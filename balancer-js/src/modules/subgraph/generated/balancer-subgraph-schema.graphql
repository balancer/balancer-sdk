"""
creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API.
"""
directive @derivedFrom(field: String!) on FIELD_DEFINITION

"""
Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive.
"""
directive @entity on OBJECT

"""Defined a Subgraph ID for an object type"""
directive @subgraphId(id: String!) on OBJECT

type AmpUpdate {
  endAmp: BigInt!
  endTimestamp: BigInt!
  id: ID!
  poolId: Pool!
  scheduledTimestamp: Int!
  startAmp: BigInt!
  startTimestamp: BigInt!
}

input AmpUpdate_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  endAmp: BigInt
  endAmp_gt: BigInt
  endAmp_gte: BigInt
  endAmp_in: [BigInt!]
  endAmp_lt: BigInt
  endAmp_lte: BigInt
  endAmp_not: BigInt
  endAmp_not_in: [BigInt!]
  endTimestamp: BigInt
  endTimestamp_gt: BigInt
  endTimestamp_gte: BigInt
  endTimestamp_in: [BigInt!]
  endTimestamp_lt: BigInt
  endTimestamp_lte: BigInt
  endTimestamp_not: BigInt
  endTimestamp_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  poolId: String
  poolId_contains: String
  poolId_contains_nocase: String
  poolId_ends_with: String
  poolId_ends_with_nocase: String
  poolId_gt: String
  poolId_gte: String
  poolId_in: [String!]
  poolId_lt: String
  poolId_lte: String
  poolId_not: String
  poolId_not_contains: String
  poolId_not_contains_nocase: String
  poolId_not_ends_with: String
  poolId_not_ends_with_nocase: String
  poolId_not_in: [String!]
  poolId_not_starts_with: String
  poolId_not_starts_with_nocase: String
  poolId_starts_with: String
  poolId_starts_with_nocase: String
  scheduledTimestamp: Int
  scheduledTimestamp_gt: Int
  scheduledTimestamp_gte: Int
  scheduledTimestamp_in: [Int!]
  scheduledTimestamp_lt: Int
  scheduledTimestamp_lte: Int
  scheduledTimestamp_not: Int
  scheduledTimestamp_not_in: [Int!]
  startAmp: BigInt
  startAmp_gt: BigInt
  startAmp_gte: BigInt
  startAmp_in: [BigInt!]
  startAmp_lt: BigInt
  startAmp_lte: BigInt
  startAmp_not: BigInt
  startAmp_not_in: [BigInt!]
  startTimestamp: BigInt
  startTimestamp_gt: BigInt
  startTimestamp_gte: BigInt
  startTimestamp_in: [BigInt!]
  startTimestamp_lt: BigInt
  startTimestamp_lte: BigInt
  startTimestamp_not: BigInt
  startTimestamp_not_in: [BigInt!]
}

enum AmpUpdate_orderBy {
  endAmp
  endTimestamp
  id
  poolId
  scheduledTimestamp
  startAmp
  startTimestamp
}

type Balancer {
  id: ID!
  poolCount: Int!
  pools(first: Int = 100, orderBy: Pool_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Pool_filter): [Pool!]
  totalLiquidity: BigDecimal!
  totalSwapCount: BigInt!
  totalSwapFee: BigDecimal!
  totalSwapVolume: BigDecimal!
}

type BalancerSnapshot {
  id: ID!
  poolCount: Int!
  timestamp: Int!
  totalLiquidity: BigDecimal!
  totalSwapCount: BigInt!
  totalSwapFee: BigDecimal!
  totalSwapVolume: BigDecimal!
  vault: Balancer!
}

input BalancerSnapshot_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  poolCount: Int
  poolCount_gt: Int
  poolCount_gte: Int
  poolCount_in: [Int!]
  poolCount_lt: Int
  poolCount_lte: Int
  poolCount_not: Int
  poolCount_not_in: [Int!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  totalLiquidity: BigDecimal
  totalLiquidity_gt: BigDecimal
  totalLiquidity_gte: BigDecimal
  totalLiquidity_in: [BigDecimal!]
  totalLiquidity_lt: BigDecimal
  totalLiquidity_lte: BigDecimal
  totalLiquidity_not: BigDecimal
  totalLiquidity_not_in: [BigDecimal!]
  totalSwapCount: BigInt
  totalSwapCount_gt: BigInt
  totalSwapCount_gte: BigInt
  totalSwapCount_in: [BigInt!]
  totalSwapCount_lt: BigInt
  totalSwapCount_lte: BigInt
  totalSwapCount_not: BigInt
  totalSwapCount_not_in: [BigInt!]
  totalSwapFee: BigDecimal
  totalSwapFee_gt: BigDecimal
  totalSwapFee_gte: BigDecimal
  totalSwapFee_in: [BigDecimal!]
  totalSwapFee_lt: BigDecimal
  totalSwapFee_lte: BigDecimal
  totalSwapFee_not: BigDecimal
  totalSwapFee_not_in: [BigDecimal!]
  totalSwapVolume: BigDecimal
  totalSwapVolume_gt: BigDecimal
  totalSwapVolume_gte: BigDecimal
  totalSwapVolume_in: [BigDecimal!]
  totalSwapVolume_lt: BigDecimal
  totalSwapVolume_lte: BigDecimal
  totalSwapVolume_not: BigDecimal
  totalSwapVolume_not_in: [BigDecimal!]
  vault: String
  vault_contains: String
  vault_contains_nocase: String
  vault_ends_with: String
  vault_ends_with_nocase: String
  vault_gt: String
  vault_gte: String
  vault_in: [String!]
  vault_lt: String
  vault_lte: String
  vault_not: String
  vault_not_contains: String
  vault_not_contains_nocase: String
  vault_not_ends_with: String
  vault_not_ends_with_nocase: String
  vault_not_in: [String!]
  vault_not_starts_with: String
  vault_not_starts_with_nocase: String
  vault_starts_with: String
  vault_starts_with_nocase: String
}

enum BalancerSnapshot_orderBy {
  id
  poolCount
  timestamp
  totalLiquidity
  totalSwapCount
  totalSwapFee
  totalSwapVolume
  vault
}

input Balancer_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  poolCount: Int
  poolCount_gt: Int
  poolCount_gte: Int
  poolCount_in: [Int!]
  poolCount_lt: Int
  poolCount_lte: Int
  poolCount_not: Int
  poolCount_not_in: [Int!]
  totalLiquidity: BigDecimal
  totalLiquidity_gt: BigDecimal
  totalLiquidity_gte: BigDecimal
  totalLiquidity_in: [BigDecimal!]
  totalLiquidity_lt: BigDecimal
  totalLiquidity_lte: BigDecimal
  totalLiquidity_not: BigDecimal
  totalLiquidity_not_in: [BigDecimal!]
  totalSwapCount: BigInt
  totalSwapCount_gt: BigInt
  totalSwapCount_gte: BigInt
  totalSwapCount_in: [BigInt!]
  totalSwapCount_lt: BigInt
  totalSwapCount_lte: BigInt
  totalSwapCount_not: BigInt
  totalSwapCount_not_in: [BigInt!]
  totalSwapFee: BigDecimal
  totalSwapFee_gt: BigDecimal
  totalSwapFee_gte: BigDecimal
  totalSwapFee_in: [BigDecimal!]
  totalSwapFee_lt: BigDecimal
  totalSwapFee_lte: BigDecimal
  totalSwapFee_not: BigDecimal
  totalSwapFee_not_in: [BigDecimal!]
  totalSwapVolume: BigDecimal
  totalSwapVolume_gt: BigDecimal
  totalSwapVolume_gte: BigDecimal
  totalSwapVolume_in: [BigDecimal!]
  totalSwapVolume_lt: BigDecimal
  totalSwapVolume_lte: BigDecimal
  totalSwapVolume_not: BigDecimal
  totalSwapVolume_not_in: [BigDecimal!]
}

enum Balancer_orderBy {
  id
  poolCount
  pools
  totalLiquidity
  totalSwapCount
  totalSwapFee
  totalSwapVolume
}

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
  number_gte: Int!
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

scalar Bytes

type GradualWeightUpdate {
  endTimestamp: BigInt!
  endWeights: [BigInt!]!
  id: ID!
  poolId: Pool!
  scheduledTimestamp: Int!
  startTimestamp: BigInt!
  startWeights: [BigInt!]!
}

input GradualWeightUpdate_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  endTimestamp: BigInt
  endTimestamp_gt: BigInt
  endTimestamp_gte: BigInt
  endTimestamp_in: [BigInt!]
  endTimestamp_lt: BigInt
  endTimestamp_lte: BigInt
  endTimestamp_not: BigInt
  endTimestamp_not_in: [BigInt!]
  endWeights: [BigInt!]
  endWeights_contains: [BigInt!]
  endWeights_contains_nocase: [BigInt!]
  endWeights_not: [BigInt!]
  endWeights_not_contains: [BigInt!]
  endWeights_not_contains_nocase: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  poolId: String
  poolId_contains: String
  poolId_contains_nocase: String
  poolId_ends_with: String
  poolId_ends_with_nocase: String
  poolId_gt: String
  poolId_gte: String
  poolId_in: [String!]
  poolId_lt: String
  poolId_lte: String
  poolId_not: String
  poolId_not_contains: String
  poolId_not_contains_nocase: String
  poolId_not_ends_with: String
  poolId_not_ends_with_nocase: String
  poolId_not_in: [String!]
  poolId_not_starts_with: String
  poolId_not_starts_with_nocase: String
  poolId_starts_with: String
  poolId_starts_with_nocase: String
  scheduledTimestamp: Int
  scheduledTimestamp_gt: Int
  scheduledTimestamp_gte: Int
  scheduledTimestamp_in: [Int!]
  scheduledTimestamp_lt: Int
  scheduledTimestamp_lte: Int
  scheduledTimestamp_not: Int
  scheduledTimestamp_not_in: [Int!]
  startTimestamp: BigInt
  startTimestamp_gt: BigInt
  startTimestamp_gte: BigInt
  startTimestamp_in: [BigInt!]
  startTimestamp_lt: BigInt
  startTimestamp_lte: BigInt
  startTimestamp_not: BigInt
  startTimestamp_not_in: [BigInt!]
  startWeights: [BigInt!]
  startWeights_contains: [BigInt!]
  startWeights_contains_nocase: [BigInt!]
  startWeights_not: [BigInt!]
  startWeights_not_contains: [BigInt!]
  startWeights_not_contains_nocase: [BigInt!]
}

enum GradualWeightUpdate_orderBy {
  endTimestamp
  endWeights
  id
  poolId
  scheduledTimestamp
  startTimestamp
  startWeights
}

enum InvestType {
  Exit
  Join
}

type Investment {
  amount: BigDecimal!
  assetManagerAddress: Bytes!
  id: ID!
  poolTokenId: PoolToken!
  timestamp: Int!
}

input Investment_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  amount: BigDecimal
  amount_gt: BigDecimal
  amount_gte: BigDecimal
  amount_in: [BigDecimal!]
  amount_lt: BigDecimal
  amount_lte: BigDecimal
  amount_not: BigDecimal
  amount_not_in: [BigDecimal!]
  assetManagerAddress: Bytes
  assetManagerAddress_contains: Bytes
  assetManagerAddress_in: [Bytes!]
  assetManagerAddress_not: Bytes
  assetManagerAddress_not_contains: Bytes
  assetManagerAddress_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  poolTokenId: String
  poolTokenId_contains: String
  poolTokenId_contains_nocase: String
  poolTokenId_ends_with: String
  poolTokenId_ends_with_nocase: String
  poolTokenId_gt: String
  poolTokenId_gte: String
  poolTokenId_in: [String!]
  poolTokenId_lt: String
  poolTokenId_lte: String
  poolTokenId_not: String
  poolTokenId_not_contains: String
  poolTokenId_not_contains_nocase: String
  poolTokenId_not_ends_with: String
  poolTokenId_not_ends_with_nocase: String
  poolTokenId_not_in: [String!]
  poolTokenId_not_starts_with: String
  poolTokenId_not_starts_with_nocase: String
  poolTokenId_starts_with: String
  poolTokenId_starts_with_nocase: String
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
}

enum Investment_orderBy {
  amount
  assetManagerAddress
  id
  poolTokenId
  timestamp
}

type JoinExit {
  amounts: [BigDecimal!]!
  id: ID!
  pool: Pool!
  sender: Bytes!
  timestamp: Int!
  tx: Bytes!
  type: InvestType!
  user: User!
}

input JoinExit_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  amounts: [BigDecimal!]
  amounts_contains: [BigDecimal!]
  amounts_contains_nocase: [BigDecimal!]
  amounts_not: [BigDecimal!]
  amounts_not_contains: [BigDecimal!]
  amounts_not_contains_nocase: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  pool: String
  pool_contains: String
  pool_contains_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  sender: Bytes
  sender_contains: Bytes
  sender_in: [Bytes!]
  sender_not: Bytes
  sender_not_contains: Bytes
  sender_not_in: [Bytes!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  tx: Bytes
  tx_contains: Bytes
  tx_in: [Bytes!]
  tx_not: Bytes
  tx_not_contains: Bytes
  tx_not_in: [Bytes!]
  type: InvestType
  type_in: [InvestType!]
  type_not: InvestType
  type_not_in: [InvestType!]
  user: String
  user_contains: String
  user_contains_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
}

enum JoinExit_orderBy {
  amounts
  id
  pool
  sender
  timestamp
  tx
  type
  user
}

type LatestPrice {
  asset: Bytes!
  block: BigInt!
  id: ID!
  poolId: Pool!
  price: BigDecimal!
  pricingAsset: Bytes!
}

input LatestPrice_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  asset: Bytes
  asset_contains: Bytes
  asset_in: [Bytes!]
  asset_not: Bytes
  asset_not_contains: Bytes
  asset_not_in: [Bytes!]
  block: BigInt
  block_gt: BigInt
  block_gte: BigInt
  block_in: [BigInt!]
  block_lt: BigInt
  block_lte: BigInt
  block_not: BigInt
  block_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  poolId: String
  poolId_contains: String
  poolId_contains_nocase: String
  poolId_ends_with: String
  poolId_ends_with_nocase: String
  poolId_gt: String
  poolId_gte: String
  poolId_in: [String!]
  poolId_lt: String
  poolId_lte: String
  poolId_not: String
  poolId_not_contains: String
  poolId_not_contains_nocase: String
  poolId_not_ends_with: String
  poolId_not_ends_with_nocase: String
  poolId_not_in: [String!]
  poolId_not_starts_with: String
  poolId_not_starts_with_nocase: String
  poolId_starts_with: String
  poolId_starts_with_nocase: String
  price: BigDecimal
  price_gt: BigDecimal
  price_gte: BigDecimal
  price_in: [BigDecimal!]
  price_lt: BigDecimal
  price_lte: BigDecimal
  price_not: BigDecimal
  price_not_in: [BigDecimal!]
  pricingAsset: Bytes
  pricingAsset_contains: Bytes
  pricingAsset_in: [Bytes!]
  pricingAsset_not: Bytes
  pricingAsset_not_contains: Bytes
  pricingAsset_not_in: [Bytes!]
}

enum LatestPrice_orderBy {
  asset
  block
  id
  poolId
  price
  pricingAsset
}

"""Defines the order direction, either ascending or descending"""
enum OrderDirection {
  asc
  desc
}

type Pool {
  address: Bytes!
  amp: BigInt
  baseToken: Bytes
  createTime: Int!
  expiryTime: BigInt
  factory: Bytes
  historicalValues(first: Int = 100, orderBy: PoolHistoricalLiquidity_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: PoolHistoricalLiquidity_filter): [PoolHistoricalLiquidity!]
  holdersCount: BigInt!
  id: ID!
  lowerTarget: BigDecimal
  mainIndex: Int
  managementFee: BigDecimal
  name: String
  owner: Bytes
  poolType: String
  priceRateProviders(first: Int = 100, orderBy: PriceRateProvider_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: PriceRateProvider_filter): [PriceRateProvider!]
  principalToken: Bytes
  shares(first: Int = 100, orderBy: PoolShare_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: PoolShare_filter): [PoolShare!]
  strategyType: Int!
  swapEnabled: Boolean!
  swapFee: BigDecimal!
  swaps(first: Int = 100, orderBy: Swap_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Swap_filter): [Swap!]
  swapsCount: BigInt!
  symbol: String
  tokens(first: Int = 100, orderBy: PoolToken_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: PoolToken_filter): [PoolToken!]
  tokensList: [Bytes!]!
  totalLiquidity: BigDecimal!
  totalShares: BigDecimal!
  totalSwapFee: BigDecimal!
  totalSwapVolume: BigDecimal!
  totalWeight: BigDecimal
  tx: Bytes
  unitSeconds: BigInt
  upperTarget: BigDecimal
  vaultID: Balancer!
  weightUpdates(first: Int = 100, orderBy: GradualWeightUpdate_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: GradualWeightUpdate_filter): [GradualWeightUpdate!]
  wrappedIndex: Int
}

type PoolHistoricalLiquidity {
  block: BigInt!
  id: ID!
  poolId: Pool!
  poolLiquidity: BigDecimal!
  poolShareValue: BigDecimal!
  poolTotalShares: BigDecimal!
  pricingAsset: Bytes!
}

input PoolHistoricalLiquidity_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  block: BigInt
  block_gt: BigInt
  block_gte: BigInt
  block_in: [BigInt!]
  block_lt: BigInt
  block_lte: BigInt
  block_not: BigInt
  block_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  poolId: String
  poolId_contains: String
  poolId_contains_nocase: String
  poolId_ends_with: String
  poolId_ends_with_nocase: String
  poolId_gt: String
  poolId_gte: String
  poolId_in: [String!]
  poolId_lt: String
  poolId_lte: String
  poolId_not: String
  poolId_not_contains: String
  poolId_not_contains_nocase: String
  poolId_not_ends_with: String
  poolId_not_ends_with_nocase: String
  poolId_not_in: [String!]
  poolId_not_starts_with: String
  poolId_not_starts_with_nocase: String
  poolId_starts_with: String
  poolId_starts_with_nocase: String
  poolLiquidity: BigDecimal
  poolLiquidity_gt: BigDecimal
  poolLiquidity_gte: BigDecimal
  poolLiquidity_in: [BigDecimal!]
  poolLiquidity_lt: BigDecimal
  poolLiquidity_lte: BigDecimal
  poolLiquidity_not: BigDecimal
  poolLiquidity_not_in: [BigDecimal!]
  poolShareValue: BigDecimal
  poolShareValue_gt: BigDecimal
  poolShareValue_gte: BigDecimal
  poolShareValue_in: [BigDecimal!]
  poolShareValue_lt: BigDecimal
  poolShareValue_lte: BigDecimal
  poolShareValue_not: BigDecimal
  poolShareValue_not_in: [BigDecimal!]
  poolTotalShares: BigDecimal
  poolTotalShares_gt: BigDecimal
  poolTotalShares_gte: BigDecimal
  poolTotalShares_in: [BigDecimal!]
  poolTotalShares_lt: BigDecimal
  poolTotalShares_lte: BigDecimal
  poolTotalShares_not: BigDecimal
  poolTotalShares_not_in: [BigDecimal!]
  pricingAsset: Bytes
  pricingAsset_contains: Bytes
  pricingAsset_in: [Bytes!]
  pricingAsset_not: Bytes
  pricingAsset_not_contains: Bytes
  pricingAsset_not_in: [Bytes!]
}

enum PoolHistoricalLiquidity_orderBy {
  block
  id
  poolId
  poolLiquidity
  poolShareValue
  poolTotalShares
  pricingAsset
}

type PoolShare {
  balance: BigDecimal!
  id: ID!
  poolId: Pool!
  userAddress: User!
}

input PoolShare_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  balance: BigDecimal
  balance_gt: BigDecimal
  balance_gte: BigDecimal
  balance_in: [BigDecimal!]
  balance_lt: BigDecimal
  balance_lte: BigDecimal
  balance_not: BigDecimal
  balance_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  poolId: String
  poolId_contains: String
  poolId_contains_nocase: String
  poolId_ends_with: String
  poolId_ends_with_nocase: String
  poolId_gt: String
  poolId_gte: String
  poolId_in: [String!]
  poolId_lt: String
  poolId_lte: String
  poolId_not: String
  poolId_not_contains: String
  poolId_not_contains_nocase: String
  poolId_not_ends_with: String
  poolId_not_ends_with_nocase: String
  poolId_not_in: [String!]
  poolId_not_starts_with: String
  poolId_not_starts_with_nocase: String
  poolId_starts_with: String
  poolId_starts_with_nocase: String
  userAddress: String
  userAddress_contains: String
  userAddress_contains_nocase: String
  userAddress_ends_with: String
  userAddress_ends_with_nocase: String
  userAddress_gt: String
  userAddress_gte: String
  userAddress_in: [String!]
  userAddress_lt: String
  userAddress_lte: String
  userAddress_not: String
  userAddress_not_contains: String
  userAddress_not_contains_nocase: String
  userAddress_not_ends_with: String
  userAddress_not_ends_with_nocase: String
  userAddress_not_in: [String!]
  userAddress_not_starts_with: String
  userAddress_not_starts_with_nocase: String
  userAddress_starts_with: String
  userAddress_starts_with_nocase: String
}

enum PoolShare_orderBy {
  balance
  id
  poolId
  userAddress
}

type PoolSnapshot {
  amounts: [BigDecimal!]!
  id: ID!
  liquidity: BigDecimal!
  pool: Pool!
  swapFees: BigDecimal!
  swapVolume: BigDecimal!
  timestamp: Int!
  totalShares: BigDecimal!
}

input PoolSnapshot_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  amounts: [BigDecimal!]
  amounts_contains: [BigDecimal!]
  amounts_contains_nocase: [BigDecimal!]
  amounts_not: [BigDecimal!]
  amounts_not_contains: [BigDecimal!]
  amounts_not_contains_nocase: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  liquidity: BigDecimal
  liquidity_gt: BigDecimal
  liquidity_gte: BigDecimal
  liquidity_in: [BigDecimal!]
  liquidity_lt: BigDecimal
  liquidity_lte: BigDecimal
  liquidity_not: BigDecimal
  liquidity_not_in: [BigDecimal!]
  pool: String
  pool_contains: String
  pool_contains_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  swapFees: BigDecimal
  swapFees_gt: BigDecimal
  swapFees_gte: BigDecimal
  swapFees_in: [BigDecimal!]
  swapFees_lt: BigDecimal
  swapFees_lte: BigDecimal
  swapFees_not: BigDecimal
  swapFees_not_in: [BigDecimal!]
  swapVolume: BigDecimal
  swapVolume_gt: BigDecimal
  swapVolume_gte: BigDecimal
  swapVolume_in: [BigDecimal!]
  swapVolume_lt: BigDecimal
  swapVolume_lte: BigDecimal
  swapVolume_not: BigDecimal
  swapVolume_not_in: [BigDecimal!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  totalShares: BigDecimal
  totalShares_gt: BigDecimal
  totalShares_gte: BigDecimal
  totalShares_in: [BigDecimal!]
  totalShares_lt: BigDecimal
  totalShares_lte: BigDecimal
  totalShares_not: BigDecimal
  totalShares_not_in: [BigDecimal!]
}

enum PoolSnapshot_orderBy {
  amounts
  id
  liquidity
  pool
  swapFees
  swapVolume
  timestamp
  totalShares
}

type PoolToken {
  address: String!
  balance: BigDecimal!
  decimals: Int!
  id: ID!
  invested: BigDecimal!
  investments(first: Int = 100, orderBy: Investment_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Investment_filter): [Investment!]
  name: String!
  poolId: Pool!
  priceRate: BigDecimal!
  symbol: String!
  token: Token!
  weight: BigDecimal
}

input PoolToken_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  address: String
  address_contains: String
  address_contains_nocase: String
  address_ends_with: String
  address_ends_with_nocase: String
  address_gt: String
  address_gte: String
  address_in: [String!]
  address_lt: String
  address_lte: String
  address_not: String
  address_not_contains: String
  address_not_contains_nocase: String
  address_not_ends_with: String
  address_not_ends_with_nocase: String
  address_not_in: [String!]
  address_not_starts_with: String
  address_not_starts_with_nocase: String
  address_starts_with: String
  address_starts_with_nocase: String
  balance: BigDecimal
  balance_gt: BigDecimal
  balance_gte: BigDecimal
  balance_in: [BigDecimal!]
  balance_lt: BigDecimal
  balance_lte: BigDecimal
  balance_not: BigDecimal
  balance_not_in: [BigDecimal!]
  decimals: Int
  decimals_gt: Int
  decimals_gte: Int
  decimals_in: [Int!]
  decimals_lt: Int
  decimals_lte: Int
  decimals_not: Int
  decimals_not_in: [Int!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  invested: BigDecimal
  invested_gt: BigDecimal
  invested_gte: BigDecimal
  invested_in: [BigDecimal!]
  invested_lt: BigDecimal
  invested_lte: BigDecimal
  invested_not: BigDecimal
  invested_not_in: [BigDecimal!]
  name: String
  name_contains: String
  name_contains_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  poolId: String
  poolId_contains: String
  poolId_contains_nocase: String
  poolId_ends_with: String
  poolId_ends_with_nocase: String
  poolId_gt: String
  poolId_gte: String
  poolId_in: [String!]
  poolId_lt: String
  poolId_lte: String
  poolId_not: String
  poolId_not_contains: String
  poolId_not_contains_nocase: String
  poolId_not_ends_with: String
  poolId_not_ends_with_nocase: String
  poolId_not_in: [String!]
  poolId_not_starts_with: String
  poolId_not_starts_with_nocase: String
  poolId_starts_with: String
  poolId_starts_with_nocase: String
  priceRate: BigDecimal
  priceRate_gt: BigDecimal
  priceRate_gte: BigDecimal
  priceRate_in: [BigDecimal!]
  priceRate_lt: BigDecimal
  priceRate_lte: BigDecimal
  priceRate_not: BigDecimal
  priceRate_not_in: [BigDecimal!]
  symbol: String
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_gt: String
  symbol_gte: String
  symbol_in: [String!]
  symbol_lt: String
  symbol_lte: String
  symbol_not: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  symbol_not_in: [String!]
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  token: String
  token_contains: String
  token_contains_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  weight: BigDecimal
  weight_gt: BigDecimal
  weight_gte: BigDecimal
  weight_in: [BigDecimal!]
  weight_lt: BigDecimal
  weight_lte: BigDecimal
  weight_not: BigDecimal
  weight_not_in: [BigDecimal!]
}

enum PoolToken_orderBy {
  address
  balance
  decimals
  id
  invested
  investments
  name
  poolId
  priceRate
  symbol
  token
  weight
}

input Pool_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  address: Bytes
  address_contains: Bytes
  address_in: [Bytes!]
  address_not: Bytes
  address_not_contains: Bytes
  address_not_in: [Bytes!]
  amp: BigInt
  amp_gt: BigInt
  amp_gte: BigInt
  amp_in: [BigInt!]
  amp_lt: BigInt
  amp_lte: BigInt
  amp_not: BigInt
  amp_not_in: [BigInt!]
  baseToken: Bytes
  baseToken_contains: Bytes
  baseToken_in: [Bytes!]
  baseToken_not: Bytes
  baseToken_not_contains: Bytes
  baseToken_not_in: [Bytes!]
  createTime: Int
  createTime_gt: Int
  createTime_gte: Int
  createTime_in: [Int!]
  createTime_lt: Int
  createTime_lte: Int
  createTime_not: Int
  createTime_not_in: [Int!]
  expiryTime: BigInt
  expiryTime_gt: BigInt
  expiryTime_gte: BigInt
  expiryTime_in: [BigInt!]
  expiryTime_lt: BigInt
  expiryTime_lte: BigInt
  expiryTime_not: BigInt
  expiryTime_not_in: [BigInt!]
  factory: Bytes
  factory_contains: Bytes
  factory_in: [Bytes!]
  factory_not: Bytes
  factory_not_contains: Bytes
  factory_not_in: [Bytes!]
  holdersCount: BigInt
  holdersCount_gt: BigInt
  holdersCount_gte: BigInt
  holdersCount_in: [BigInt!]
  holdersCount_lt: BigInt
  holdersCount_lte: BigInt
  holdersCount_not: BigInt
  holdersCount_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lowerTarget: BigDecimal
  lowerTarget_gt: BigDecimal
  lowerTarget_gte: BigDecimal
  lowerTarget_in: [BigDecimal!]
  lowerTarget_lt: BigDecimal
  lowerTarget_lte: BigDecimal
  lowerTarget_not: BigDecimal
  lowerTarget_not_in: [BigDecimal!]
  mainIndex: Int
  mainIndex_gt: Int
  mainIndex_gte: Int
  mainIndex_in: [Int!]
  mainIndex_lt: Int
  mainIndex_lte: Int
  mainIndex_not: Int
  mainIndex_not_in: [Int!]
  managementFee: BigDecimal
  managementFee_gt: BigDecimal
  managementFee_gte: BigDecimal
  managementFee_in: [BigDecimal!]
  managementFee_lt: BigDecimal
  managementFee_lte: BigDecimal
  managementFee_not: BigDecimal
  managementFee_not_in: [BigDecimal!]
  name: String
  name_contains: String
  name_contains_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  owner: Bytes
  owner_contains: Bytes
  owner_in: [Bytes!]
  owner_not: Bytes
  owner_not_contains: Bytes
  owner_not_in: [Bytes!]
  poolType: String
  poolType_contains: String
  poolType_contains_nocase: String
  poolType_ends_with: String
  poolType_ends_with_nocase: String
  poolType_gt: String
  poolType_gte: String
  poolType_in: [String!]
  poolType_lt: String
  poolType_lte: String
  poolType_not: String
  poolType_not_contains: String
  poolType_not_contains_nocase: String
  poolType_not_ends_with: String
  poolType_not_ends_with_nocase: String
  poolType_not_in: [String!]
  poolType_not_starts_with: String
  poolType_not_starts_with_nocase: String
  poolType_starts_with: String
  poolType_starts_with_nocase: String
  principalToken: Bytes
  principalToken_contains: Bytes
  principalToken_in: [Bytes!]
  principalToken_not: Bytes
  principalToken_not_contains: Bytes
  principalToken_not_in: [Bytes!]
  strategyType: Int
  strategyType_gt: Int
  strategyType_gte: Int
  strategyType_in: [Int!]
  strategyType_lt: Int
  strategyType_lte: Int
  strategyType_not: Int
  strategyType_not_in: [Int!]
  swapEnabled: Boolean
  swapEnabled_in: [Boolean!]
  swapEnabled_not: Boolean
  swapEnabled_not_in: [Boolean!]
  swapFee: BigDecimal
  swapFee_gt: BigDecimal
  swapFee_gte: BigDecimal
  swapFee_in: [BigDecimal!]
  swapFee_lt: BigDecimal
  swapFee_lte: BigDecimal
  swapFee_not: BigDecimal
  swapFee_not_in: [BigDecimal!]
  swapsCount: BigInt
  swapsCount_gt: BigInt
  swapsCount_gte: BigInt
  swapsCount_in: [BigInt!]
  swapsCount_lt: BigInt
  swapsCount_lte: BigInt
  swapsCount_not: BigInt
  swapsCount_not_in: [BigInt!]
  symbol: String
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_gt: String
  symbol_gte: String
  symbol_in: [String!]
  symbol_lt: String
  symbol_lte: String
  symbol_not: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  symbol_not_in: [String!]
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  tokensList: [Bytes!]
  tokensList_contains: [Bytes!]
  tokensList_contains_nocase: [Bytes!]
  tokensList_not: [Bytes!]
  tokensList_not_contains: [Bytes!]
  tokensList_not_contains_nocase: [Bytes!]
  totalLiquidity: BigDecimal
  totalLiquidity_gt: BigDecimal
  totalLiquidity_gte: BigDecimal
  totalLiquidity_in: [BigDecimal!]
  totalLiquidity_lt: BigDecimal
  totalLiquidity_lte: BigDecimal
  totalLiquidity_not: BigDecimal
  totalLiquidity_not_in: [BigDecimal!]
  totalShares: BigDecimal
  totalShares_gt: BigDecimal
  totalShares_gte: BigDecimal
  totalShares_in: [BigDecimal!]
  totalShares_lt: BigDecimal
  totalShares_lte: BigDecimal
  totalShares_not: BigDecimal
  totalShares_not_in: [BigDecimal!]
  totalSwapFee: BigDecimal
  totalSwapFee_gt: BigDecimal
  totalSwapFee_gte: BigDecimal
  totalSwapFee_in: [BigDecimal!]
  totalSwapFee_lt: BigDecimal
  totalSwapFee_lte: BigDecimal
  totalSwapFee_not: BigDecimal
  totalSwapFee_not_in: [BigDecimal!]
  totalSwapVolume: BigDecimal
  totalSwapVolume_gt: BigDecimal
  totalSwapVolume_gte: BigDecimal
  totalSwapVolume_in: [BigDecimal!]
  totalSwapVolume_lt: BigDecimal
  totalSwapVolume_lte: BigDecimal
  totalSwapVolume_not: BigDecimal
  totalSwapVolume_not_in: [BigDecimal!]
  totalWeight: BigDecimal
  totalWeight_gt: BigDecimal
  totalWeight_gte: BigDecimal
  totalWeight_in: [BigDecimal!]
  totalWeight_lt: BigDecimal
  totalWeight_lte: BigDecimal
  totalWeight_not: BigDecimal
  totalWeight_not_in: [BigDecimal!]
  tx: Bytes
  tx_contains: Bytes
  tx_in: [Bytes!]
  tx_not: Bytes
  tx_not_contains: Bytes
  tx_not_in: [Bytes!]
  unitSeconds: BigInt
  unitSeconds_gt: BigInt
  unitSeconds_gte: BigInt
  unitSeconds_in: [BigInt!]
  unitSeconds_lt: BigInt
  unitSeconds_lte: BigInt
  unitSeconds_not: BigInt
  unitSeconds_not_in: [BigInt!]
  upperTarget: BigDecimal
  upperTarget_gt: BigDecimal
  upperTarget_gte: BigDecimal
  upperTarget_in: [BigDecimal!]
  upperTarget_lt: BigDecimal
  upperTarget_lte: BigDecimal
  upperTarget_not: BigDecimal
  upperTarget_not_in: [BigDecimal!]
  vaultID: String
  vaultID_contains: String
  vaultID_contains_nocase: String
  vaultID_ends_with: String
  vaultID_ends_with_nocase: String
  vaultID_gt: String
  vaultID_gte: String
  vaultID_in: [String!]
  vaultID_lt: String
  vaultID_lte: String
  vaultID_not: String
  vaultID_not_contains: String
  vaultID_not_contains_nocase: String
  vaultID_not_ends_with: String
  vaultID_not_ends_with_nocase: String
  vaultID_not_in: [String!]
  vaultID_not_starts_with: String
  vaultID_not_starts_with_nocase: String
  vaultID_starts_with: String
  vaultID_starts_with_nocase: String
  wrappedIndex: Int
  wrappedIndex_gt: Int
  wrappedIndex_gte: Int
  wrappedIndex_in: [Int!]
  wrappedIndex_lt: Int
  wrappedIndex_lte: Int
  wrappedIndex_not: Int
  wrappedIndex_not_in: [Int!]
}

enum Pool_orderBy {
  address
  amp
  baseToken
  createTime
  expiryTime
  factory
  historicalValues
  holdersCount
  id
  lowerTarget
  mainIndex
  managementFee
  name
  owner
  poolType
  priceRateProviders
  principalToken
  shares
  strategyType
  swapEnabled
  swapFee
  swaps
  swapsCount
  symbol
  tokens
  tokensList
  totalLiquidity
  totalShares
  totalSwapFee
  totalSwapVolume
  totalWeight
  tx
  unitSeconds
  upperTarget
  vaultID
  weightUpdates
  wrappedIndex
}

type PriceRateProvider {
  address: Bytes!
  cacheDuration: Int!
  cacheExpiry: Int!
  id: ID!
  lastCached: Int!
  poolId: Pool!
  rate: BigDecimal!
  token: PoolToken!
}

input PriceRateProvider_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  address: Bytes
  address_contains: Bytes
  address_in: [Bytes!]
  address_not: Bytes
  address_not_contains: Bytes
  address_not_in: [Bytes!]
  cacheDuration: Int
  cacheDuration_gt: Int
  cacheDuration_gte: Int
  cacheDuration_in: [Int!]
  cacheDuration_lt: Int
  cacheDuration_lte: Int
  cacheDuration_not: Int
  cacheDuration_not_in: [Int!]
  cacheExpiry: Int
  cacheExpiry_gt: Int
  cacheExpiry_gte: Int
  cacheExpiry_in: [Int!]
  cacheExpiry_lt: Int
  cacheExpiry_lte: Int
  cacheExpiry_not: Int
  cacheExpiry_not_in: [Int!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lastCached: Int
  lastCached_gt: Int
  lastCached_gte: Int
  lastCached_in: [Int!]
  lastCached_lt: Int
  lastCached_lte: Int
  lastCached_not: Int
  lastCached_not_in: [Int!]
  poolId: String
  poolId_contains: String
  poolId_contains_nocase: String
  poolId_ends_with: String
  poolId_ends_with_nocase: String
  poolId_gt: String
  poolId_gte: String
  poolId_in: [String!]
  poolId_lt: String
  poolId_lte: String
  poolId_not: String
  poolId_not_contains: String
  poolId_not_contains_nocase: String
  poolId_not_ends_with: String
  poolId_not_ends_with_nocase: String
  poolId_not_in: [String!]
  poolId_not_starts_with: String
  poolId_not_starts_with_nocase: String
  poolId_starts_with: String
  poolId_starts_with_nocase: String
  rate: BigDecimal
  rate_gt: BigDecimal
  rate_gte: BigDecimal
  rate_in: [BigDecimal!]
  rate_lt: BigDecimal
  rate_lte: BigDecimal
  rate_not: BigDecimal
  rate_not_in: [BigDecimal!]
  token: String
  token_contains: String
  token_contains_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
}

enum PriceRateProvider_orderBy {
  address
  cacheDuration
  cacheExpiry
  id
  lastCached
  poolId
  rate
  token
}

type Query {
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
  ampUpdate(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AmpUpdate
  ampUpdates(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: AmpUpdate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: AmpUpdate_filter
  ): [AmpUpdate!]!
  balancer(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Balancer
  balancerSnapshot(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BalancerSnapshot
  balancerSnapshots(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BalancerSnapshot_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BalancerSnapshot_filter
  ): [BalancerSnapshot!]!
  balancers(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Balancer_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Balancer_filter
  ): [Balancer!]!
  gradualWeightUpdate(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GradualWeightUpdate
  gradualWeightUpdates(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: GradualWeightUpdate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: GradualWeightUpdate_filter
  ): [GradualWeightUpdate!]!
  investment(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Investment
  investments(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Investment_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Investment_filter
  ): [Investment!]!
  joinExit(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): JoinExit
  joinExits(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: JoinExit_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: JoinExit_filter
  ): [JoinExit!]!
  latestPrice(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LatestPrice
  latestPrices(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LatestPrice_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LatestPrice_filter
  ): [LatestPrice!]!
  pool(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Pool
  poolHistoricalLiquidities(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolHistoricalLiquidity_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolHistoricalLiquidity_filter
  ): [PoolHistoricalLiquidity!]!
  poolHistoricalLiquidity(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolHistoricalLiquidity
  poolShare(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolShare
  poolShares(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolShare_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolShare_filter
  ): [PoolShare!]!
  poolSnapshot(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolSnapshot
  poolSnapshots(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolSnapshot_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolSnapshot_filter
  ): [PoolSnapshot!]!
  poolToken(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolToken
  poolTokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolToken_filter
  ): [PoolToken!]!
  pools(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Pool_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Pool_filter
  ): [Pool!]!
  priceRateProvider(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PriceRateProvider
  priceRateProviders(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PriceRateProvider_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PriceRateProvider_filter
  ): [PriceRateProvider!]!
  swap(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Swap
  swaps(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Swap_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Swap_filter
  ): [Swap!]!
  token(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokenPrice(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenPrice
  tokenPrices(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TokenPrice_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TokenPrice_filter
  ): [TokenPrice!]!
  tokenSnapshot(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenSnapshot
  tokenSnapshots(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TokenSnapshot_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TokenSnapshot_filter
  ): [TokenSnapshot!]!
  tokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Token_filter
  ): [Token!]!
  tradePair(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TradePair
  tradePairSnapshot(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TradePairSnapshot
  tradePairSnapshots(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TradePairSnapshot_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TradePairSnapshot_filter
  ): [TradePairSnapshot!]!
  tradePairs(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TradePair_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TradePair_filter
  ): [TradePair!]!
  user(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): User
  userInternalBalance(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserInternalBalance
  userInternalBalances(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: UserInternalBalance_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: UserInternalBalance_filter
  ): [UserInternalBalance!]!
  users(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: User_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: User_filter
  ): [User!]!
}

type Subscription {
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
  ampUpdate(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AmpUpdate
  ampUpdates(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: AmpUpdate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: AmpUpdate_filter
  ): [AmpUpdate!]!
  balancer(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Balancer
  balancerSnapshot(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BalancerSnapshot
  balancerSnapshots(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BalancerSnapshot_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BalancerSnapshot_filter
  ): [BalancerSnapshot!]!
  balancers(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Balancer_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Balancer_filter
  ): [Balancer!]!
  gradualWeightUpdate(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GradualWeightUpdate
  gradualWeightUpdates(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: GradualWeightUpdate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: GradualWeightUpdate_filter
  ): [GradualWeightUpdate!]!
  investment(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Investment
  investments(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Investment_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Investment_filter
  ): [Investment!]!
  joinExit(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): JoinExit
  joinExits(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: JoinExit_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: JoinExit_filter
  ): [JoinExit!]!
  latestPrice(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LatestPrice
  latestPrices(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LatestPrice_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LatestPrice_filter
  ): [LatestPrice!]!
  pool(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Pool
  poolHistoricalLiquidities(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolHistoricalLiquidity_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolHistoricalLiquidity_filter
  ): [PoolHistoricalLiquidity!]!
  poolHistoricalLiquidity(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolHistoricalLiquidity
  poolShare(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolShare
  poolShares(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolShare_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolShare_filter
  ): [PoolShare!]!
  poolSnapshot(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolSnapshot
  poolSnapshots(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolSnapshot_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolSnapshot_filter
  ): [PoolSnapshot!]!
  poolToken(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolToken
  poolTokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolToken_filter
  ): [PoolToken!]!
  pools(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Pool_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Pool_filter
  ): [Pool!]!
  priceRateProvider(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PriceRateProvider
  priceRateProviders(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PriceRateProvider_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PriceRateProvider_filter
  ): [PriceRateProvider!]!
  swap(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Swap
  swaps(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Swap_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Swap_filter
  ): [Swap!]!
  token(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokenPrice(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenPrice
  tokenPrices(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TokenPrice_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TokenPrice_filter
  ): [TokenPrice!]!
  tokenSnapshot(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenSnapshot
  tokenSnapshots(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TokenSnapshot_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TokenSnapshot_filter
  ): [TokenSnapshot!]!
  tokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Token_filter
  ): [Token!]!
  tradePair(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TradePair
  tradePairSnapshot(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TradePairSnapshot
  tradePairSnapshots(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TradePairSnapshot_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TradePairSnapshot_filter
  ): [TradePairSnapshot!]!
  tradePairs(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TradePair_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TradePair_filter
  ): [TradePair!]!
  user(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): User
  userInternalBalance(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserInternalBalance
  userInternalBalances(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: UserInternalBalance_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: UserInternalBalance_filter
  ): [UserInternalBalance!]!
  users(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: User_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: User_filter
  ): [User!]!
}

type Swap {
  caller: Bytes!
  id: ID!
  poolId: Pool!
  timestamp: Int!
  tokenAmountIn: BigDecimal!
  tokenAmountOut: BigDecimal!
  tokenIn: Bytes!
  tokenInSym: String!
  tokenOut: Bytes!
  tokenOutSym: String!
  tx: Bytes!
  userAddress: User!
}

input Swap_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  caller: Bytes
  caller_contains: Bytes
  caller_in: [Bytes!]
  caller_not: Bytes
  caller_not_contains: Bytes
  caller_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  poolId: String
  poolId_contains: String
  poolId_contains_nocase: String
  poolId_ends_with: String
  poolId_ends_with_nocase: String
  poolId_gt: String
  poolId_gte: String
  poolId_in: [String!]
  poolId_lt: String
  poolId_lte: String
  poolId_not: String
  poolId_not_contains: String
  poolId_not_contains_nocase: String
  poolId_not_ends_with: String
  poolId_not_ends_with_nocase: String
  poolId_not_in: [String!]
  poolId_not_starts_with: String
  poolId_not_starts_with_nocase: String
  poolId_starts_with: String
  poolId_starts_with_nocase: String
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  tokenAmountIn: BigDecimal
  tokenAmountIn_gt: BigDecimal
  tokenAmountIn_gte: BigDecimal
  tokenAmountIn_in: [BigDecimal!]
  tokenAmountIn_lt: BigDecimal
  tokenAmountIn_lte: BigDecimal
  tokenAmountIn_not: BigDecimal
  tokenAmountIn_not_in: [BigDecimal!]
  tokenAmountOut: BigDecimal
  tokenAmountOut_gt: BigDecimal
  tokenAmountOut_gte: BigDecimal
  tokenAmountOut_in: [BigDecimal!]
  tokenAmountOut_lt: BigDecimal
  tokenAmountOut_lte: BigDecimal
  tokenAmountOut_not: BigDecimal
  tokenAmountOut_not_in: [BigDecimal!]
  tokenIn: Bytes
  tokenInSym: String
  tokenInSym_contains: String
  tokenInSym_contains_nocase: String
  tokenInSym_ends_with: String
  tokenInSym_ends_with_nocase: String
  tokenInSym_gt: String
  tokenInSym_gte: String
  tokenInSym_in: [String!]
  tokenInSym_lt: String
  tokenInSym_lte: String
  tokenInSym_not: String
  tokenInSym_not_contains: String
  tokenInSym_not_contains_nocase: String
  tokenInSym_not_ends_with: String
  tokenInSym_not_ends_with_nocase: String
  tokenInSym_not_in: [String!]
  tokenInSym_not_starts_with: String
  tokenInSym_not_starts_with_nocase: String
  tokenInSym_starts_with: String
  tokenInSym_starts_with_nocase: String
  tokenIn_contains: Bytes
  tokenIn_in: [Bytes!]
  tokenIn_not: Bytes
  tokenIn_not_contains: Bytes
  tokenIn_not_in: [Bytes!]
  tokenOut: Bytes
  tokenOutSym: String
  tokenOutSym_contains: String
  tokenOutSym_contains_nocase: String
  tokenOutSym_ends_with: String
  tokenOutSym_ends_with_nocase: String
  tokenOutSym_gt: String
  tokenOutSym_gte: String
  tokenOutSym_in: [String!]
  tokenOutSym_lt: String
  tokenOutSym_lte: String
  tokenOutSym_not: String
  tokenOutSym_not_contains: String
  tokenOutSym_not_contains_nocase: String
  tokenOutSym_not_ends_with: String
  tokenOutSym_not_ends_with_nocase: String
  tokenOutSym_not_in: [String!]
  tokenOutSym_not_starts_with: String
  tokenOutSym_not_starts_with_nocase: String
  tokenOutSym_starts_with: String
  tokenOutSym_starts_with_nocase: String
  tokenOut_contains: Bytes
  tokenOut_in: [Bytes!]
  tokenOut_not: Bytes
  tokenOut_not_contains: Bytes
  tokenOut_not_in: [Bytes!]
  tx: Bytes
  tx_contains: Bytes
  tx_in: [Bytes!]
  tx_not: Bytes
  tx_not_contains: Bytes
  tx_not_in: [Bytes!]
  userAddress: String
  userAddress_contains: String
  userAddress_contains_nocase: String
  userAddress_ends_with: String
  userAddress_ends_with_nocase: String
  userAddress_gt: String
  userAddress_gte: String
  userAddress_in: [String!]
  userAddress_lt: String
  userAddress_lte: String
  userAddress_not: String
  userAddress_not_contains: String
  userAddress_not_contains_nocase: String
  userAddress_not_ends_with: String
  userAddress_not_ends_with_nocase: String
  userAddress_not_in: [String!]
  userAddress_not_starts_with: String
  userAddress_not_starts_with_nocase: String
  userAddress_starts_with: String
  userAddress_starts_with_nocase: String
}

enum Swap_orderBy {
  caller
  id
  poolId
  timestamp
  tokenAmountIn
  tokenAmountOut
  tokenIn
  tokenInSym
  tokenOut
  tokenOutSym
  tx
  userAddress
}

type Token {
  address: String!
  decimals: Int!
  id: ID!
  latestPrice: LatestPrice
  name: String
  symbol: String
  totalBalanceNotional: BigDecimal!
  totalBalanceUSD: BigDecimal!
  totalSwapCount: BigInt!
  totalVolumeNotional: BigDecimal!
  totalVolumeUSD: BigDecimal!
}

type TokenPrice {
  amount: BigDecimal!
  asset: Bytes!
  block: BigInt!
  id: ID!
  poolId: Pool!
  price: BigDecimal!
  pricingAsset: Bytes!
  timestamp: Int!
}

input TokenPrice_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  amount: BigDecimal
  amount_gt: BigDecimal
  amount_gte: BigDecimal
  amount_in: [BigDecimal!]
  amount_lt: BigDecimal
  amount_lte: BigDecimal
  amount_not: BigDecimal
  amount_not_in: [BigDecimal!]
  asset: Bytes
  asset_contains: Bytes
  asset_in: [Bytes!]
  asset_not: Bytes
  asset_not_contains: Bytes
  asset_not_in: [Bytes!]
  block: BigInt
  block_gt: BigInt
  block_gte: BigInt
  block_in: [BigInt!]
  block_lt: BigInt
  block_lte: BigInt
  block_not: BigInt
  block_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  poolId: String
  poolId_contains: String
  poolId_contains_nocase: String
  poolId_ends_with: String
  poolId_ends_with_nocase: String
  poolId_gt: String
  poolId_gte: String
  poolId_in: [String!]
  poolId_lt: String
  poolId_lte: String
  poolId_not: String
  poolId_not_contains: String
  poolId_not_contains_nocase: String
  poolId_not_ends_with: String
  poolId_not_ends_with_nocase: String
  poolId_not_in: [String!]
  poolId_not_starts_with: String
  poolId_not_starts_with_nocase: String
  poolId_starts_with: String
  poolId_starts_with_nocase: String
  price: BigDecimal
  price_gt: BigDecimal
  price_gte: BigDecimal
  price_in: [BigDecimal!]
  price_lt: BigDecimal
  price_lte: BigDecimal
  price_not: BigDecimal
  price_not_in: [BigDecimal!]
  pricingAsset: Bytes
  pricingAsset_contains: Bytes
  pricingAsset_in: [Bytes!]
  pricingAsset_not: Bytes
  pricingAsset_not_contains: Bytes
  pricingAsset_not_in: [Bytes!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
}

enum TokenPrice_orderBy {
  amount
  asset
  block
  id
  poolId
  price
  pricingAsset
  timestamp
}

type TokenSnapshot {
  id: ID!
  timestamp: Int!
  token: Token!
  totalBalanceNotional: BigDecimal!
  totalBalanceUSD: BigDecimal!
  totalSwapCount: BigInt!
  totalVolumeNotional: BigDecimal!
  totalVolumeUSD: BigDecimal!
}

input TokenSnapshot_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  token: String
  token_contains: String
  token_contains_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  totalBalanceNotional: BigDecimal
  totalBalanceNotional_gt: BigDecimal
  totalBalanceNotional_gte: BigDecimal
  totalBalanceNotional_in: [BigDecimal!]
  totalBalanceNotional_lt: BigDecimal
  totalBalanceNotional_lte: BigDecimal
  totalBalanceNotional_not: BigDecimal
  totalBalanceNotional_not_in: [BigDecimal!]
  totalBalanceUSD: BigDecimal
  totalBalanceUSD_gt: BigDecimal
  totalBalanceUSD_gte: BigDecimal
  totalBalanceUSD_in: [BigDecimal!]
  totalBalanceUSD_lt: BigDecimal
  totalBalanceUSD_lte: BigDecimal
  totalBalanceUSD_not: BigDecimal
  totalBalanceUSD_not_in: [BigDecimal!]
  totalSwapCount: BigInt
  totalSwapCount_gt: BigInt
  totalSwapCount_gte: BigInt
  totalSwapCount_in: [BigInt!]
  totalSwapCount_lt: BigInt
  totalSwapCount_lte: BigInt
  totalSwapCount_not: BigInt
  totalSwapCount_not_in: [BigInt!]
  totalVolumeNotional: BigDecimal
  totalVolumeNotional_gt: BigDecimal
  totalVolumeNotional_gte: BigDecimal
  totalVolumeNotional_in: [BigDecimal!]
  totalVolumeNotional_lt: BigDecimal
  totalVolumeNotional_lte: BigDecimal
  totalVolumeNotional_not: BigDecimal
  totalVolumeNotional_not_in: [BigDecimal!]
  totalVolumeUSD: BigDecimal
  totalVolumeUSD_gt: BigDecimal
  totalVolumeUSD_gte: BigDecimal
  totalVolumeUSD_in: [BigDecimal!]
  totalVolumeUSD_lt: BigDecimal
  totalVolumeUSD_lte: BigDecimal
  totalVolumeUSD_not: BigDecimal
  totalVolumeUSD_not_in: [BigDecimal!]
}

enum TokenSnapshot_orderBy {
  id
  timestamp
  token
  totalBalanceNotional
  totalBalanceUSD
  totalSwapCount
  totalVolumeNotional
  totalVolumeUSD
}

input Token_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  address: String
  address_contains: String
  address_contains_nocase: String
  address_ends_with: String
  address_ends_with_nocase: String
  address_gt: String
  address_gte: String
  address_in: [String!]
  address_lt: String
  address_lte: String
  address_not: String
  address_not_contains: String
  address_not_contains_nocase: String
  address_not_ends_with: String
  address_not_ends_with_nocase: String
  address_not_in: [String!]
  address_not_starts_with: String
  address_not_starts_with_nocase: String
  address_starts_with: String
  address_starts_with_nocase: String
  decimals: Int
  decimals_gt: Int
  decimals_gte: Int
  decimals_in: [Int!]
  decimals_lt: Int
  decimals_lte: Int
  decimals_not: Int
  decimals_not_in: [Int!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  latestPrice: String
  latestPrice_contains: String
  latestPrice_contains_nocase: String
  latestPrice_ends_with: String
  latestPrice_ends_with_nocase: String
  latestPrice_gt: String
  latestPrice_gte: String
  latestPrice_in: [String!]
  latestPrice_lt: String
  latestPrice_lte: String
  latestPrice_not: String
  latestPrice_not_contains: String
  latestPrice_not_contains_nocase: String
  latestPrice_not_ends_with: String
  latestPrice_not_ends_with_nocase: String
  latestPrice_not_in: [String!]
  latestPrice_not_starts_with: String
  latestPrice_not_starts_with_nocase: String
  latestPrice_starts_with: String
  latestPrice_starts_with_nocase: String
  name: String
  name_contains: String
  name_contains_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  symbol: String
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_gt: String
  symbol_gte: String
  symbol_in: [String!]
  symbol_lt: String
  symbol_lte: String
  symbol_not: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  symbol_not_in: [String!]
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  totalBalanceNotional: BigDecimal
  totalBalanceNotional_gt: BigDecimal
  totalBalanceNotional_gte: BigDecimal
  totalBalanceNotional_in: [BigDecimal!]
  totalBalanceNotional_lt: BigDecimal
  totalBalanceNotional_lte: BigDecimal
  totalBalanceNotional_not: BigDecimal
  totalBalanceNotional_not_in: [BigDecimal!]
  totalBalanceUSD: BigDecimal
  totalBalanceUSD_gt: BigDecimal
  totalBalanceUSD_gte: BigDecimal
  totalBalanceUSD_in: [BigDecimal!]
  totalBalanceUSD_lt: BigDecimal
  totalBalanceUSD_lte: BigDecimal
  totalBalanceUSD_not: BigDecimal
  totalBalanceUSD_not_in: [BigDecimal!]
  totalSwapCount: BigInt
  totalSwapCount_gt: BigInt
  totalSwapCount_gte: BigInt
  totalSwapCount_in: [BigInt!]
  totalSwapCount_lt: BigInt
  totalSwapCount_lte: BigInt
  totalSwapCount_not: BigInt
  totalSwapCount_not_in: [BigInt!]
  totalVolumeNotional: BigDecimal
  totalVolumeNotional_gt: BigDecimal
  totalVolumeNotional_gte: BigDecimal
  totalVolumeNotional_in: [BigDecimal!]
  totalVolumeNotional_lt: BigDecimal
  totalVolumeNotional_lte: BigDecimal
  totalVolumeNotional_not: BigDecimal
  totalVolumeNotional_not_in: [BigDecimal!]
  totalVolumeUSD: BigDecimal
  totalVolumeUSD_gt: BigDecimal
  totalVolumeUSD_gte: BigDecimal
  totalVolumeUSD_in: [BigDecimal!]
  totalVolumeUSD_lt: BigDecimal
  totalVolumeUSD_lte: BigDecimal
  totalVolumeUSD_not: BigDecimal
  totalVolumeUSD_not_in: [BigDecimal!]
}

enum Token_orderBy {
  address
  decimals
  id
  latestPrice
  name
  symbol
  totalBalanceNotional
  totalBalanceUSD
  totalSwapCount
  totalVolumeNotional
  totalVolumeUSD
}

type TradePair {
  """Token Address - Token Address"""
  id: ID!
  token0: Token!
  token1: Token!
  totalSwapFee: BigDecimal!
  totalSwapVolume: BigDecimal!
}

type TradePairSnapshot {
  id: ID!
  pair: TradePair!
  timestamp: Int!
  totalSwapFee: BigDecimal!
  totalSwapVolume: BigDecimal!
}

input TradePairSnapshot_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  pair: String
  pair_contains: String
  pair_contains_nocase: String
  pair_ends_with: String
  pair_ends_with_nocase: String
  pair_gt: String
  pair_gte: String
  pair_in: [String!]
  pair_lt: String
  pair_lte: String
  pair_not: String
  pair_not_contains: String
  pair_not_contains_nocase: String
  pair_not_ends_with: String
  pair_not_ends_with_nocase: String
  pair_not_in: [String!]
  pair_not_starts_with: String
  pair_not_starts_with_nocase: String
  pair_starts_with: String
  pair_starts_with_nocase: String
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  totalSwapFee: BigDecimal
  totalSwapFee_gt: BigDecimal
  totalSwapFee_gte: BigDecimal
  totalSwapFee_in: [BigDecimal!]
  totalSwapFee_lt: BigDecimal
  totalSwapFee_lte: BigDecimal
  totalSwapFee_not: BigDecimal
  totalSwapFee_not_in: [BigDecimal!]
  totalSwapVolume: BigDecimal
  totalSwapVolume_gt: BigDecimal
  totalSwapVolume_gte: BigDecimal
  totalSwapVolume_in: [BigDecimal!]
  totalSwapVolume_lt: BigDecimal
  totalSwapVolume_lte: BigDecimal
  totalSwapVolume_not: BigDecimal
  totalSwapVolume_not_in: [BigDecimal!]
}

enum TradePairSnapshot_orderBy {
  id
  pair
  timestamp
  totalSwapFee
  totalSwapVolume
}

input TradePair_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  token0: String
  token0_contains: String
  token0_contains_nocase: String
  token0_ends_with: String
  token0_ends_with_nocase: String
  token0_gt: String
  token0_gte: String
  token0_in: [String!]
  token0_lt: String
  token0_lte: String
  token0_not: String
  token0_not_contains: String
  token0_not_contains_nocase: String
  token0_not_ends_with: String
  token0_not_ends_with_nocase: String
  token0_not_in: [String!]
  token0_not_starts_with: String
  token0_not_starts_with_nocase: String
  token0_starts_with: String
  token0_starts_with_nocase: String
  token1: String
  token1_contains: String
  token1_contains_nocase: String
  token1_ends_with: String
  token1_ends_with_nocase: String
  token1_gt: String
  token1_gte: String
  token1_in: [String!]
  token1_lt: String
  token1_lte: String
  token1_not: String
  token1_not_contains: String
  token1_not_contains_nocase: String
  token1_not_ends_with: String
  token1_not_ends_with_nocase: String
  token1_not_in: [String!]
  token1_not_starts_with: String
  token1_not_starts_with_nocase: String
  token1_starts_with: String
  token1_starts_with_nocase: String
  totalSwapFee: BigDecimal
  totalSwapFee_gt: BigDecimal
  totalSwapFee_gte: BigDecimal
  totalSwapFee_in: [BigDecimal!]
  totalSwapFee_lt: BigDecimal
  totalSwapFee_lte: BigDecimal
  totalSwapFee_not: BigDecimal
  totalSwapFee_not_in: [BigDecimal!]
  totalSwapVolume: BigDecimal
  totalSwapVolume_gt: BigDecimal
  totalSwapVolume_gte: BigDecimal
  totalSwapVolume_in: [BigDecimal!]
  totalSwapVolume_lt: BigDecimal
  totalSwapVolume_lte: BigDecimal
  totalSwapVolume_not: BigDecimal
  totalSwapVolume_not_in: [BigDecimal!]
}

enum TradePair_orderBy {
  id
  token0
  token1
  totalSwapFee
  totalSwapVolume
}

type User {
  id: ID!
  sharesOwned(first: Int = 100, orderBy: PoolShare_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: PoolShare_filter): [PoolShare!]
  swaps(first: Int = 100, orderBy: Swap_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Swap_filter): [Swap!]
  userInternalBalances(first: Int = 100, orderBy: UserInternalBalance_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: UserInternalBalance_filter): [UserInternalBalance!]
}

type UserInternalBalance {
  balance: BigDecimal!
  id: ID!
  token: Bytes!
  userAddress: User
}

input UserInternalBalance_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  balance: BigDecimal
  balance_gt: BigDecimal
  balance_gte: BigDecimal
  balance_in: [BigDecimal!]
  balance_lt: BigDecimal
  balance_lte: BigDecimal
  balance_not: BigDecimal
  balance_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  token: Bytes
  token_contains: Bytes
  token_in: [Bytes!]
  token_not: Bytes
  token_not_contains: Bytes
  token_not_in: [Bytes!]
  userAddress: String
  userAddress_contains: String
  userAddress_contains_nocase: String
  userAddress_ends_with: String
  userAddress_ends_with_nocase: String
  userAddress_gt: String
  userAddress_gte: String
  userAddress_in: [String!]
  userAddress_lt: String
  userAddress_lte: String
  userAddress_not: String
  userAddress_not_contains: String
  userAddress_not_contains_nocase: String
  userAddress_not_ends_with: String
  userAddress_not_ends_with_nocase: String
  userAddress_not_in: [String!]
  userAddress_not_starts_with: String
  userAddress_not_starts_with_nocase: String
  userAddress_starts_with: String
  userAddress_starts_with_nocase: String
}

enum UserInternalBalance_orderBy {
  balance
  id
  token
  userAddress
}

input User_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
}

enum User_orderBy {
  id
  sharesOwned
  swaps
  userInternalBalances
}

type _Block_ {
  """The hash of the block"""
  hash: Bytes

  """The block number"""
  number: Int!
}

"""The type for the top-level _meta field"""
type _Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: _Block_!

  """The deployment ID"""
  deployment: String!

  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow

  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}
