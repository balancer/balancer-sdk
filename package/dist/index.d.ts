import { BigNumberish, BigNumber } from '@ethersproject/bignumber';
import { Contract } from '@ethersproject/contracts';
import { SubgraphPoolBase, SubgraphToken, PoolDataService, TokenPriceService, SwapInfo, SOR, WeightedPool as WeightedPool$1, StablePool as StablePool$1, LinearPool as LinearPool$1, MetaStablePool, PhantomStablePool, ComposableStablePool as ComposableStablePool$1, SwapTypes, SwapV2 } from '@balancer-labs/sor';
export { PoolFilter, SOR, SubgraphPoolBase, SwapInfo, SwapOptions, SwapTypes, SwapV2, stableBPTForTokensZeroPriceImpact, weightedBPTForTokensZeroPriceImpact } from '@balancer-labs/sor';
import { Listener, Provider, TransactionReceipt, JsonRpcSigner, JsonRpcProvider } from '@ethersproject/providers';
import { Event, EventFilter, BigNumberish as BigNumberish$1, BigNumber as BigNumber$1, BaseContract, Signer, CallOverrides, Overrides, ContractTransaction, BytesLike, PopulatedTransaction, utils, PayableOverrides } from 'ethers';
import { FunctionFragment, Result, EventFragment, Interface, LogDescription } from '@ethersproject/abi';
import { GraphQLClient } from 'graphql-request';
import * as Dom from 'graphql-request/dist/types.dom';
import { Signer as Signer$1, TypedDataSigner } from '@ethersproject/abstract-signer';
import { BytesLike as BytesLike$1 } from '@ethersproject/bytes';

declare class BasePoolEncoder {
    /**
     * Encodes the userData parameter for exiting any Pool in recovery mode, by removing tokens in return for
     * an exact amount of BPT
     * @param bptAmountIn - the amount of BPT to be burned
     */
    static recoveryModeExit: (bptAmountIn: BigNumberish) => string;
}

declare enum StablePoolJoinKind {
    INIT = 0,
    EXACT_TOKENS_IN_FOR_BPT_OUT = 1,
    TOKEN_IN_FOR_EXACT_BPT_OUT = 2
}
declare enum StablePhantomPoolJoinKind {
    INIT = 0,
    COLLECT_PROTOCOL_FEES = 1
}
declare enum StablePoolExitKind {
    EXACT_BPT_IN_FOR_ONE_TOKEN_OUT = 0,
    EXACT_BPT_IN_FOR_TOKENS_OUT = 1,
    BPT_IN_FOR_EXACT_TOKENS_OUT = 2
}
declare class StablePoolEncoder {
    /**
     * Cannot be constructed.
     */
    private constructor();
    /**
     * Encodes the userData parameter for providing the initial liquidity to a StablePool
     * @param initialBalances - the amounts of tokens to send to the pool to form the initial balances
     */
    static joinInit: (amountsIn: BigNumberish[]) => string;
    /**
     * Encodes the userData parameter for collecting protocol fees for StablePhantomPool
     */
    static joinCollectProtocolFees: () => string;
    /**
     * Encodes the userData parameter for joining a StablePool with exact token inputs
     * @param amountsIn - the amounts each of token to deposit in the pool as liquidity
     * @param minimumBPT - the minimum acceptable BPT to receive in return for deposited tokens
     */
    static joinExactTokensInForBPTOut: (amountsIn: BigNumberish[], minimumBPT: BigNumberish) => string;
    /**
     * Encodes the userData parameter for joining a StablePool with to receive an exact amount of BPT
     * @param bptAmountOut - the amount of BPT to be minted
     * @param enterTokenIndex - the index of the token to be provided as liquidity
     */
    static joinTokenInForExactBPTOut: (bptAmountOut: BigNumberish, enterTokenIndex: number) => string;
    /**
     * Encodes the userData parameter for exiting a StablePool by removing a single token in return for an exact amount of BPT
     * @param bptAmountIn - the amount of BPT to be burned
     * @param enterTokenIndex - the index of the token to removed from the pool
     */
    static exitExactBPTInForOneTokenOut: (bptAmountIn: BigNumberish, exitTokenIndex: number) => string;
    /**
     * Encodes the userData parameter for exiting a StablePool by removing tokens in return for an exact amount of BPT
     * @param bptAmountIn - the amount of BPT to be burned
     */
    static exitExactBPTInForTokensOut: (bptAmountIn: BigNumberish) => string;
    /**
     * Encodes the userData parameter for exiting a StablePool by removing exact amounts of tokens
     * @param amountsOut - the amounts of each token to be withdrawn from the pool
     * @param maxBPTAmountIn - the minimum acceptable BPT to burn in return for withdrawn tokens
     */
    static exitBPTInForExactTokensOut: (amountsOut: BigNumberish[], maxBPTAmountIn: BigNumberish) => string;
}

declare enum WeightedPoolJoinKind {
    INIT = 0,
    EXACT_TOKENS_IN_FOR_BPT_OUT = 1,
    TOKEN_IN_FOR_EXACT_BPT_OUT = 2,
    ALL_TOKENS_IN_FOR_EXACT_BPT_OUT = 3
}
declare enum WeightedPoolExitKind {
    EXACT_BPT_IN_FOR_ONE_TOKEN_OUT = 0,
    EXACT_BPT_IN_FOR_TOKENS_OUT = 1,
    BPT_IN_FOR_EXACT_TOKENS_OUT = 2,
    MANAGEMENT_FEE_TOKENS_OUT = 3
}
declare class WeightedPoolEncoder {
    /**
     * Cannot be constructed.
     */
    private constructor();
    /**
     * Encodes the userData parameter for providing the initial liquidity to a WeightedPool
     * @param initialBalances - the amounts of tokens to send to the pool to form the initial balances
     */
    static joinInit: (amountsIn: BigNumberish[]) => string;
    /**
     * Encodes the userData parameter for joining a WeightedPool with exact token inputs
     * @param amountsIn - the amounts each of token to deposit in the pool as liquidity
     * @param minimumBPT - the minimum acceptable BPT to receive in return for deposited tokens
     */
    static joinExactTokensInForBPTOut: (amountsIn: BigNumberish[], minimumBPT: BigNumberish) => string;
    /**
     * Encodes the userData parameter for joining a WeightedPool with a single token to receive an exact amount of BPT
     * @param bptAmountOut - the amount of BPT to be minted
     * @param enterTokenIndex - the index of the token to be provided as liquidity
     */
    static joinTokenInForExactBPTOut: (bptAmountOut: BigNumberish, enterTokenIndex: number) => string;
    /**
     * Encodes the userData parameter for joining a WeightedPool proportionally to receive an exact amount of BPT
     * @param bptAmountOut - the amount of BPT to be minted
     */
    static joinAllTokensInForExactBPTOut: (bptAmountOut: BigNumberish) => string;
    /**
     * Encodes the userData parameter for exiting a WeightedPool by removing a single token in return for an exact amount of BPT
     * @param bptAmountIn - the amount of BPT to be burned
     * @param enterTokenIndex - the index of the token to removed from the pool
     */
    static exitExactBPTInForOneTokenOut: (bptAmountIn: BigNumberish, exitTokenIndex: number) => string;
    /**
     * Encodes the userData parameter for exiting a WeightedPool by removing tokens in return for an exact amount of BPT
     * @param bptAmountIn - the amount of BPT to be burned
     */
    static exitExactBPTInForTokensOut: (bptAmountIn: BigNumberish) => string;
    /**
     * Encodes the userData parameter for exiting a WeightedPool by removing exact amounts of tokens
     * @param amountsOut - the amounts of each token to be withdrawn from the pool
     * @param maxBPTAmountIn - the minimum acceptable BPT to burn in return for withdrawn tokens
     */
    static exitBPTInForExactTokensOut: (amountsOut: BigNumberish[], maxBPTAmountIn: BigNumberish) => string;
}
declare class ManagedPoolEncoder {
    /**
     * Cannot be constructed.
     */
    private constructor();
    /**
     * Encodes the userData parameter for exiting a ManagedPool for withdrawing management fees.
     * This can only be done by the pool owner.
     */
    static exitForManagementFees: () => string;
}

/**
 * Normalize an array of token weights to ensure they sum to `1e18`
 * @param weights - an array of token weights to be normalized
 * @returns an equivalent set of normalized weights
 */
declare function toNormalizedWeights(weights: BigNumber[]): BigNumber[];
/**
 * Check whether a set of weights are normalized
 * @param weights - an array of potentially unnormalized weights
 * @returns a boolean of whether the weights are normalized
 */
declare const isNormalizedWeights: (weights: BigNumberish[]) => boolean;

declare enum ComposableStablePoolJoinKind {
    INIT = 0,
    EXACT_TOKENS_IN_FOR_BPT_OUT = 1,
    TOKEN_IN_FOR_EXACT_BPT_OUT = 2
}
declare enum ComposableStablePoolExitKind {
    EXACT_BPT_IN_FOR_ONE_TOKEN_OUT = 0,
    BPT_IN_FOR_EXACT_TOKENS_OUT = 1,
    EXACT_BPT_IN_FOR_ALL_TOKENS_OUT = 2
}
declare class ComposableStablePoolEncoder {
    /**
     * Cannot be constructed.
     */
    private constructor();
    /**
     * Encodes the userData parameter for providing the initial liquidity to a ComposableStablePool
     * @param initialBalances - the amounts of tokens to send to the pool to form the initial balances
     */
    static joinInit: (amountsIn: BigNumberish[]) => string;
    /**
     * Encodes the userData parameter for collecting protocol fees for StablePhantomPool
     */
    static joinCollectProtocolFees: () => string;
    /**
     * Encodes the userData parameter for joining a ComposableStablePool with exact token inputs
     * @param amountsIn - the amounts each of token to deposit in the pool as liquidity
     * @param minimumBPT - the minimum acceptable BPT to receive in return for deposited tokens
     */
    static joinExactTokensInForBPTOut: (amountsIn: BigNumberish[], minimumBPT: BigNumberish) => string;
    /**
     * Encodes the userData parameter for joining a ComposableStablePool with to receive an exact amount of BPT
     * @param bptAmountOut - the amount of BPT to be minted
     * @param enterTokenIndex - the index of the token to be provided as liquidity
     */
    static joinTokenInForExactBPTOut: (bptAmountOut: BigNumberish, enterTokenIndex: number) => string;
    /**
     * Encodes the userData parameter for exiting a ComposableStablePool by removing a single token in return for an exact amount of BPT
     * @param bptAmountIn - the amount of BPT to be burned
     * @param enterTokenIndex - the index of the token to removed from the pool
     */
    static exitExactBPTInForOneTokenOut: (bptAmountIn: BigNumberish, exitTokenIndex: number) => string;
    /**
     * Encodes the userData parameter for exiting a StablePool by removing tokens in return for an exact amount of BPT
     * @param bptAmountIn - the amount of BPT to be burned
     */
    static exitExactBPTInForAllTokensOut: (bptAmountIn: BigNumberish) => string;
    /**
     * Encodes the userData parameter for exiting a ComposableStablePool by removing exact amounts of tokens
     * @param amountsOut - the amounts of each token to be withdrawn from the pool
     * @param maxBPTAmountIn - the max acceptable BPT to burn in return for withdrawn tokens
     */
    static exitBPTInForExactTokensOut: (amountsOut: BigNumberish[], maxBPTAmountIn: BigNumberish) => string;
}

declare enum Network {
    MAINNET = 1,
    GOERLI = 5,
    GÃ–RLI = 5,
    OPTIMISM = 10,
    GNOSIS = 100,
    POLYGON = 137,
    FANTOM = 250,
    BASE = 8453,
    ZKEVM = 1101,
    ARBITRUM = 42161,
    AVALANCHE = 43114,
    SEPOLIA = 11155111
}

interface JoinPool {
    poolId: string;
    sender: string;
    recipient: string;
    joinPoolRequest: JoinPoolRequest$1;
}
/**
 * Join with exact tokens in transaction parameters
 * @param to Address that will execute the transaction (vault address)
 * @param functionName Function name to be called (joinPool)
 * @param attributes Transaction attributes ready to be encoded
 * @param data Encoded transaction data
 * @param value Optional: ETH amount in EVM scale (required when joining with ETH)
 * @param minBptOut Minimum BPT amount out of join transaction considering slippage tolerance in EVM scale
 * @param expectedBptOut Expected BPT amount out of join transaction in EVM scale
 * @param priceImpact Price impact of join transaction in EVM scale
 */
interface JoinPoolAttributes {
    to: string;
    functionName: string;
    attributes: JoinPool;
    data: string;
    value?: BigNumber;
    minBPTOut: string;
    expectedBPTOut: string;
    priceImpact: string;
}
interface ExitPool {
    poolId: string;
    sender: string;
    recipient: string;
    exitPoolRequest: ExitPoolRequest$1;
}
interface ExitPoolAttributes {
    to: string;
    functionName: string;
    attributes: ExitPool;
    data: string;
}
/**
 * Exit exact BPT in transaction parameters
 * @param to Address that will execute the transaction (vault address)
 * @param functionName Function name to be called (exitPool)
 * @param attributes Transaction attributes ready to be encoded
 * @param data Encoded transaction data
 * @param expectedAmountsOut Expected amounts out of exit transaction in EVM scale
 * @param minAmountsOut Minimum amounts out of exit transaction (considering slippage tolerance) in EVM scale
 * @param priceImpact Price impact of exit transaction in EVM scale
 */
interface ExitExactBPTInAttributes extends ExitPoolAttributes {
    expectedAmountsOut: string[];
    minAmountsOut: string[];
    priceImpact: string;
}
/**
 * Exit exact tokens out transaction parameters
 * @param to Address that will execute the transaction (vault address)
 * @param functionName Function name to be called (exitPool)
 * @param attributes Transaction attributes ready to be encoded
 * @param data Encoded transaction data
 * @param expectedBPTIn Expected BPT into exit transaction in EVM scale
 * @param maxBPTIn Max BPT into exit transaction (considering slippage tolerance) in EVM scale
 * @param priceImpact Price impact of exit transaction in EVM scale
 */
interface ExitExactTokensOutAttributes extends ExitPoolAttributes {
    expectedBPTIn: string;
    maxBPTIn: string;
    priceImpact: string;
}

interface TypedEvent<TArgsArray extends Array<any> = any, TArgsObject = any> extends Event {
    args: TArgsArray & TArgsObject;
}
interface TypedEventFilter<_TEvent extends TypedEvent> extends EventFilter {
}
interface TypedListener<TEvent extends TypedEvent> {
    (...listenerArg: [...__TypechainArgsArray<TEvent>, TEvent]): void;
}
type __TypechainArgsArray<T> = T extends TypedEvent<infer U> ? U : never;
interface OnEvent<TRes> {
    <TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>, listener: TypedListener<TEvent>): TRes;
    (eventName: string, listener: Listener): TRes;
}
type PromiseOrValue<T> = T | Promise<T>;

declare namespace IPoolSwapStructs$b {
    type SwapRequestStruct = {
        kind: PromiseOrValue<BigNumberish$1>;
        tokenIn: PromiseOrValue<string>;
        tokenOut: PromiseOrValue<string>;
        amount: PromiseOrValue<BigNumberish$1>;
        poolId: PromiseOrValue<BytesLike>;
        lastChangeBlock: PromiseOrValue<BigNumberish$1>;
        from: PromiseOrValue<string>;
        to: PromiseOrValue<string>;
        userData: PromiseOrValue<BytesLike>;
    };
    type SwapRequestStructOutput = [
        number,
        string,
        string,
        BigNumber$1,
        string,
        BigNumber$1,
        string,
        string,
        string
    ] & {
        kind: number;
        tokenIn: string;
        tokenOut: string;
        amount: BigNumber$1;
        poolId: string;
        lastChangeBlock: BigNumber$1;
        from: string;
        to: string;
        userData: string;
    };
}
interface AaveLinearPoolInterface extends utils.Interface {
    functions: {
        "DOMAIN_SEPARATOR()": FunctionFragment;
        "allowance(address,address)": FunctionFragment;
        "approve(address,uint256)": FunctionFragment;
        "balanceOf(address)": FunctionFragment;
        "decimals()": FunctionFragment;
        "decreaseAllowance(address,uint256)": FunctionFragment;
        "disableRecoveryMode()": FunctionFragment;
        "enableRecoveryMode()": FunctionFragment;
        "getActionId(bytes4)": FunctionFragment;
        "getAuthorizer()": FunctionFragment;
        "getBptIndex()": FunctionFragment;
        "getDomainSeparator()": FunctionFragment;
        "getMainIndex()": FunctionFragment;
        "getMainToken()": FunctionFragment;
        "getNextNonce(address)": FunctionFragment;
        "getOwner()": FunctionFragment;
        "getPausedState()": FunctionFragment;
        "getPoolId()": FunctionFragment;
        "getProtocolFeesCollector()": FunctionFragment;
        "getRate()": FunctionFragment;
        "getScalingFactors()": FunctionFragment;
        "getSwapFeePercentage()": FunctionFragment;
        "getTargets()": FunctionFragment;
        "getVault()": FunctionFragment;
        "getVirtualSupply()": FunctionFragment;
        "getWrappedIndex()": FunctionFragment;
        "getWrappedToken()": FunctionFragment;
        "getWrappedTokenRate()": FunctionFragment;
        "inRecoveryMode()": FunctionFragment;
        "increaseAllowance(address,uint256)": FunctionFragment;
        "initialize()": FunctionFragment;
        "name()": FunctionFragment;
        "nonces(address)": FunctionFragment;
        "onExitPool(bytes32,address,address,uint256[],uint256,uint256,bytes)": FunctionFragment;
        "onJoinPool(bytes32,address,address,uint256[],uint256,uint256,bytes)": FunctionFragment;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)": FunctionFragment;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)": FunctionFragment;
        "pause()": FunctionFragment;
        "permit(address,address,uint256,uint256,uint8,bytes32,bytes32)": FunctionFragment;
        "queryExit(bytes32,address,address,uint256[],uint256,uint256,bytes)": FunctionFragment;
        "queryJoin(bytes32,address,address,uint256[],uint256,uint256,bytes)": FunctionFragment;
        "setSwapFeePercentage(uint256)": FunctionFragment;
        "setTargets(uint256,uint256)": FunctionFragment;
        "symbol()": FunctionFragment;
        "totalSupply()": FunctionFragment;
        "transfer(address,uint256)": FunctionFragment;
        "transferFrom(address,address,uint256)": FunctionFragment;
        "unpause()": FunctionFragment;
        "version()": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "DOMAIN_SEPARATOR" | "allowance" | "approve" | "balanceOf" | "decimals" | "decreaseAllowance" | "disableRecoveryMode" | "enableRecoveryMode" | "getActionId" | "getAuthorizer" | "getBptIndex" | "getDomainSeparator" | "getMainIndex" | "getMainToken" | "getNextNonce" | "getOwner" | "getPausedState" | "getPoolId" | "getProtocolFeesCollector" | "getRate" | "getScalingFactors" | "getSwapFeePercentage" | "getTargets" | "getVault" | "getVirtualSupply" | "getWrappedIndex" | "getWrappedToken" | "getWrappedTokenRate" | "inRecoveryMode" | "increaseAllowance" | "initialize" | "name" | "nonces" | "onExitPool" | "onJoinPool" | "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)" | "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)" | "pause" | "permit" | "queryExit" | "queryJoin" | "setSwapFeePercentage" | "setTargets" | "symbol" | "totalSupply" | "transfer" | "transferFrom" | "unpause" | "version"): FunctionFragment;
    encodeFunctionData(functionFragment: "DOMAIN_SEPARATOR", values?: undefined): string;
    encodeFunctionData(functionFragment: "allowance", values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "approve", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "balanceOf", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "decimals", values?: undefined): string;
    encodeFunctionData(functionFragment: "decreaseAllowance", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "disableRecoveryMode", values?: undefined): string;
    encodeFunctionData(functionFragment: "enableRecoveryMode", values?: undefined): string;
    encodeFunctionData(functionFragment: "getActionId", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "getAuthorizer", values?: undefined): string;
    encodeFunctionData(functionFragment: "getBptIndex", values?: undefined): string;
    encodeFunctionData(functionFragment: "getDomainSeparator", values?: undefined): string;
    encodeFunctionData(functionFragment: "getMainIndex", values?: undefined): string;
    encodeFunctionData(functionFragment: "getMainToken", values?: undefined): string;
    encodeFunctionData(functionFragment: "getNextNonce", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "getOwner", values?: undefined): string;
    encodeFunctionData(functionFragment: "getPausedState", values?: undefined): string;
    encodeFunctionData(functionFragment: "getPoolId", values?: undefined): string;
    encodeFunctionData(functionFragment: "getProtocolFeesCollector", values?: undefined): string;
    encodeFunctionData(functionFragment: "getRate", values?: undefined): string;
    encodeFunctionData(functionFragment: "getScalingFactors", values?: undefined): string;
    encodeFunctionData(functionFragment: "getSwapFeePercentage", values?: undefined): string;
    encodeFunctionData(functionFragment: "getTargets", values?: undefined): string;
    encodeFunctionData(functionFragment: "getVault", values?: undefined): string;
    encodeFunctionData(functionFragment: "getVirtualSupply", values?: undefined): string;
    encodeFunctionData(functionFragment: "getWrappedIndex", values?: undefined): string;
    encodeFunctionData(functionFragment: "getWrappedToken", values?: undefined): string;
    encodeFunctionData(functionFragment: "getWrappedTokenRate", values?: undefined): string;
    encodeFunctionData(functionFragment: "inRecoveryMode", values?: undefined): string;
    encodeFunctionData(functionFragment: "increaseAllowance", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "initialize", values?: undefined): string;
    encodeFunctionData(functionFragment: "name", values?: undefined): string;
    encodeFunctionData(functionFragment: "nonces", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "onExitPool", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "onJoinPool", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)", values: [
        IPoolSwapStructs$b.SwapRequestStruct,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)", values: [
        IPoolSwapStructs$b.SwapRequestStruct,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "pause", values?: undefined): string;
    encodeFunctionData(functionFragment: "permit", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "queryExit", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "queryJoin", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "setSwapFeePercentage", values: [PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "setTargets", values: [PromiseOrValue<BigNumberish$1>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "symbol", values?: undefined): string;
    encodeFunctionData(functionFragment: "totalSupply", values?: undefined): string;
    encodeFunctionData(functionFragment: "transfer", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "transferFrom", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "unpause", values?: undefined): string;
    encodeFunctionData(functionFragment: "version", values?: undefined): string;
    decodeFunctionResult(functionFragment: "DOMAIN_SEPARATOR", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "allowance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "approve", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "balanceOf", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "decimals", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "decreaseAllowance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "disableRecoveryMode", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "enableRecoveryMode", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getActionId", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getAuthorizer", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getBptIndex", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getDomainSeparator", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getMainIndex", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getMainToken", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getNextNonce", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getOwner", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getPausedState", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getPoolId", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getProtocolFeesCollector", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getRate", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getScalingFactors", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getSwapFeePercentage", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getTargets", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getVault", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getVirtualSupply", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getWrappedIndex", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getWrappedToken", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getWrappedTokenRate", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "inRecoveryMode", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "increaseAllowance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "name", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "nonces", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "onExitPool", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "onJoinPool", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "pause", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "permit", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "queryExit", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "queryJoin", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setSwapFeePercentage", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setTargets", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "symbol", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "totalSupply", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "transfer", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "transferFrom", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "unpause", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "version", data: BytesLike): Result;
    events: {
        "Approval(address,address,uint256)": EventFragment;
        "PausedStateChanged(bool)": EventFragment;
        "RecoveryModeStateChanged(bool)": EventFragment;
        "SwapFeePercentageChanged(uint256)": EventFragment;
        "TargetsSet(address,uint256,uint256)": EventFragment;
        "Transfer(address,address,uint256)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "Approval"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "PausedStateChanged"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "RecoveryModeStateChanged"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "SwapFeePercentageChanged"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "TargetsSet"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Transfer"): EventFragment;
}
interface ApprovalEventObject$d {
    owner: string;
    spender: string;
    value: BigNumber$1;
}
type ApprovalEvent$d = TypedEvent<[
    string,
    string,
    BigNumber$1
], ApprovalEventObject$d>;
type ApprovalEventFilter$d = TypedEventFilter<ApprovalEvent$d>;
interface PausedStateChangedEventObject$a {
    paused: boolean;
}
type PausedStateChangedEvent$a = TypedEvent<[
    boolean
], PausedStateChangedEventObject$a>;
type PausedStateChangedEventFilter$a = TypedEventFilter<PausedStateChangedEvent$a>;
interface RecoveryModeStateChangedEventObject$6 {
    enabled: boolean;
}
type RecoveryModeStateChangedEvent$6 = TypedEvent<[
    boolean
], RecoveryModeStateChangedEventObject$6>;
type RecoveryModeStateChangedEventFilter$6 = TypedEventFilter<RecoveryModeStateChangedEvent$6>;
interface SwapFeePercentageChangedEventObject$9 {
    swapFeePercentage: BigNumber$1;
}
type SwapFeePercentageChangedEvent$9 = TypedEvent<[
    BigNumber$1
], SwapFeePercentageChangedEventObject$9>;
type SwapFeePercentageChangedEventFilter$9 = TypedEventFilter<SwapFeePercentageChangedEvent$9>;
interface TargetsSetEventObject$5 {
    token: string;
    lowerTarget: BigNumber$1;
    upperTarget: BigNumber$1;
}
type TargetsSetEvent$5 = TypedEvent<[
    string,
    BigNumber$1,
    BigNumber$1
], TargetsSetEventObject$5>;
type TargetsSetEventFilter$5 = TypedEventFilter<TargetsSetEvent$5>;
interface TransferEventObject$d {
    from: string;
    to: string;
    value: BigNumber$1;
}
type TransferEvent$d = TypedEvent<[
    string,
    string,
    BigNumber$1
], TransferEventObject$d>;
type TransferEventFilter$d = TypedEventFilter<TransferEvent$d>;
declare namespace AaveLinearPool {
    type ConstructorArgsStruct = {
        vault: PromiseOrValue<string>;
        name: PromiseOrValue<string>;
        symbol: PromiseOrValue<string>;
        mainToken: PromiseOrValue<string>;
        wrappedToken: PromiseOrValue<string>;
        assetManager: PromiseOrValue<string>;
        upperTarget: PromiseOrValue<BigNumberish$1>;
        swapFeePercentage: PromiseOrValue<BigNumberish$1>;
        pauseWindowDuration: PromiseOrValue<BigNumberish$1>;
        bufferPeriodDuration: PromiseOrValue<BigNumberish$1>;
        owner: PromiseOrValue<string>;
        version: PromiseOrValue<string>;
    };
    type ConstructorArgsStructOutput = [
        string,
        string,
        string,
        string,
        string,
        string,
        BigNumber$1,
        BigNumber$1,
        BigNumber$1,
        BigNumber$1,
        string,
        string
    ] & {
        vault: string;
        name: string;
        symbol: string;
        mainToken: string;
        wrappedToken: string;
        assetManager: string;
        upperTarget: BigNumber$1;
        swapFeePercentage: BigNumber$1;
        pauseWindowDuration: BigNumber$1;
        bufferPeriodDuration: BigNumber$1;
        owner: string;
        version: string;
    };
}
interface AaveLinearPool extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: AaveLinearPoolInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<[string]>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        decimals(overrides?: CallOverrides): Promise<[number]>;
        decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        disableRecoveryMode(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        enableRecoveryMode(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[string]>;
        getAuthorizer(overrides?: CallOverrides): Promise<[string]>;
        getBptIndex(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getDomainSeparator(overrides?: CallOverrides): Promise<[string]>;
        getMainIndex(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getMainToken(overrides?: CallOverrides): Promise<[string]>;
        getNextNonce(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getOwner(overrides?: CallOverrides): Promise<[string]>;
        getPausedState(overrides?: CallOverrides): Promise<[
            boolean,
            BigNumber$1,
            BigNumber$1
        ] & {
            paused: boolean;
            pauseWindowEndTime: BigNumber$1;
            bufferPeriodEndTime: BigNumber$1;
        }>;
        getPoolId(overrides?: CallOverrides): Promise<[string]>;
        getProtocolFeesCollector(overrides?: CallOverrides): Promise<[string]>;
        getRate(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getScalingFactors(overrides?: CallOverrides): Promise<[BigNumber$1[]]>;
        getSwapFeePercentage(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getTargets(overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1
        ] & {
            lowerTarget: BigNumber$1;
            upperTarget: BigNumber$1;
        }>;
        getVault(overrides?: CallOverrides): Promise<[string]>;
        getVirtualSupply(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getWrappedIndex(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getWrappedToken(overrides?: CallOverrides): Promise<[string]>;
        getWrappedTokenRate(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        inRecoveryMode(overrides?: CallOverrides): Promise<[boolean]>;
        increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        initialize(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        name(overrides?: CallOverrides): Promise<[string]>;
        nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        onJoinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)"(request: IPoolSwapStructs$b.SwapRequestStruct, balances: PromiseOrValue<BigNumberish$1>[], indexIn: PromiseOrValue<BigNumberish$1>, indexOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)"(request: IPoolSwapStructs$b.SwapRequestStruct, balanceTokenIn: PromiseOrValue<BigNumberish$1>, balanceTokenOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        pause(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        queryExit(arg0: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        queryJoin(arg0: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setSwapFeePercentage(swapFeePercentage: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setTargets(newLowerTarget: PromiseOrValue<BigNumberish$1>, newUpperTarget: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        symbol(overrides?: CallOverrides): Promise<[string]>;
        totalSupply(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        unpause(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        version(overrides?: CallOverrides): Promise<[string]>;
    };
    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;
    allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    decimals(overrides?: CallOverrides): Promise<number>;
    decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    disableRecoveryMode(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    enableRecoveryMode(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
    getAuthorizer(overrides?: CallOverrides): Promise<string>;
    getBptIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
    getDomainSeparator(overrides?: CallOverrides): Promise<string>;
    getMainIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
    getMainToken(overrides?: CallOverrides): Promise<string>;
    getNextNonce(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    getOwner(overrides?: CallOverrides): Promise<string>;
    getPausedState(overrides?: CallOverrides): Promise<[
        boolean,
        BigNumber$1,
        BigNumber$1
    ] & {
        paused: boolean;
        pauseWindowEndTime: BigNumber$1;
        bufferPeriodEndTime: BigNumber$1;
    }>;
    getPoolId(overrides?: CallOverrides): Promise<string>;
    getProtocolFeesCollector(overrides?: CallOverrides): Promise<string>;
    getRate(overrides?: CallOverrides): Promise<BigNumber$1>;
    getScalingFactors(overrides?: CallOverrides): Promise<BigNumber$1[]>;
    getSwapFeePercentage(overrides?: CallOverrides): Promise<BigNumber$1>;
    getTargets(overrides?: CallOverrides): Promise<[
        BigNumber$1,
        BigNumber$1
    ] & {
        lowerTarget: BigNumber$1;
        upperTarget: BigNumber$1;
    }>;
    getVault(overrides?: CallOverrides): Promise<string>;
    getVirtualSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
    getWrappedIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
    getWrappedToken(overrides?: CallOverrides): Promise<string>;
    getWrappedTokenRate(overrides?: CallOverrides): Promise<BigNumber$1>;
    inRecoveryMode(overrides?: CallOverrides): Promise<boolean>;
    increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    initialize(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    name(overrides?: CallOverrides): Promise<string>;
    nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    onJoinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)"(request: IPoolSwapStructs$b.SwapRequestStruct, balances: PromiseOrValue<BigNumberish$1>[], indexIn: PromiseOrValue<BigNumberish$1>, indexOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)"(request: IPoolSwapStructs$b.SwapRequestStruct, balanceTokenIn: PromiseOrValue<BigNumberish$1>, balanceTokenOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    pause(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    queryExit(arg0: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    queryJoin(arg0: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setSwapFeePercentage(swapFeePercentage: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setTargets(newLowerTarget: PromiseOrValue<BigNumberish$1>, newUpperTarget: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    symbol(overrides?: CallOverrides): Promise<string>;
    totalSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
    transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    unpause(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    version(overrides?: CallOverrides): Promise<string>;
    callStatic: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        decimals(overrides?: CallOverrides): Promise<number>;
        decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        disableRecoveryMode(overrides?: CallOverrides): Promise<void>;
        enableRecoveryMode(overrides?: CallOverrides): Promise<void>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
        getAuthorizer(overrides?: CallOverrides): Promise<string>;
        getBptIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
        getDomainSeparator(overrides?: CallOverrides): Promise<string>;
        getMainIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
        getMainToken(overrides?: CallOverrides): Promise<string>;
        getNextNonce(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getOwner(overrides?: CallOverrides): Promise<string>;
        getPausedState(overrides?: CallOverrides): Promise<[
            boolean,
            BigNumber$1,
            BigNumber$1
        ] & {
            paused: boolean;
            pauseWindowEndTime: BigNumber$1;
            bufferPeriodEndTime: BigNumber$1;
        }>;
        getPoolId(overrides?: CallOverrides): Promise<string>;
        getProtocolFeesCollector(overrides?: CallOverrides): Promise<string>;
        getRate(overrides?: CallOverrides): Promise<BigNumber$1>;
        getScalingFactors(overrides?: CallOverrides): Promise<BigNumber$1[]>;
        getSwapFeePercentage(overrides?: CallOverrides): Promise<BigNumber$1>;
        getTargets(overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1
        ] & {
            lowerTarget: BigNumber$1;
            upperTarget: BigNumber$1;
        }>;
        getVault(overrides?: CallOverrides): Promise<string>;
        getVirtualSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
        getWrappedIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
        getWrappedToken(overrides?: CallOverrides): Promise<string>;
        getWrappedTokenRate(overrides?: CallOverrides): Promise<BigNumber$1>;
        inRecoveryMode(overrides?: CallOverrides): Promise<boolean>;
        increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        initialize(overrides?: CallOverrides): Promise<void>;
        name(overrides?: CallOverrides): Promise<string>;
        nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[
            BigNumber$1[],
            BigNumber$1[]
        ] & {
            amountsOut: BigNumber$1[];
            dueProtocolFees: BigNumber$1[];
        }>;
        onJoinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[
            BigNumber$1[],
            BigNumber$1[]
        ] & {
            amountsIn: BigNumber$1[];
            dueProtocolFees: BigNumber$1[];
        }>;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)"(request: IPoolSwapStructs$b.SwapRequestStruct, balances: PromiseOrValue<BigNumberish$1>[], indexIn: PromiseOrValue<BigNumberish$1>, indexOut: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)"(request: IPoolSwapStructs$b.SwapRequestStruct, balanceTokenIn: PromiseOrValue<BigNumberish$1>, balanceTokenOut: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        pause(overrides?: CallOverrides): Promise<void>;
        permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<void>;
        queryExit(arg0: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1[]
        ] & {
            bptIn: BigNumber$1;
            amountsOut: BigNumber$1[];
        }>;
        queryJoin(arg0: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1[]
        ] & {
            bptOut: BigNumber$1;
            amountsIn: BigNumber$1[];
        }>;
        setSwapFeePercentage(swapFeePercentage: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        setTargets(newLowerTarget: PromiseOrValue<BigNumberish$1>, newUpperTarget: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        symbol(overrides?: CallOverrides): Promise<string>;
        totalSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
        transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        unpause(overrides?: CallOverrides): Promise<void>;
        version(overrides?: CallOverrides): Promise<string>;
    };
    filters: {
        "Approval(address,address,uint256)"(owner?: PromiseOrValue<string> | null, spender?: PromiseOrValue<string> | null, value?: null): ApprovalEventFilter$d;
        Approval(owner?: PromiseOrValue<string> | null, spender?: PromiseOrValue<string> | null, value?: null): ApprovalEventFilter$d;
        "PausedStateChanged(bool)"(paused?: null): PausedStateChangedEventFilter$a;
        PausedStateChanged(paused?: null): PausedStateChangedEventFilter$a;
        "RecoveryModeStateChanged(bool)"(enabled?: null): RecoveryModeStateChangedEventFilter$6;
        RecoveryModeStateChanged(enabled?: null): RecoveryModeStateChangedEventFilter$6;
        "SwapFeePercentageChanged(uint256)"(swapFeePercentage?: null): SwapFeePercentageChangedEventFilter$9;
        SwapFeePercentageChanged(swapFeePercentage?: null): SwapFeePercentageChangedEventFilter$9;
        "TargetsSet(address,uint256,uint256)"(token?: PromiseOrValue<string> | null, lowerTarget?: null, upperTarget?: null): TargetsSetEventFilter$5;
        TargetsSet(token?: PromiseOrValue<string> | null, lowerTarget?: null, upperTarget?: null): TargetsSetEventFilter$5;
        "Transfer(address,address,uint256)"(from?: PromiseOrValue<string> | null, to?: PromiseOrValue<string> | null, value?: null): TransferEventFilter$d;
        Transfer(from?: PromiseOrValue<string> | null, to?: PromiseOrValue<string> | null, value?: null): TransferEventFilter$d;
    };
    estimateGas: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<BigNumber$1>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        decimals(overrides?: CallOverrides): Promise<BigNumber$1>;
        decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        disableRecoveryMode(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        enableRecoveryMode(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getAuthorizer(overrides?: CallOverrides): Promise<BigNumber$1>;
        getBptIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
        getDomainSeparator(overrides?: CallOverrides): Promise<BigNumber$1>;
        getMainIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
        getMainToken(overrides?: CallOverrides): Promise<BigNumber$1>;
        getNextNonce(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getOwner(overrides?: CallOverrides): Promise<BigNumber$1>;
        getPausedState(overrides?: CallOverrides): Promise<BigNumber$1>;
        getPoolId(overrides?: CallOverrides): Promise<BigNumber$1>;
        getProtocolFeesCollector(overrides?: CallOverrides): Promise<BigNumber$1>;
        getRate(overrides?: CallOverrides): Promise<BigNumber$1>;
        getScalingFactors(overrides?: CallOverrides): Promise<BigNumber$1>;
        getSwapFeePercentage(overrides?: CallOverrides): Promise<BigNumber$1>;
        getTargets(overrides?: CallOverrides): Promise<BigNumber$1>;
        getVault(overrides?: CallOverrides): Promise<BigNumber$1>;
        getVirtualSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
        getWrappedIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
        getWrappedToken(overrides?: CallOverrides): Promise<BigNumber$1>;
        getWrappedTokenRate(overrides?: CallOverrides): Promise<BigNumber$1>;
        inRecoveryMode(overrides?: CallOverrides): Promise<BigNumber$1>;
        increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        initialize(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        name(overrides?: CallOverrides): Promise<BigNumber$1>;
        nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        onJoinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)"(request: IPoolSwapStructs$b.SwapRequestStruct, balances: PromiseOrValue<BigNumberish$1>[], indexIn: PromiseOrValue<BigNumberish$1>, indexOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)"(request: IPoolSwapStructs$b.SwapRequestStruct, balanceTokenIn: PromiseOrValue<BigNumberish$1>, balanceTokenOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        pause(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        queryExit(arg0: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        queryJoin(arg0: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        setSwapFeePercentage(swapFeePercentage: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        setTargets(newLowerTarget: PromiseOrValue<BigNumberish$1>, newUpperTarget: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        symbol(overrides?: CallOverrides): Promise<BigNumber$1>;
        totalSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
        transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        unpause(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        version(overrides?: CallOverrides): Promise<BigNumber$1>;
    };
    populateTransaction: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        decimals(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        disableRecoveryMode(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        enableRecoveryMode(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getAuthorizer(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getBptIndex(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getDomainSeparator(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getMainIndex(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getMainToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getNextNonce(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getOwner(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getPausedState(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getPoolId(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getProtocolFeesCollector(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getRate(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getScalingFactors(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getSwapFeePercentage(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getTargets(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getVault(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getVirtualSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getWrappedIndex(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getWrappedToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getWrappedTokenRate(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        inRecoveryMode(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        initialize(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        name(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        onJoinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)"(request: IPoolSwapStructs$b.SwapRequestStruct, balances: PromiseOrValue<BigNumberish$1>[], indexIn: PromiseOrValue<BigNumberish$1>, indexOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)"(request: IPoolSwapStructs$b.SwapRequestStruct, balanceTokenIn: PromiseOrValue<BigNumberish$1>, balanceTokenOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        pause(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        queryExit(arg0: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        queryJoin(arg0: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setSwapFeePercentage(swapFeePercentage: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setTargets(newLowerTarget: PromiseOrValue<BigNumberish$1>, newUpperTarget: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        symbol(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        totalSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        unpause(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        version(overrides?: CallOverrides): Promise<PopulatedTransaction>;
    };
}

interface AaveLinearPoolFactoryInterface extends utils.Interface {
    functions: {
        "create(string,string,address,address,uint256,uint256,address,uint256,bytes32)": FunctionFragment;
        "disable()": FunctionFragment;
        "getActionId(bytes4)": FunctionFragment;
        "getAuthorizer()": FunctionFragment;
        "getCreationCode()": FunctionFragment;
        "getCreationCodeContracts()": FunctionFragment;
        "getLastCreatedPool()": FunctionFragment;
        "getPauseConfiguration()": FunctionFragment;
        "getPoolVersion()": FunctionFragment;
        "getProtocolFeePercentagesProvider()": FunctionFragment;
        "getVault()": FunctionFragment;
        "isDisabled()": FunctionFragment;
        "isPoolFromFactory(address)": FunctionFragment;
        "version()": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "create" | "disable" | "getActionId" | "getAuthorizer" | "getCreationCode" | "getCreationCodeContracts" | "getLastCreatedPool" | "getPauseConfiguration" | "getPoolVersion" | "getProtocolFeePercentagesProvider" | "getVault" | "isDisabled" | "isPoolFromFactory" | "version"): FunctionFragment;
    encodeFunctionData(functionFragment: "create", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "disable", values?: undefined): string;
    encodeFunctionData(functionFragment: "getActionId", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "getAuthorizer", values?: undefined): string;
    encodeFunctionData(functionFragment: "getCreationCode", values?: undefined): string;
    encodeFunctionData(functionFragment: "getCreationCodeContracts", values?: undefined): string;
    encodeFunctionData(functionFragment: "getLastCreatedPool", values?: undefined): string;
    encodeFunctionData(functionFragment: "getPauseConfiguration", values?: undefined): string;
    encodeFunctionData(functionFragment: "getPoolVersion", values?: undefined): string;
    encodeFunctionData(functionFragment: "getProtocolFeePercentagesProvider", values?: undefined): string;
    encodeFunctionData(functionFragment: "getVault", values?: undefined): string;
    encodeFunctionData(functionFragment: "isDisabled", values?: undefined): string;
    encodeFunctionData(functionFragment: "isPoolFromFactory", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "version", values?: undefined): string;
    decodeFunctionResult(functionFragment: "create", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "disable", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getActionId", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getAuthorizer", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getCreationCode", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getCreationCodeContracts", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getLastCreatedPool", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getPauseConfiguration", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getPoolVersion", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getProtocolFeePercentagesProvider", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getVault", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isDisabled", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isPoolFromFactory", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "version", data: BytesLike): Result;
    events: {
        "AaveLinearPoolCreated(address,uint256)": EventFragment;
        "FactoryDisabled()": EventFragment;
        "PoolCreated(address)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "AaveLinearPoolCreated"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "FactoryDisabled"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "PoolCreated"): EventFragment;
}
interface AaveLinearPoolCreatedEventObject {
    pool: string;
    protocolId: BigNumber$1;
}
type AaveLinearPoolCreatedEvent = TypedEvent<[
    string,
    BigNumber$1
], AaveLinearPoolCreatedEventObject>;
type AaveLinearPoolCreatedEventFilter = TypedEventFilter<AaveLinearPoolCreatedEvent>;
interface FactoryDisabledEventObject$6 {
}
type FactoryDisabledEvent$6 = TypedEvent<[], FactoryDisabledEventObject$6>;
type FactoryDisabledEventFilter$6 = TypedEventFilter<FactoryDisabledEvent$6>;
interface PoolCreatedEventObject$6 {
    pool: string;
}
type PoolCreatedEvent$6 = TypedEvent<[string], PoolCreatedEventObject$6>;
type PoolCreatedEventFilter$6 = TypedEventFilter<PoolCreatedEvent$6>;
interface AaveLinearPoolFactory extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: AaveLinearPoolFactoryInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        create(name: PromiseOrValue<string>, symbol: PromiseOrValue<string>, mainToken: PromiseOrValue<string>, wrappedToken: PromiseOrValue<string>, upperTarget: PromiseOrValue<BigNumberish$1>, swapFeePercentage: PromiseOrValue<BigNumberish$1>, owner: PromiseOrValue<string>, protocolId: PromiseOrValue<BigNumberish$1>, salt: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        disable(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[string]>;
        getAuthorizer(overrides?: CallOverrides): Promise<[string]>;
        getCreationCode(overrides?: CallOverrides): Promise<[string]>;
        getCreationCodeContracts(overrides?: CallOverrides): Promise<[string, string] & {
            contractA: string;
            contractB: string;
        }>;
        getLastCreatedPool(overrides?: CallOverrides): Promise<[string]>;
        getPauseConfiguration(overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1
        ] & {
            pauseWindowDuration: BigNumber$1;
            bufferPeriodDuration: BigNumber$1;
        }>;
        getPoolVersion(overrides?: CallOverrides): Promise<[string]>;
        getProtocolFeePercentagesProvider(overrides?: CallOverrides): Promise<[string]>;
        getVault(overrides?: CallOverrides): Promise<[string]>;
        isDisabled(overrides?: CallOverrides): Promise<[boolean]>;
        isPoolFromFactory(pool: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;
        version(overrides?: CallOverrides): Promise<[string]>;
    };
    create(name: PromiseOrValue<string>, symbol: PromiseOrValue<string>, mainToken: PromiseOrValue<string>, wrappedToken: PromiseOrValue<string>, upperTarget: PromiseOrValue<BigNumberish$1>, swapFeePercentage: PromiseOrValue<BigNumberish$1>, owner: PromiseOrValue<string>, protocolId: PromiseOrValue<BigNumberish$1>, salt: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    disable(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
    getAuthorizer(overrides?: CallOverrides): Promise<string>;
    getCreationCode(overrides?: CallOverrides): Promise<string>;
    getCreationCodeContracts(overrides?: CallOverrides): Promise<[string, string] & {
        contractA: string;
        contractB: string;
    }>;
    getLastCreatedPool(overrides?: CallOverrides): Promise<string>;
    getPauseConfiguration(overrides?: CallOverrides): Promise<[
        BigNumber$1,
        BigNumber$1
    ] & {
        pauseWindowDuration: BigNumber$1;
        bufferPeriodDuration: BigNumber$1;
    }>;
    getPoolVersion(overrides?: CallOverrides): Promise<string>;
    getProtocolFeePercentagesProvider(overrides?: CallOverrides): Promise<string>;
    getVault(overrides?: CallOverrides): Promise<string>;
    isDisabled(overrides?: CallOverrides): Promise<boolean>;
    isPoolFromFactory(pool: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
    version(overrides?: CallOverrides): Promise<string>;
    callStatic: {
        create(name: PromiseOrValue<string>, symbol: PromiseOrValue<string>, mainToken: PromiseOrValue<string>, wrappedToken: PromiseOrValue<string>, upperTarget: PromiseOrValue<BigNumberish$1>, swapFeePercentage: PromiseOrValue<BigNumberish$1>, owner: PromiseOrValue<string>, protocolId: PromiseOrValue<BigNumberish$1>, salt: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
        disable(overrides?: CallOverrides): Promise<void>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
        getAuthorizer(overrides?: CallOverrides): Promise<string>;
        getCreationCode(overrides?: CallOverrides): Promise<string>;
        getCreationCodeContracts(overrides?: CallOverrides): Promise<[string, string] & {
            contractA: string;
            contractB: string;
        }>;
        getLastCreatedPool(overrides?: CallOverrides): Promise<string>;
        getPauseConfiguration(overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1
        ] & {
            pauseWindowDuration: BigNumber$1;
            bufferPeriodDuration: BigNumber$1;
        }>;
        getPoolVersion(overrides?: CallOverrides): Promise<string>;
        getProtocolFeePercentagesProvider(overrides?: CallOverrides): Promise<string>;
        getVault(overrides?: CallOverrides): Promise<string>;
        isDisabled(overrides?: CallOverrides): Promise<boolean>;
        isPoolFromFactory(pool: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
        version(overrides?: CallOverrides): Promise<string>;
    };
    filters: {
        "AaveLinearPoolCreated(address,uint256)"(pool?: PromiseOrValue<string> | null, protocolId?: PromiseOrValue<BigNumberish$1> | null): AaveLinearPoolCreatedEventFilter;
        AaveLinearPoolCreated(pool?: PromiseOrValue<string> | null, protocolId?: PromiseOrValue<BigNumberish$1> | null): AaveLinearPoolCreatedEventFilter;
        "FactoryDisabled()"(): FactoryDisabledEventFilter$6;
        FactoryDisabled(): FactoryDisabledEventFilter$6;
        "PoolCreated(address)"(pool?: PromiseOrValue<string> | null): PoolCreatedEventFilter$6;
        PoolCreated(pool?: PromiseOrValue<string> | null): PoolCreatedEventFilter$6;
    };
    estimateGas: {
        create(name: PromiseOrValue<string>, symbol: PromiseOrValue<string>, mainToken: PromiseOrValue<string>, wrappedToken: PromiseOrValue<string>, upperTarget: PromiseOrValue<BigNumberish$1>, swapFeePercentage: PromiseOrValue<BigNumberish$1>, owner: PromiseOrValue<string>, protocolId: PromiseOrValue<BigNumberish$1>, salt: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        disable(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getAuthorizer(overrides?: CallOverrides): Promise<BigNumber$1>;
        getCreationCode(overrides?: CallOverrides): Promise<BigNumber$1>;
        getCreationCodeContracts(overrides?: CallOverrides): Promise<BigNumber$1>;
        getLastCreatedPool(overrides?: CallOverrides): Promise<BigNumber$1>;
        getPauseConfiguration(overrides?: CallOverrides): Promise<BigNumber$1>;
        getPoolVersion(overrides?: CallOverrides): Promise<BigNumber$1>;
        getProtocolFeePercentagesProvider(overrides?: CallOverrides): Promise<BigNumber$1>;
        getVault(overrides?: CallOverrides): Promise<BigNumber$1>;
        isDisabled(overrides?: CallOverrides): Promise<BigNumber$1>;
        isPoolFromFactory(pool: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        version(overrides?: CallOverrides): Promise<BigNumber$1>;
    };
    populateTransaction: {
        create(name: PromiseOrValue<string>, symbol: PromiseOrValue<string>, mainToken: PromiseOrValue<string>, wrappedToken: PromiseOrValue<string>, upperTarget: PromiseOrValue<BigNumberish$1>, swapFeePercentage: PromiseOrValue<BigNumberish$1>, owner: PromiseOrValue<string>, protocolId: PromiseOrValue<BigNumberish$1>, salt: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        disable(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getAuthorizer(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getCreationCode(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getCreationCodeContracts(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getLastCreatedPool(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getPauseConfiguration(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getPoolVersion(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getProtocolFeePercentagesProvider(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getVault(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        isDisabled(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        isPoolFromFactory(pool: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        version(overrides?: CallOverrides): Promise<PopulatedTransaction>;
    };
}

interface AaveWrappingInterface extends utils.Interface {
    functions: {
        "approveVault(address,uint256)": FunctionFragment;
        "getVault()": FunctionFragment;
        "unwrapAaveStaticToken(address,address,address,uint256,bool,uint256)": FunctionFragment;
        "wrapAaveDynamicToken(address,address,address,uint256,bool,uint256)": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "approveVault" | "getVault" | "unwrapAaveStaticToken" | "wrapAaveDynamicToken"): FunctionFragment;
    encodeFunctionData(functionFragment: "approveVault", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "getVault", values?: undefined): string;
    encodeFunctionData(functionFragment: "unwrapAaveStaticToken", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<boolean>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "wrapAaveDynamicToken", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<boolean>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    decodeFunctionResult(functionFragment: "approveVault", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getVault", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "unwrapAaveStaticToken", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "wrapAaveDynamicToken", data: BytesLike): Result;
    events: {};
}
interface AaveWrapping extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: AaveWrappingInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        approveVault(token: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        getVault(overrides?: CallOverrides): Promise<[string]>;
        unwrapAaveStaticToken(staticToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, toUnderlying: PromiseOrValue<boolean>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        wrapAaveDynamicToken(staticToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, fromUnderlying: PromiseOrValue<boolean>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
    };
    approveVault(token: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    getVault(overrides?: CallOverrides): Promise<string>;
    unwrapAaveStaticToken(staticToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, toUnderlying: PromiseOrValue<boolean>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    wrapAaveDynamicToken(staticToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, fromUnderlying: PromiseOrValue<boolean>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        approveVault(token: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        getVault(overrides?: CallOverrides): Promise<string>;
        unwrapAaveStaticToken(staticToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, toUnderlying: PromiseOrValue<boolean>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        wrapAaveDynamicToken(staticToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, fromUnderlying: PromiseOrValue<boolean>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
    };
    filters: {};
    estimateGas: {
        approveVault(token: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        getVault(overrides?: CallOverrides): Promise<BigNumber$1>;
        unwrapAaveStaticToken(staticToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, toUnderlying: PromiseOrValue<boolean>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        wrapAaveDynamicToken(staticToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, fromUnderlying: PromiseOrValue<boolean>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
    };
    populateTransaction: {
        approveVault(token: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        getVault(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        unwrapAaveStaticToken(staticToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, toUnderlying: PromiseOrValue<boolean>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        wrapAaveDynamicToken(staticToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, fromUnderlying: PromiseOrValue<boolean>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
    };
}

interface AuthoriserInterface extends utils.Interface {
    functions: {
        "DEFAULT_ADMIN_ROLE()": FunctionFragment;
        "canPerform(bytes32,address,address)": FunctionFragment;
        "getRoleAdmin(bytes32)": FunctionFragment;
        "getRoleMember(bytes32,uint256)": FunctionFragment;
        "getRoleMemberCount(bytes32)": FunctionFragment;
        "grantRole(bytes32,address)": FunctionFragment;
        "grantRoles(bytes32[],address)": FunctionFragment;
        "grantRolesToMany(bytes32[],address[])": FunctionFragment;
        "hasRole(bytes32,address)": FunctionFragment;
        "renounceRole(bytes32,address)": FunctionFragment;
        "revokeRole(bytes32,address)": FunctionFragment;
        "revokeRoles(bytes32[],address)": FunctionFragment;
        "revokeRolesFromMany(bytes32[],address[])": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "DEFAULT_ADMIN_ROLE" | "canPerform" | "getRoleAdmin" | "getRoleMember" | "getRoleMemberCount" | "grantRole" | "grantRoles" | "grantRolesToMany" | "hasRole" | "renounceRole" | "revokeRole" | "revokeRoles" | "revokeRolesFromMany"): FunctionFragment;
    encodeFunctionData(functionFragment: "DEFAULT_ADMIN_ROLE", values?: undefined): string;
    encodeFunctionData(functionFragment: "canPerform", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>
    ]): string;
    encodeFunctionData(functionFragment: "getRoleAdmin", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "getRoleMember", values: [PromiseOrValue<BytesLike>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "getRoleMemberCount", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "grantRole", values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "grantRoles", values: [PromiseOrValue<BytesLike>[], PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "grantRolesToMany", values: [PromiseOrValue<BytesLike>[], PromiseOrValue<string>[]]): string;
    encodeFunctionData(functionFragment: "hasRole", values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "renounceRole", values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "revokeRole", values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "revokeRoles", values: [PromiseOrValue<BytesLike>[], PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "revokeRolesFromMany", values: [PromiseOrValue<BytesLike>[], PromiseOrValue<string>[]]): string;
    decodeFunctionResult(functionFragment: "DEFAULT_ADMIN_ROLE", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "canPerform", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getRoleAdmin", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getRoleMember", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getRoleMemberCount", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "grantRole", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "grantRoles", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "grantRolesToMany", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "hasRole", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "renounceRole", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "revokeRole", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "revokeRoles", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "revokeRolesFromMany", data: BytesLike): Result;
    events: {
        "RoleAdminChanged(bytes32,bytes32,bytes32)": EventFragment;
        "RoleGranted(bytes32,address,address)": EventFragment;
        "RoleRevoked(bytes32,address,address)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "RoleAdminChanged"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "RoleGranted"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "RoleRevoked"): EventFragment;
}
interface RoleAdminChangedEventObject {
    role: string;
    previousAdminRole: string;
    newAdminRole: string;
}
type RoleAdminChangedEvent = TypedEvent<[
    string,
    string,
    string
], RoleAdminChangedEventObject>;
type RoleAdminChangedEventFilter = TypedEventFilter<RoleAdminChangedEvent>;
interface RoleGrantedEventObject {
    role: string;
    account: string;
    sender: string;
}
type RoleGrantedEvent = TypedEvent<[
    string,
    string,
    string
], RoleGrantedEventObject>;
type RoleGrantedEventFilter = TypedEventFilter<RoleGrantedEvent>;
interface RoleRevokedEventObject {
    role: string;
    account: string;
    sender: string;
}
type RoleRevokedEvent = TypedEvent<[
    string,
    string,
    string
], RoleRevokedEventObject>;
type RoleRevokedEventFilter = TypedEventFilter<RoleRevokedEvent>;
interface Authoriser extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: AuthoriserInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<[string]>;
        canPerform(actionId: PromiseOrValue<BytesLike>, account: PromiseOrValue<string>, arg2: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;
        getRoleAdmin(role: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[string]>;
        getRoleMember(role: PromiseOrValue<BytesLike>, index: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<[string]>;
        getRoleMemberCount(role: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        grantRole(role: PromiseOrValue<BytesLike>, account: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        grantRoles(roles: PromiseOrValue<BytesLike>[], account: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        grantRolesToMany(roles: PromiseOrValue<BytesLike>[], accounts: PromiseOrValue<string>[], overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        hasRole(role: PromiseOrValue<BytesLike>, account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;
        renounceRole(role: PromiseOrValue<BytesLike>, account: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        revokeRole(role: PromiseOrValue<BytesLike>, account: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        revokeRoles(roles: PromiseOrValue<BytesLike>[], account: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        revokeRolesFromMany(roles: PromiseOrValue<BytesLike>[], accounts: PromiseOrValue<string>[], overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
    };
    DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<string>;
    canPerform(actionId: PromiseOrValue<BytesLike>, account: PromiseOrValue<string>, arg2: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
    getRoleAdmin(role: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
    getRoleMember(role: PromiseOrValue<BytesLike>, index: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<string>;
    getRoleMemberCount(role: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber$1>;
    grantRole(role: PromiseOrValue<BytesLike>, account: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    grantRoles(roles: PromiseOrValue<BytesLike>[], account: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    grantRolesToMany(roles: PromiseOrValue<BytesLike>[], accounts: PromiseOrValue<string>[], overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    hasRole(role: PromiseOrValue<BytesLike>, account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
    renounceRole(role: PromiseOrValue<BytesLike>, account: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    revokeRole(role: PromiseOrValue<BytesLike>, account: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    revokeRoles(roles: PromiseOrValue<BytesLike>[], account: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    revokeRolesFromMany(roles: PromiseOrValue<BytesLike>[], accounts: PromiseOrValue<string>[], overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<string>;
        canPerform(actionId: PromiseOrValue<BytesLike>, account: PromiseOrValue<string>, arg2: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
        getRoleAdmin(role: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
        getRoleMember(role: PromiseOrValue<BytesLike>, index: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<string>;
        getRoleMemberCount(role: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber$1>;
        grantRole(role: PromiseOrValue<BytesLike>, account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
        grantRoles(roles: PromiseOrValue<BytesLike>[], account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
        grantRolesToMany(roles: PromiseOrValue<BytesLike>[], accounts: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<void>;
        hasRole(role: PromiseOrValue<BytesLike>, account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
        renounceRole(role: PromiseOrValue<BytesLike>, account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
        revokeRole(role: PromiseOrValue<BytesLike>, account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
        revokeRoles(roles: PromiseOrValue<BytesLike>[], account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
        revokeRolesFromMany(roles: PromiseOrValue<BytesLike>[], accounts: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<void>;
    };
    filters: {
        "RoleAdminChanged(bytes32,bytes32,bytes32)"(role?: PromiseOrValue<BytesLike> | null, previousAdminRole?: PromiseOrValue<BytesLike> | null, newAdminRole?: PromiseOrValue<BytesLike> | null): RoleAdminChangedEventFilter;
        RoleAdminChanged(role?: PromiseOrValue<BytesLike> | null, previousAdminRole?: PromiseOrValue<BytesLike> | null, newAdminRole?: PromiseOrValue<BytesLike> | null): RoleAdminChangedEventFilter;
        "RoleGranted(bytes32,address,address)"(role?: PromiseOrValue<BytesLike> | null, account?: PromiseOrValue<string> | null, sender?: PromiseOrValue<string> | null): RoleGrantedEventFilter;
        RoleGranted(role?: PromiseOrValue<BytesLike> | null, account?: PromiseOrValue<string> | null, sender?: PromiseOrValue<string> | null): RoleGrantedEventFilter;
        "RoleRevoked(bytes32,address,address)"(role?: PromiseOrValue<BytesLike> | null, account?: PromiseOrValue<string> | null, sender?: PromiseOrValue<string> | null): RoleRevokedEventFilter;
        RoleRevoked(role?: PromiseOrValue<BytesLike> | null, account?: PromiseOrValue<string> | null, sender?: PromiseOrValue<string> | null): RoleRevokedEventFilter;
    };
    estimateGas: {
        DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<BigNumber$1>;
        canPerform(actionId: PromiseOrValue<BytesLike>, account: PromiseOrValue<string>, arg2: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getRoleAdmin(role: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getRoleMember(role: PromiseOrValue<BytesLike>, index: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getRoleMemberCount(role: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber$1>;
        grantRole(role: PromiseOrValue<BytesLike>, account: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        grantRoles(roles: PromiseOrValue<BytesLike>[], account: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        grantRolesToMany(roles: PromiseOrValue<BytesLike>[], accounts: PromiseOrValue<string>[], overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        hasRole(role: PromiseOrValue<BytesLike>, account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        renounceRole(role: PromiseOrValue<BytesLike>, account: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        revokeRole(role: PromiseOrValue<BytesLike>, account: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        revokeRoles(roles: PromiseOrValue<BytesLike>[], account: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        revokeRolesFromMany(roles: PromiseOrValue<BytesLike>[], accounts: PromiseOrValue<string>[], overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
    };
    populateTransaction: {
        DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        canPerform(actionId: PromiseOrValue<BytesLike>, account: PromiseOrValue<string>, arg2: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getRoleAdmin(role: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getRoleMember(role: PromiseOrValue<BytesLike>, index: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getRoleMemberCount(role: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        grantRole(role: PromiseOrValue<BytesLike>, account: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        grantRoles(roles: PromiseOrValue<BytesLike>[], account: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        grantRolesToMany(roles: PromiseOrValue<BytesLike>[], accounts: PromiseOrValue<string>[], overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        hasRole(role: PromiseOrValue<BytesLike>, account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        renounceRole(role: PromiseOrValue<BytesLike>, account: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        revokeRole(role: PromiseOrValue<BytesLike>, account: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        revokeRoles(roles: PromiseOrValue<BytesLike>[], account: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        revokeRolesFromMany(roles: PromiseOrValue<BytesLike>[], accounts: PromiseOrValue<string>[], overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
    };
}

declare namespace IVault$3 {
    type ExitPoolRequestStruct = {
        assets: PromiseOrValue<string>[];
        minAmountsOut: PromiseOrValue<BigNumberish$1>[];
        userData: PromiseOrValue<BytesLike>;
        toInternalBalance: PromiseOrValue<boolean>;
    };
    type ExitPoolRequestStructOutput = [
        string[],
        BigNumber$1[],
        string,
        boolean
    ] & {
        assets: string[];
        minAmountsOut: BigNumber$1[];
        userData: string;
        toInternalBalance: boolean;
    };
    type JoinPoolRequestStruct = {
        assets: PromiseOrValue<string>[];
        maxAmountsIn: PromiseOrValue<BigNumberish$1>[];
        userData: PromiseOrValue<BytesLike>;
        fromInternalBalance: PromiseOrValue<boolean>;
    };
    type JoinPoolRequestStructOutput = [
        string[],
        BigNumber$1[],
        string,
        boolean
    ] & {
        assets: string[];
        maxAmountsIn: BigNumber$1[];
        userData: string;
        fromInternalBalance: boolean;
    };
}
interface BalancerHelpersInterface extends utils.Interface {
    functions: {
        "queryExit(bytes32,address,address,(address[],uint256[],bytes,bool))": FunctionFragment;
        "queryJoin(bytes32,address,address,(address[],uint256[],bytes,bool))": FunctionFragment;
        "vault()": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "queryExit" | "queryJoin" | "vault"): FunctionFragment;
    encodeFunctionData(functionFragment: "queryExit", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        IVault$3.ExitPoolRequestStruct
    ]): string;
    encodeFunctionData(functionFragment: "queryJoin", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        IVault$3.JoinPoolRequestStruct
    ]): string;
    encodeFunctionData(functionFragment: "vault", values?: undefined): string;
    decodeFunctionResult(functionFragment: "queryExit", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "queryJoin", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "vault", data: BytesLike): Result;
    events: {};
}
interface BalancerHelpers extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: BalancerHelpersInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        queryExit(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, request: IVault$3.ExitPoolRequestStruct, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        queryJoin(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, request: IVault$3.JoinPoolRequestStruct, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        vault(overrides?: CallOverrides): Promise<[string]>;
    };
    queryExit(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, request: IVault$3.ExitPoolRequestStruct, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    queryJoin(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, request: IVault$3.JoinPoolRequestStruct, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    vault(overrides?: CallOverrides): Promise<string>;
    callStatic: {
        queryExit(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, request: IVault$3.ExitPoolRequestStruct, overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1[]
        ] & {
            bptIn: BigNumber$1;
            amountsOut: BigNumber$1[];
        }>;
        queryJoin(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, request: IVault$3.JoinPoolRequestStruct, overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1[]
        ] & {
            bptOut: BigNumber$1;
            amountsIn: BigNumber$1[];
        }>;
        vault(overrides?: CallOverrides): Promise<string>;
    };
    filters: {};
    estimateGas: {
        queryExit(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, request: IVault$3.ExitPoolRequestStruct, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        queryJoin(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, request: IVault$3.JoinPoolRequestStruct, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        vault(overrides?: CallOverrides): Promise<BigNumber$1>;
    };
    populateTransaction: {
        queryExit(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, request: IVault$3.ExitPoolRequestStruct, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        queryJoin(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, request: IVault$3.JoinPoolRequestStruct, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        vault(overrides?: CallOverrides): Promise<PopulatedTransaction>;
    };
}

interface BalancerMinterInterface extends utils.Interface {
    functions: {
        "allowed_to_mint_for(address,address)": FunctionFragment;
        "getBalancerToken()": FunctionFragment;
        "getBalancerTokenAdmin()": FunctionFragment;
        "getDomainSeparator()": FunctionFragment;
        "getGaugeController()": FunctionFragment;
        "getMinterApproval(address,address)": FunctionFragment;
        "getNextNonce(address)": FunctionFragment;
        "mint(address)": FunctionFragment;
        "mintFor(address,address)": FunctionFragment;
        "mintMany(address[])": FunctionFragment;
        "mintManyFor(address[],address)": FunctionFragment;
        "mint_for(address,address)": FunctionFragment;
        "mint_many(address[8])": FunctionFragment;
        "minted(address,address)": FunctionFragment;
        "setMinterApproval(address,bool)": FunctionFragment;
        "setMinterApprovalWithSignature(address,bool,address,uint256,uint8,bytes32,bytes32)": FunctionFragment;
        "toggle_approve_mint(address)": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "allowed_to_mint_for" | "getBalancerToken" | "getBalancerTokenAdmin" | "getDomainSeparator" | "getGaugeController" | "getMinterApproval" | "getNextNonce" | "mint" | "mintFor" | "mintMany" | "mintManyFor" | "mint_for" | "mint_many" | "minted" | "setMinterApproval" | "setMinterApprovalWithSignature" | "toggle_approve_mint"): FunctionFragment;
    encodeFunctionData(functionFragment: "allowed_to_mint_for", values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "getBalancerToken", values?: undefined): string;
    encodeFunctionData(functionFragment: "getBalancerTokenAdmin", values?: undefined): string;
    encodeFunctionData(functionFragment: "getDomainSeparator", values?: undefined): string;
    encodeFunctionData(functionFragment: "getGaugeController", values?: undefined): string;
    encodeFunctionData(functionFragment: "getMinterApproval", values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "getNextNonce", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "mint", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "mintFor", values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "mintMany", values: [PromiseOrValue<string>[]]): string;
    encodeFunctionData(functionFragment: "mintManyFor", values: [PromiseOrValue<string>[], PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "mint_for", values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "mint_many", values: [PromiseOrValue<string>[]]): string;
    encodeFunctionData(functionFragment: "minted", values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "setMinterApproval", values: [PromiseOrValue<string>, PromiseOrValue<boolean>]): string;
    encodeFunctionData(functionFragment: "setMinterApprovalWithSignature", values: [
        PromiseOrValue<string>,
        PromiseOrValue<boolean>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "toggle_approve_mint", values: [PromiseOrValue<string>]): string;
    decodeFunctionResult(functionFragment: "allowed_to_mint_for", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getBalancerToken", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getBalancerTokenAdmin", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getDomainSeparator", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getGaugeController", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getMinterApproval", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getNextNonce", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "mint", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "mintFor", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "mintMany", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "mintManyFor", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "mint_for", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "mint_many", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "minted", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setMinterApproval", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setMinterApprovalWithSignature", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "toggle_approve_mint", data: BytesLike): Result;
    events: {
        "Minted(address,address,uint256)": EventFragment;
        "MinterApprovalSet(address,address,bool)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "Minted"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "MinterApprovalSet"): EventFragment;
}
interface MintedEventObject {
    recipient: string;
    gauge: string;
    minted: BigNumber$1;
}
type MintedEvent = TypedEvent<[
    string,
    string,
    BigNumber$1
], MintedEventObject>;
type MintedEventFilter = TypedEventFilter<MintedEvent>;
interface MinterApprovalSetEventObject {
    user: string;
    minter: string;
    approval: boolean;
}
type MinterApprovalSetEvent = TypedEvent<[
    string,
    string,
    boolean
], MinterApprovalSetEventObject>;
type MinterApprovalSetEventFilter = TypedEventFilter<MinterApprovalSetEvent>;
interface BalancerMinter extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: BalancerMinterInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        allowed_to_mint_for(minter: PromiseOrValue<string>, user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;
        getBalancerToken(overrides?: CallOverrides): Promise<[string]>;
        getBalancerTokenAdmin(overrides?: CallOverrides): Promise<[string]>;
        getDomainSeparator(overrides?: CallOverrides): Promise<[string]>;
        getGaugeController(overrides?: CallOverrides): Promise<[string]>;
        getMinterApproval(minter: PromiseOrValue<string>, user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;
        getNextNonce(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        mint(gauge: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        mintFor(gauge: PromiseOrValue<string>, user: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        mintMany(gauges: PromiseOrValue<string>[], overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        mintManyFor(gauges: PromiseOrValue<string>[], user: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        mint_for(gauge: PromiseOrValue<string>, user: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        mint_many(gauges: PromiseOrValue<string>[], overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        minted(user: PromiseOrValue<string>, gauge: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        setMinterApproval(minter: PromiseOrValue<string>, approval: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setMinterApprovalWithSignature(minter: PromiseOrValue<string>, approval: PromiseOrValue<boolean>, user: PromiseOrValue<string>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        toggle_approve_mint(minter: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
    };
    allowed_to_mint_for(minter: PromiseOrValue<string>, user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
    getBalancerToken(overrides?: CallOverrides): Promise<string>;
    getBalancerTokenAdmin(overrides?: CallOverrides): Promise<string>;
    getDomainSeparator(overrides?: CallOverrides): Promise<string>;
    getGaugeController(overrides?: CallOverrides): Promise<string>;
    getMinterApproval(minter: PromiseOrValue<string>, user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
    getNextNonce(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    mint(gauge: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    mintFor(gauge: PromiseOrValue<string>, user: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    mintMany(gauges: PromiseOrValue<string>[], overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    mintManyFor(gauges: PromiseOrValue<string>[], user: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    mint_for(gauge: PromiseOrValue<string>, user: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    mint_many(gauges: PromiseOrValue<string>[], overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    minted(user: PromiseOrValue<string>, gauge: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    setMinterApproval(minter: PromiseOrValue<string>, approval: PromiseOrValue<boolean>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setMinterApprovalWithSignature(minter: PromiseOrValue<string>, approval: PromiseOrValue<boolean>, user: PromiseOrValue<string>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    toggle_approve_mint(minter: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        allowed_to_mint_for(minter: PromiseOrValue<string>, user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
        getBalancerToken(overrides?: CallOverrides): Promise<string>;
        getBalancerTokenAdmin(overrides?: CallOverrides): Promise<string>;
        getDomainSeparator(overrides?: CallOverrides): Promise<string>;
        getGaugeController(overrides?: CallOverrides): Promise<string>;
        getMinterApproval(minter: PromiseOrValue<string>, user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
        getNextNonce(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        mint(gauge: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        mintFor(gauge: PromiseOrValue<string>, user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        mintMany(gauges: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<BigNumber$1>;
        mintManyFor(gauges: PromiseOrValue<string>[], user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        mint_for(gauge: PromiseOrValue<string>, user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
        mint_many(gauges: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<void>;
        minted(user: PromiseOrValue<string>, gauge: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        setMinterApproval(minter: PromiseOrValue<string>, approval: PromiseOrValue<boolean>, overrides?: CallOverrides): Promise<void>;
        setMinterApprovalWithSignature(minter: PromiseOrValue<string>, approval: PromiseOrValue<boolean>, user: PromiseOrValue<string>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<void>;
        toggle_approve_mint(minter: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
    };
    filters: {
        "Minted(address,address,uint256)"(recipient?: PromiseOrValue<string> | null, gauge?: null, minted?: null): MintedEventFilter;
        Minted(recipient?: PromiseOrValue<string> | null, gauge?: null, minted?: null): MintedEventFilter;
        "MinterApprovalSet(address,address,bool)"(user?: PromiseOrValue<string> | null, minter?: PromiseOrValue<string> | null, approval?: null): MinterApprovalSetEventFilter;
        MinterApprovalSet(user?: PromiseOrValue<string> | null, minter?: PromiseOrValue<string> | null, approval?: null): MinterApprovalSetEventFilter;
    };
    estimateGas: {
        allowed_to_mint_for(minter: PromiseOrValue<string>, user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getBalancerToken(overrides?: CallOverrides): Promise<BigNumber$1>;
        getBalancerTokenAdmin(overrides?: CallOverrides): Promise<BigNumber$1>;
        getDomainSeparator(overrides?: CallOverrides): Promise<BigNumber$1>;
        getGaugeController(overrides?: CallOverrides): Promise<BigNumber$1>;
        getMinterApproval(minter: PromiseOrValue<string>, user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getNextNonce(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        mint(gauge: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        mintFor(gauge: PromiseOrValue<string>, user: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        mintMany(gauges: PromiseOrValue<string>[], overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        mintManyFor(gauges: PromiseOrValue<string>[], user: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        mint_for(gauge: PromiseOrValue<string>, user: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        mint_many(gauges: PromiseOrValue<string>[], overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        minted(user: PromiseOrValue<string>, gauge: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        setMinterApproval(minter: PromiseOrValue<string>, approval: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        setMinterApprovalWithSignature(minter: PromiseOrValue<string>, approval: PromiseOrValue<boolean>, user: PromiseOrValue<string>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        toggle_approve_mint(minter: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
    };
    populateTransaction: {
        allowed_to_mint_for(minter: PromiseOrValue<string>, user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getBalancerToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getBalancerTokenAdmin(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getDomainSeparator(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getGaugeController(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getMinterApproval(minter: PromiseOrValue<string>, user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getNextNonce(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        mint(gauge: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        mintFor(gauge: PromiseOrValue<string>, user: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        mintMany(gauges: PromiseOrValue<string>[], overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        mintManyFor(gauges: PromiseOrValue<string>[], user: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        mint_for(gauge: PromiseOrValue<string>, user: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        mint_many(gauges: PromiseOrValue<string>[], overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        minted(user: PromiseOrValue<string>, gauge: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        setMinterApproval(minter: PromiseOrValue<string>, approval: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setMinterApprovalWithSignature(minter: PromiseOrValue<string>, approval: PromiseOrValue<boolean>, user: PromiseOrValue<string>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        toggle_approve_mint(minter: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
    };
}

type PoolDataQueryConfigStruct = {
    loadTokenBalanceUpdatesAfterBlock: PromiseOrValue<boolean>;
    loadTotalSupply: PromiseOrValue<boolean>;
    loadSwapFees: PromiseOrValue<boolean>;
    loadLinearWrappedTokenRates: PromiseOrValue<boolean>;
    loadLinearTargets: PromiseOrValue<boolean>;
    loadNormalizedWeights: PromiseOrValue<boolean>;
    loadScalingFactors: PromiseOrValue<boolean>;
    loadAmps: PromiseOrValue<boolean>;
    loadRates: PromiseOrValue<boolean>;
    blockNumber: PromiseOrValue<BigNumberish$1>;
    totalSupplyTypes: PromiseOrValue<BigNumberish$1>[];
    swapFeeTypes: PromiseOrValue<BigNumberish$1>[];
    linearPoolIdxs: PromiseOrValue<BigNumberish$1>[];
    weightedPoolIdxs: PromiseOrValue<BigNumberish$1>[];
    scalingFactorPoolIdxs: PromiseOrValue<BigNumberish$1>[];
    ampPoolIdxs: PromiseOrValue<BigNumberish$1>[];
    ratePoolIdxs: PromiseOrValue<BigNumberish$1>[];
};
type PoolStatusQueryConfigStruct = {
    loadInRecoveryMode: PromiseOrValue<boolean>;
    loadIsPaused: PromiseOrValue<boolean>;
};
interface BalancerPoolDataQueriesInterface extends utils.Interface {
    functions: {
        "getAmpForPools(address[])": FunctionFragment;
        "getInRecoveryModeForPools(address[])": FunctionFragment;
        "getIsPausedForPools(address[])": FunctionFragment;
        "getLinearTargetsForPools(address[])": FunctionFragment;
        "getNormalizedWeightsForPools(address[])": FunctionFragment;
        "getPoolData(bytes32[],(bool,bool,bool,bool,bool,bool,bool,bool,bool,uint256,uint8[],uint8[],uint256[],uint256[],uint256[],uint256[],uint256[]))": FunctionFragment;
        "getPoolStatus(bytes32[],(bool,bool))": FunctionFragment;
        "getPoolTokenBalancesWithUpdatesAfterBlock(bytes32[],uint256)": FunctionFragment;
        "getRateForPools(address[])": FunctionFragment;
        "getScalingFactorsForPools(address[])": FunctionFragment;
        "getSwapFeePercentageForPools(address[],uint8[])": FunctionFragment;
        "getTotalSupplyForPools(address[],uint8[])": FunctionFragment;
        "getWrappedTokenRateForLinearPools(address[])": FunctionFragment;
        "vault()": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "getAmpForPools" | "getInRecoveryModeForPools" | "getIsPausedForPools" | "getLinearTargetsForPools" | "getNormalizedWeightsForPools" | "getPoolData" | "getPoolStatus" | "getPoolTokenBalancesWithUpdatesAfterBlock" | "getRateForPools" | "getScalingFactorsForPools" | "getSwapFeePercentageForPools" | "getTotalSupplyForPools" | "getWrappedTokenRateForLinearPools" | "vault"): FunctionFragment;
    encodeFunctionData(functionFragment: "getAmpForPools", values: [PromiseOrValue<string>[]]): string;
    encodeFunctionData(functionFragment: "getInRecoveryModeForPools", values: [PromiseOrValue<string>[]]): string;
    encodeFunctionData(functionFragment: "getIsPausedForPools", values: [PromiseOrValue<string>[]]): string;
    encodeFunctionData(functionFragment: "getLinearTargetsForPools", values: [PromiseOrValue<string>[]]): string;
    encodeFunctionData(functionFragment: "getNormalizedWeightsForPools", values: [PromiseOrValue<string>[]]): string;
    encodeFunctionData(functionFragment: "getPoolData", values: [PromiseOrValue<BytesLike>[], PoolDataQueryConfigStruct]): string;
    encodeFunctionData(functionFragment: "getPoolStatus", values: [PromiseOrValue<BytesLike>[], PoolStatusQueryConfigStruct]): string;
    encodeFunctionData(functionFragment: "getPoolTokenBalancesWithUpdatesAfterBlock", values: [PromiseOrValue<BytesLike>[], PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "getRateForPools", values: [PromiseOrValue<string>[]]): string;
    encodeFunctionData(functionFragment: "getScalingFactorsForPools", values: [PromiseOrValue<string>[]]): string;
    encodeFunctionData(functionFragment: "getSwapFeePercentageForPools", values: [PromiseOrValue<string>[], PromiseOrValue<BigNumberish$1>[]]): string;
    encodeFunctionData(functionFragment: "getTotalSupplyForPools", values: [PromiseOrValue<string>[], PromiseOrValue<BigNumberish$1>[]]): string;
    encodeFunctionData(functionFragment: "getWrappedTokenRateForLinearPools", values: [PromiseOrValue<string>[]]): string;
    encodeFunctionData(functionFragment: "vault", values?: undefined): string;
    decodeFunctionResult(functionFragment: "getAmpForPools", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getInRecoveryModeForPools", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getIsPausedForPools", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getLinearTargetsForPools", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getNormalizedWeightsForPools", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getPoolData", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getPoolStatus", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getPoolTokenBalancesWithUpdatesAfterBlock", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getRateForPools", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getScalingFactorsForPools", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getSwapFeePercentageForPools", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getTotalSupplyForPools", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getWrappedTokenRateForLinearPools", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "vault", data: BytesLike): Result;
    events: {};
}
interface BalancerPoolDataQueries extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: BalancerPoolDataQueriesInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        getAmpForPools(poolAddresses: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<[BigNumber$1[]]>;
        getInRecoveryModeForPools(poolAddresses: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<[boolean[]]>;
        getIsPausedForPools(poolAddresses: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<[boolean[]]>;
        getLinearTargetsForPools(poolAddresses: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<[BigNumber$1[][]]>;
        getNormalizedWeightsForPools(poolAddresses: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<[BigNumber$1[][]]>;
        getPoolData(poolIds: PromiseOrValue<BytesLike>[], config: PoolDataQueryConfigStruct, overrides?: CallOverrides): Promise<[
            BigNumber$1[][],
            BigNumber$1[],
            BigNumber$1[],
            BigNumber$1[],
            BigNumber$1[][],
            BigNumber$1[][],
            BigNumber$1[][],
            BigNumber$1[],
            BigNumber$1[],
            BigNumber$1[]
        ] & {
            balances: BigNumber$1[][];
            totalSupplies: BigNumber$1[];
            swapFees: BigNumber$1[];
            linearWrappedTokenRates: BigNumber$1[];
            linearTargets: BigNumber$1[][];
            weights: BigNumber$1[][];
            scalingFactors: BigNumber$1[][];
            amps: BigNumber$1[];
            rates: BigNumber$1[];
            ignoreIdxs: BigNumber$1[];
        }>;
        getPoolStatus(poolIds: PromiseOrValue<BytesLike>[], config: PoolStatusQueryConfigStruct, overrides?: CallOverrides): Promise<[
            boolean[],
            boolean[]
        ] & {
            isPaused: boolean[];
            inRecoveryMode: boolean[];
        }>;
        getPoolTokenBalancesWithUpdatesAfterBlock(poolIds: PromiseOrValue<BytesLike>[], blockNumber: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<[BigNumber$1[][]]>;
        getRateForPools(poolAddresses: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<[BigNumber$1[]]>;
        getScalingFactorsForPools(poolAddresses: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<[BigNumber$1[][]]>;
        getSwapFeePercentageForPools(poolAddresses: PromiseOrValue<string>[], swapFeeTypes: PromiseOrValue<BigNumberish$1>[], overrides?: CallOverrides): Promise<[BigNumber$1[]]>;
        getTotalSupplyForPools(poolAddresses: PromiseOrValue<string>[], totalSupplyTypes: PromiseOrValue<BigNumberish$1>[], overrides?: CallOverrides): Promise<[BigNumber$1[]]>;
        getWrappedTokenRateForLinearPools(poolAddresses: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<[BigNumber$1[]]>;
        vault(overrides?: CallOverrides): Promise<[string]>;
    };
    getAmpForPools(poolAddresses: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<BigNumber$1[]>;
    getInRecoveryModeForPools(poolAddresses: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<boolean[]>;
    getIsPausedForPools(poolAddresses: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<boolean[]>;
    getLinearTargetsForPools(poolAddresses: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<BigNumber$1[][]>;
    getNormalizedWeightsForPools(poolAddresses: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<BigNumber$1[][]>;
    getPoolData(poolIds: PromiseOrValue<BytesLike>[], config: PoolDataQueryConfigStruct, overrides?: CallOverrides): Promise<[
        BigNumber$1[][],
        BigNumber$1[],
        BigNumber$1[],
        BigNumber$1[],
        BigNumber$1[][],
        BigNumber$1[][],
        BigNumber$1[][],
        BigNumber$1[],
        BigNumber$1[],
        BigNumber$1[]
    ] & {
        balances: BigNumber$1[][];
        totalSupplies: BigNumber$1[];
        swapFees: BigNumber$1[];
        linearWrappedTokenRates: BigNumber$1[];
        linearTargets: BigNumber$1[][];
        weights: BigNumber$1[][];
        scalingFactors: BigNumber$1[][];
        amps: BigNumber$1[];
        rates: BigNumber$1[];
        ignoreIdxs: BigNumber$1[];
    }>;
    getPoolStatus(poolIds: PromiseOrValue<BytesLike>[], config: PoolStatusQueryConfigStruct, overrides?: CallOverrides): Promise<[
        boolean[],
        boolean[]
    ] & {
        isPaused: boolean[];
        inRecoveryMode: boolean[];
    }>;
    getPoolTokenBalancesWithUpdatesAfterBlock(poolIds: PromiseOrValue<BytesLike>[], blockNumber: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1[][]>;
    getRateForPools(poolAddresses: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<BigNumber$1[]>;
    getScalingFactorsForPools(poolAddresses: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<BigNumber$1[][]>;
    getSwapFeePercentageForPools(poolAddresses: PromiseOrValue<string>[], swapFeeTypes: PromiseOrValue<BigNumberish$1>[], overrides?: CallOverrides): Promise<BigNumber$1[]>;
    getTotalSupplyForPools(poolAddresses: PromiseOrValue<string>[], totalSupplyTypes: PromiseOrValue<BigNumberish$1>[], overrides?: CallOverrides): Promise<BigNumber$1[]>;
    getWrappedTokenRateForLinearPools(poolAddresses: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<BigNumber$1[]>;
    vault(overrides?: CallOverrides): Promise<string>;
    callStatic: {
        getAmpForPools(poolAddresses: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<BigNumber$1[]>;
        getInRecoveryModeForPools(poolAddresses: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<boolean[]>;
        getIsPausedForPools(poolAddresses: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<boolean[]>;
        getLinearTargetsForPools(poolAddresses: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<BigNumber$1[][]>;
        getNormalizedWeightsForPools(poolAddresses: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<BigNumber$1[][]>;
        getPoolData(poolIds: PromiseOrValue<BytesLike>[], config: PoolDataQueryConfigStruct, overrides?: CallOverrides): Promise<[
            BigNumber$1[][],
            BigNumber$1[],
            BigNumber$1[],
            BigNumber$1[],
            BigNumber$1[][],
            BigNumber$1[][],
            BigNumber$1[][],
            BigNumber$1[],
            BigNumber$1[],
            BigNumber$1[]
        ] & {
            balances: BigNumber$1[][];
            totalSupplies: BigNumber$1[];
            swapFees: BigNumber$1[];
            linearWrappedTokenRates: BigNumber$1[];
            linearTargets: BigNumber$1[][];
            weights: BigNumber$1[][];
            scalingFactors: BigNumber$1[][];
            amps: BigNumber$1[];
            rates: BigNumber$1[];
            ignoreIdxs: BigNumber$1[];
        }>;
        getPoolStatus(poolIds: PromiseOrValue<BytesLike>[], config: PoolStatusQueryConfigStruct, overrides?: CallOverrides): Promise<[
            boolean[],
            boolean[]
        ] & {
            isPaused: boolean[];
            inRecoveryMode: boolean[];
        }>;
        getPoolTokenBalancesWithUpdatesAfterBlock(poolIds: PromiseOrValue<BytesLike>[], blockNumber: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1[][]>;
        getRateForPools(poolAddresses: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<BigNumber$1[]>;
        getScalingFactorsForPools(poolAddresses: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<BigNumber$1[][]>;
        getSwapFeePercentageForPools(poolAddresses: PromiseOrValue<string>[], swapFeeTypes: PromiseOrValue<BigNumberish$1>[], overrides?: CallOverrides): Promise<BigNumber$1[]>;
        getTotalSupplyForPools(poolAddresses: PromiseOrValue<string>[], totalSupplyTypes: PromiseOrValue<BigNumberish$1>[], overrides?: CallOverrides): Promise<BigNumber$1[]>;
        getWrappedTokenRateForLinearPools(poolAddresses: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<BigNumber$1[]>;
        vault(overrides?: CallOverrides): Promise<string>;
    };
    filters: {};
    estimateGas: {
        getAmpForPools(poolAddresses: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<BigNumber$1>;
        getInRecoveryModeForPools(poolAddresses: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<BigNumber$1>;
        getIsPausedForPools(poolAddresses: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<BigNumber$1>;
        getLinearTargetsForPools(poolAddresses: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<BigNumber$1>;
        getNormalizedWeightsForPools(poolAddresses: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<BigNumber$1>;
        getPoolData(poolIds: PromiseOrValue<BytesLike>[], config: PoolDataQueryConfigStruct, overrides?: CallOverrides): Promise<BigNumber$1>;
        getPoolStatus(poolIds: PromiseOrValue<BytesLike>[], config: PoolStatusQueryConfigStruct, overrides?: CallOverrides): Promise<BigNumber$1>;
        getPoolTokenBalancesWithUpdatesAfterBlock(poolIds: PromiseOrValue<BytesLike>[], blockNumber: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getRateForPools(poolAddresses: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<BigNumber$1>;
        getScalingFactorsForPools(poolAddresses: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<BigNumber$1>;
        getSwapFeePercentageForPools(poolAddresses: PromiseOrValue<string>[], swapFeeTypes: PromiseOrValue<BigNumberish$1>[], overrides?: CallOverrides): Promise<BigNumber$1>;
        getTotalSupplyForPools(poolAddresses: PromiseOrValue<string>[], totalSupplyTypes: PromiseOrValue<BigNumberish$1>[], overrides?: CallOverrides): Promise<BigNumber$1>;
        getWrappedTokenRateForLinearPools(poolAddresses: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<BigNumber$1>;
        vault(overrides?: CallOverrides): Promise<BigNumber$1>;
    };
    populateTransaction: {
        getAmpForPools(poolAddresses: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getInRecoveryModeForPools(poolAddresses: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getIsPausedForPools(poolAddresses: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getLinearTargetsForPools(poolAddresses: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getNormalizedWeightsForPools(poolAddresses: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getPoolData(poolIds: PromiseOrValue<BytesLike>[], config: PoolDataQueryConfigStruct, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getPoolStatus(poolIds: PromiseOrValue<BytesLike>[], config: PoolStatusQueryConfigStruct, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getPoolTokenBalancesWithUpdatesAfterBlock(poolIds: PromiseOrValue<BytesLike>[], blockNumber: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getRateForPools(poolAddresses: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getScalingFactorsForPools(poolAddresses: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getSwapFeePercentageForPools(poolAddresses: PromiseOrValue<string>[], swapFeeTypes: PromiseOrValue<BigNumberish$1>[], overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getTotalSupplyForPools(poolAddresses: PromiseOrValue<string>[], totalSupplyTypes: PromiseOrValue<BigNumberish$1>[], overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getWrappedTokenRateForLinearPools(poolAddresses: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<PopulatedTransaction>;
        vault(overrides?: CallOverrides): Promise<PopulatedTransaction>;
    };
}

interface BalancerRelayerInterface extends utils.Interface {
    functions: {
        "getLibrary()": FunctionFragment;
        "getVault()": FunctionFragment;
        "multicall(bytes[])": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "getLibrary" | "getVault" | "multicall"): FunctionFragment;
    encodeFunctionData(functionFragment: "getLibrary", values?: undefined): string;
    encodeFunctionData(functionFragment: "getVault", values?: undefined): string;
    encodeFunctionData(functionFragment: "multicall", values: [PromiseOrValue<BytesLike>[]]): string;
    decodeFunctionResult(functionFragment: "getLibrary", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getVault", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "multicall", data: BytesLike): Result;
    events: {};
}
interface BalancerRelayer extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: BalancerRelayerInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        getLibrary(overrides?: CallOverrides): Promise<[string]>;
        getVault(overrides?: CallOverrides): Promise<[string]>;
        multicall(data: PromiseOrValue<BytesLike>[], overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
    };
    getLibrary(overrides?: CallOverrides): Promise<string>;
    getVault(overrides?: CallOverrides): Promise<string>;
    multicall(data: PromiseOrValue<BytesLike>[], overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        getLibrary(overrides?: CallOverrides): Promise<string>;
        getVault(overrides?: CallOverrides): Promise<string>;
        multicall(data: PromiseOrValue<BytesLike>[], overrides?: CallOverrides): Promise<string[]>;
    };
    filters: {};
    estimateGas: {
        getLibrary(overrides?: CallOverrides): Promise<BigNumber$1>;
        getVault(overrides?: CallOverrides): Promise<BigNumber$1>;
        multicall(data: PromiseOrValue<BytesLike>[], overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
    };
    populateTransaction: {
        getLibrary(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getVault(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        multicall(data: PromiseOrValue<BytesLike>[], overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
    };
}

declare namespace IVault$2 {
    type BatchSwapStepStruct = {
        poolId: PromiseOrValue<BytesLike>;
        assetInIndex: PromiseOrValue<BigNumberish$1>;
        assetOutIndex: PromiseOrValue<BigNumberish$1>;
        amount: PromiseOrValue<BigNumberish$1>;
        userData: PromiseOrValue<BytesLike>;
    };
    type BatchSwapStepStructOutput = [
        string,
        BigNumber$1,
        BigNumber$1,
        BigNumber$1,
        string
    ] & {
        poolId: string;
        assetInIndex: BigNumber$1;
        assetOutIndex: BigNumber$1;
        amount: BigNumber$1;
        userData: string;
    };
    type FundManagementStruct = {
        sender: PromiseOrValue<string>;
        fromInternalBalance: PromiseOrValue<boolean>;
        recipient: PromiseOrValue<string>;
        toInternalBalance: PromiseOrValue<boolean>;
    };
    type FundManagementStructOutput = [
        string,
        boolean,
        string,
        boolean
    ] & {
        sender: string;
        fromInternalBalance: boolean;
        recipient: string;
        toInternalBalance: boolean;
    };
    type ExitPoolRequestStruct = {
        assets: PromiseOrValue<string>[];
        minAmountsOut: PromiseOrValue<BigNumberish$1>[];
        userData: PromiseOrValue<BytesLike>;
        toInternalBalance: PromiseOrValue<boolean>;
    };
    type ExitPoolRequestStructOutput = [
        string[],
        BigNumber$1[],
        string,
        boolean
    ] & {
        assets: string[];
        minAmountsOut: BigNumber$1[];
        userData: string;
        toInternalBalance: boolean;
    };
    type JoinPoolRequestStruct = {
        assets: PromiseOrValue<string>[];
        maxAmountsIn: PromiseOrValue<BigNumberish$1>[];
        userData: PromiseOrValue<BytesLike>;
        fromInternalBalance: PromiseOrValue<boolean>;
    };
    type JoinPoolRequestStructOutput = [
        string[],
        BigNumber$1[],
        string,
        boolean
    ] & {
        assets: string[];
        maxAmountsIn: BigNumber$1[];
        userData: string;
        fromInternalBalance: boolean;
    };
    type UserBalanceOpStruct = {
        kind: PromiseOrValue<BigNumberish$1>;
        asset: PromiseOrValue<string>;
        amount: PromiseOrValue<BigNumberish$1>;
        sender: PromiseOrValue<string>;
        recipient: PromiseOrValue<string>;
    };
    type UserBalanceOpStructOutput = [
        number,
        string,
        BigNumber$1,
        string,
        string
    ] & {
        kind: number;
        asset: string;
        amount: BigNumber$1;
        sender: string;
        recipient: string;
    };
    type SingleSwapStruct = {
        poolId: PromiseOrValue<BytesLike>;
        kind: PromiseOrValue<BigNumberish$1>;
        assetIn: PromiseOrValue<string>;
        assetOut: PromiseOrValue<string>;
        amount: PromiseOrValue<BigNumberish$1>;
        userData: PromiseOrValue<BytesLike>;
    };
    type SingleSwapStructOutput = [
        string,
        number,
        string,
        string,
        BigNumber$1,
        string
    ] & {
        poolId: string;
        kind: number;
        assetIn: string;
        assetOut: string;
        amount: BigNumber$1;
        userData: string;
    };
}
declare namespace VaultActions {
    type OutputReferenceStruct = {
        index: PromiseOrValue<BigNumberish$1>;
        key: PromiseOrValue<BigNumberish$1>;
    };
    type OutputReferenceStructOutput = [BigNumber$1, BigNumber$1] & {
        index: BigNumber$1;
        key: BigNumber$1;
    };
}
interface BatchRelayerLibraryInterface extends utils.Interface {
    functions: {
        "approveVault(address,uint256)": FunctionFragment;
        "batchSwap(uint8,(bytes32,uint256,uint256,uint256,bytes)[],address[],(address,bool,address,bool),int256[],uint256,uint256,(uint256,uint256)[])": FunctionFragment;
        "exitPool(bytes32,uint8,address,address,(address[],uint256[],bytes,bool),(uint256,uint256)[])": FunctionFragment;
        "gaugeClaimRewards(address[])": FunctionFragment;
        "gaugeDeposit(address,address,address,uint256)": FunctionFragment;
        "gaugeMint(address[],uint256)": FunctionFragment;
        "gaugeSetMinterApproval(bool,address,uint256,uint8,bytes32,bytes32)": FunctionFragment;
        "gaugeWithdraw(address,address,address,uint256)": FunctionFragment;
        "getEntrypoint()": FunctionFragment;
        "getVault()": FunctionFragment;
        "joinPool(bytes32,uint8,address,address,(address[],uint256[],bytes,bool),uint256,uint256)": FunctionFragment;
        "manageUserBalance((uint8,address,uint256,address,address)[],uint256)": FunctionFragment;
        "peekChainedReferenceValue(uint256)": FunctionFragment;
        "setRelayerApproval(address,bool,bytes)": FunctionFragment;
        "stakeETH(address,uint256,uint256)": FunctionFragment;
        "stakeETHAndWrap(address,uint256,uint256)": FunctionFragment;
        "swap((bytes32,uint8,address,address,uint256,bytes),(address,bool,address,bool),uint256,uint256,uint256,uint256)": FunctionFragment;
        "unwrapAaveStaticToken(address,address,address,uint256,bool,uint256)": FunctionFragment;
        "unwrapCompoundV2(address,address,address,uint256,uint256)": FunctionFragment;
        "unwrapERC4626(address,address,address,uint256,uint256)": FunctionFragment;
        "unwrapEuler(address,address,address,uint256,uint256)": FunctionFragment;
        "unwrapGearbox(address,address,address,uint256,uint256)": FunctionFragment;
        "unwrapReaperVaultToken(address,address,address,uint256,uint256)": FunctionFragment;
        "unwrapShareToken(address,address,address,uint256,uint256)": FunctionFragment;
        "unwrapTetu(address,address,address,uint256,uint256)": FunctionFragment;
        "unwrapUnbuttonToken(address,address,address,uint256,uint256)": FunctionFragment;
        "unwrapWstETH(address,address,uint256,uint256)": FunctionFragment;
        "unwrapYearn(address,address,address,uint256,uint256)": FunctionFragment;
        "vaultPermit(address,address,uint256,uint256,uint8,bytes32,bytes32)": FunctionFragment;
        "vaultPermitDAI(address,address,uint256,uint256,bool,uint8,bytes32,bytes32)": FunctionFragment;
        "wrapAaveDynamicToken(address,address,address,uint256,bool,uint256)": FunctionFragment;
        "wrapCompoundV2(address,address,address,uint256,uint256)": FunctionFragment;
        "wrapERC4626(address,address,address,uint256,uint256)": FunctionFragment;
        "wrapEuler(address,address,address,address,uint256,uint256)": FunctionFragment;
        "wrapGearbox(address,address,address,uint256,uint256)": FunctionFragment;
        "wrapReaperVaultToken(address,address,address,uint256,uint256)": FunctionFragment;
        "wrapShareToken(address,address,address,uint256,uint256)": FunctionFragment;
        "wrapStETH(address,address,uint256,uint256)": FunctionFragment;
        "wrapTetu(address,address,address,uint256,uint256)": FunctionFragment;
        "wrapUnbuttonToken(address,address,address,uint256,uint256)": FunctionFragment;
        "wrapYearn(address,address,address,uint256,uint256)": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "approveVault" | "batchSwap" | "exitPool" | "gaugeClaimRewards" | "gaugeDeposit" | "gaugeMint" | "gaugeSetMinterApproval" | "gaugeWithdraw" | "getEntrypoint" | "getVault" | "joinPool" | "manageUserBalance" | "peekChainedReferenceValue" | "setRelayerApproval" | "stakeETH" | "stakeETHAndWrap" | "swap" | "unwrapAaveStaticToken" | "unwrapCompoundV2" | "unwrapERC4626" | "unwrapEuler" | "unwrapGearbox" | "unwrapReaperVaultToken" | "unwrapShareToken" | "unwrapTetu" | "unwrapUnbuttonToken" | "unwrapWstETH" | "unwrapYearn" | "vaultPermit" | "vaultPermitDAI" | "wrapAaveDynamicToken" | "wrapCompoundV2" | "wrapERC4626" | "wrapEuler" | "wrapGearbox" | "wrapReaperVaultToken" | "wrapShareToken" | "wrapStETH" | "wrapTetu" | "wrapUnbuttonToken" | "wrapYearn"): FunctionFragment;
    encodeFunctionData(functionFragment: "approveVault", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "batchSwap", values: [
        PromiseOrValue<BigNumberish$1>,
        IVault$2.BatchSwapStepStruct[],
        PromiseOrValue<string>[],
        IVault$2.FundManagementStruct,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        VaultActions.OutputReferenceStruct[]
    ]): string;
    encodeFunctionData(functionFragment: "exitPool", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        IVault$2.ExitPoolRequestStruct,
        VaultActions.OutputReferenceStruct[]
    ]): string;
    encodeFunctionData(functionFragment: "gaugeClaimRewards", values: [PromiseOrValue<string>[]]): string;
    encodeFunctionData(functionFragment: "gaugeDeposit", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "gaugeMint", values: [PromiseOrValue<string>[], PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "gaugeSetMinterApproval", values: [
        PromiseOrValue<boolean>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "gaugeWithdraw", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "getEntrypoint", values?: undefined): string;
    encodeFunctionData(functionFragment: "getVault", values?: undefined): string;
    encodeFunctionData(functionFragment: "joinPool", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        IVault$2.JoinPoolRequestStruct,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "manageUserBalance", values: [IVault$2.UserBalanceOpStruct[], PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "peekChainedReferenceValue", values: [PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "setRelayerApproval", values: [
        PromiseOrValue<string>,
        PromiseOrValue<boolean>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "stakeETH", values: [
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "stakeETHAndWrap", values: [
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "swap", values: [
        IVault$2.SingleSwapStruct,
        IVault$2.FundManagementStruct,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "unwrapAaveStaticToken", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<boolean>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "unwrapCompoundV2", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "unwrapERC4626", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "unwrapEuler", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "unwrapGearbox", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "unwrapReaperVaultToken", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "unwrapShareToken", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "unwrapTetu", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "unwrapUnbuttonToken", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "unwrapWstETH", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "unwrapYearn", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "vaultPermit", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "vaultPermitDAI", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<boolean>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "wrapAaveDynamicToken", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<boolean>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "wrapCompoundV2", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "wrapERC4626", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "wrapEuler", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "wrapGearbox", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "wrapReaperVaultToken", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "wrapShareToken", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "wrapStETH", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "wrapTetu", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "wrapUnbuttonToken", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "wrapYearn", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    decodeFunctionResult(functionFragment: "approveVault", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "batchSwap", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "exitPool", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "gaugeClaimRewards", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "gaugeDeposit", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "gaugeMint", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "gaugeSetMinterApproval", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "gaugeWithdraw", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getEntrypoint", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getVault", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "joinPool", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "manageUserBalance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "peekChainedReferenceValue", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setRelayerApproval", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "stakeETH", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "stakeETHAndWrap", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "swap", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "unwrapAaveStaticToken", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "unwrapCompoundV2", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "unwrapERC4626", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "unwrapEuler", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "unwrapGearbox", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "unwrapReaperVaultToken", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "unwrapShareToken", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "unwrapTetu", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "unwrapUnbuttonToken", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "unwrapWstETH", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "unwrapYearn", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "vaultPermit", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "vaultPermitDAI", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "wrapAaveDynamicToken", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "wrapCompoundV2", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "wrapERC4626", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "wrapEuler", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "wrapGearbox", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "wrapReaperVaultToken", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "wrapShareToken", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "wrapStETH", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "wrapTetu", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "wrapUnbuttonToken", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "wrapYearn", data: BytesLike): Result;
    events: {};
}
interface BatchRelayerLibrary extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: BatchRelayerLibraryInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        approveVault(token: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        batchSwap(kind: PromiseOrValue<BigNumberish$1>, swaps: IVault$2.BatchSwapStepStruct[], assets: PromiseOrValue<string>[], funds: IVault$2.FundManagementStruct, limits: PromiseOrValue<BigNumberish$1>[], deadline: PromiseOrValue<BigNumberish$1>, value: PromiseOrValue<BigNumberish$1>, outputReferences: VaultActions.OutputReferenceStruct[], overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        exitPool(poolId: PromiseOrValue<BytesLike>, kind: PromiseOrValue<BigNumberish$1>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, request: IVault$2.ExitPoolRequestStruct, outputReferences: VaultActions.OutputReferenceStruct[], overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        gaugeClaimRewards(gauges: PromiseOrValue<string>[], overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        gaugeDeposit(gauge: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        gaugeMint(gauges: PromiseOrValue<string>[], outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        gaugeSetMinterApproval(approval: PromiseOrValue<boolean>, user: PromiseOrValue<string>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        gaugeWithdraw(gauge: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        getEntrypoint(overrides?: CallOverrides): Promise<[string]>;
        getVault(overrides?: CallOverrides): Promise<[string]>;
        joinPool(poolId: PromiseOrValue<BytesLike>, kind: PromiseOrValue<BigNumberish$1>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, request: IVault$2.JoinPoolRequestStruct, value: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        manageUserBalance(ops: IVault$2.UserBalanceOpStruct[], value: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        peekChainedReferenceValue(ref: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<[BigNumber$1] & {
            value: BigNumber$1;
        }>;
        setRelayerApproval(relayer: PromiseOrValue<string>, approved: PromiseOrValue<boolean>, authorisation: PromiseOrValue<BytesLike>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        stakeETH(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        stakeETHAndWrap(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        swap(singleSwap: IVault$2.SingleSwapStruct, funds: IVault$2.FundManagementStruct, limit: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, value: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        unwrapAaveStaticToken(staticToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, toUnderlying: PromiseOrValue<boolean>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        unwrapCompoundV2(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        unwrapERC4626(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        unwrapEuler(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        unwrapGearbox(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, dieselAmount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        unwrapReaperVaultToken(vaultToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        unwrapShareToken(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        unwrapTetu(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        unwrapUnbuttonToken(wrapperToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        unwrapWstETH(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        unwrapYearn(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        vaultPermit(token: PromiseOrValue<string>, owner: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        vaultPermitDAI(token: PromiseOrValue<string>, holder: PromiseOrValue<string>, nonce: PromiseOrValue<BigNumberish$1>, expiry: PromiseOrValue<BigNumberish$1>, allowed: PromiseOrValue<boolean>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        wrapAaveDynamicToken(staticToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, fromUnderlying: PromiseOrValue<boolean>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        wrapCompoundV2(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        wrapERC4626(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        wrapEuler(wrappedToken: PromiseOrValue<string>, eulerProtocol: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        wrapGearbox(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, mainAmount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        wrapReaperVaultToken(vaultToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        wrapShareToken(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        wrapStETH(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        wrapTetu(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        wrapUnbuttonToken(wrapperToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, uAmount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        wrapYearn(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
    };
    approveVault(token: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    batchSwap(kind: PromiseOrValue<BigNumberish$1>, swaps: IVault$2.BatchSwapStepStruct[], assets: PromiseOrValue<string>[], funds: IVault$2.FundManagementStruct, limits: PromiseOrValue<BigNumberish$1>[], deadline: PromiseOrValue<BigNumberish$1>, value: PromiseOrValue<BigNumberish$1>, outputReferences: VaultActions.OutputReferenceStruct[], overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    exitPool(poolId: PromiseOrValue<BytesLike>, kind: PromiseOrValue<BigNumberish$1>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, request: IVault$2.ExitPoolRequestStruct, outputReferences: VaultActions.OutputReferenceStruct[], overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    gaugeClaimRewards(gauges: PromiseOrValue<string>[], overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    gaugeDeposit(gauge: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    gaugeMint(gauges: PromiseOrValue<string>[], outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    gaugeSetMinterApproval(approval: PromiseOrValue<boolean>, user: PromiseOrValue<string>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    gaugeWithdraw(gauge: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    getEntrypoint(overrides?: CallOverrides): Promise<string>;
    getVault(overrides?: CallOverrides): Promise<string>;
    joinPool(poolId: PromiseOrValue<BytesLike>, kind: PromiseOrValue<BigNumberish$1>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, request: IVault$2.JoinPoolRequestStruct, value: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    manageUserBalance(ops: IVault$2.UserBalanceOpStruct[], value: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    peekChainedReferenceValue(ref: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
    setRelayerApproval(relayer: PromiseOrValue<string>, approved: PromiseOrValue<boolean>, authorisation: PromiseOrValue<BytesLike>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    stakeETH(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    stakeETHAndWrap(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    swap(singleSwap: IVault$2.SingleSwapStruct, funds: IVault$2.FundManagementStruct, limit: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, value: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    unwrapAaveStaticToken(staticToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, toUnderlying: PromiseOrValue<boolean>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    unwrapCompoundV2(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    unwrapERC4626(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    unwrapEuler(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    unwrapGearbox(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, dieselAmount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    unwrapReaperVaultToken(vaultToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    unwrapShareToken(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    unwrapTetu(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    unwrapUnbuttonToken(wrapperToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    unwrapWstETH(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    unwrapYearn(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    vaultPermit(token: PromiseOrValue<string>, owner: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    vaultPermitDAI(token: PromiseOrValue<string>, holder: PromiseOrValue<string>, nonce: PromiseOrValue<BigNumberish$1>, expiry: PromiseOrValue<BigNumberish$1>, allowed: PromiseOrValue<boolean>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    wrapAaveDynamicToken(staticToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, fromUnderlying: PromiseOrValue<boolean>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    wrapCompoundV2(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    wrapERC4626(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    wrapEuler(wrappedToken: PromiseOrValue<string>, eulerProtocol: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    wrapGearbox(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, mainAmount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    wrapReaperVaultToken(vaultToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    wrapShareToken(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    wrapStETH(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    wrapTetu(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    wrapUnbuttonToken(wrapperToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, uAmount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    wrapYearn(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        approveVault(token: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        batchSwap(kind: PromiseOrValue<BigNumberish$1>, swaps: IVault$2.BatchSwapStepStruct[], assets: PromiseOrValue<string>[], funds: IVault$2.FundManagementStruct, limits: PromiseOrValue<BigNumberish$1>[], deadline: PromiseOrValue<BigNumberish$1>, value: PromiseOrValue<BigNumberish$1>, outputReferences: VaultActions.OutputReferenceStruct[], overrides?: CallOverrides): Promise<void>;
        exitPool(poolId: PromiseOrValue<BytesLike>, kind: PromiseOrValue<BigNumberish$1>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, request: IVault$2.ExitPoolRequestStruct, outputReferences: VaultActions.OutputReferenceStruct[], overrides?: CallOverrides): Promise<void>;
        gaugeClaimRewards(gauges: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<void>;
        gaugeDeposit(gauge: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        gaugeMint(gauges: PromiseOrValue<string>[], outputReference: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        gaugeSetMinterApproval(approval: PromiseOrValue<boolean>, user: PromiseOrValue<string>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<void>;
        gaugeWithdraw(gauge: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        getEntrypoint(overrides?: CallOverrides): Promise<string>;
        getVault(overrides?: CallOverrides): Promise<string>;
        joinPool(poolId: PromiseOrValue<BytesLike>, kind: PromiseOrValue<BigNumberish$1>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, request: IVault$2.JoinPoolRequestStruct, value: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        manageUserBalance(ops: IVault$2.UserBalanceOpStruct[], value: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        peekChainedReferenceValue(ref: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        setRelayerApproval(relayer: PromiseOrValue<string>, approved: PromiseOrValue<boolean>, authorisation: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<void>;
        stakeETH(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        stakeETHAndWrap(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        swap(singleSwap: IVault$2.SingleSwapStruct, funds: IVault$2.FundManagementStruct, limit: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, value: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        unwrapAaveStaticToken(staticToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, toUnderlying: PromiseOrValue<boolean>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        unwrapCompoundV2(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        unwrapERC4626(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        unwrapEuler(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        unwrapGearbox(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, dieselAmount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        unwrapReaperVaultToken(vaultToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        unwrapShareToken(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        unwrapTetu(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        unwrapUnbuttonToken(wrapperToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        unwrapWstETH(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        unwrapYearn(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        vaultPermit(token: PromiseOrValue<string>, owner: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<void>;
        vaultPermitDAI(token: PromiseOrValue<string>, holder: PromiseOrValue<string>, nonce: PromiseOrValue<BigNumberish$1>, expiry: PromiseOrValue<BigNumberish$1>, allowed: PromiseOrValue<boolean>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<void>;
        wrapAaveDynamicToken(staticToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, fromUnderlying: PromiseOrValue<boolean>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        wrapCompoundV2(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        wrapERC4626(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        wrapEuler(wrappedToken: PromiseOrValue<string>, eulerProtocol: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        wrapGearbox(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, mainAmount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        wrapReaperVaultToken(vaultToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        wrapShareToken(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        wrapStETH(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        wrapTetu(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        wrapUnbuttonToken(wrapperToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, uAmount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        wrapYearn(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
    };
    filters: {};
    estimateGas: {
        approveVault(token: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        batchSwap(kind: PromiseOrValue<BigNumberish$1>, swaps: IVault$2.BatchSwapStepStruct[], assets: PromiseOrValue<string>[], funds: IVault$2.FundManagementStruct, limits: PromiseOrValue<BigNumberish$1>[], deadline: PromiseOrValue<BigNumberish$1>, value: PromiseOrValue<BigNumberish$1>, outputReferences: VaultActions.OutputReferenceStruct[], overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        exitPool(poolId: PromiseOrValue<BytesLike>, kind: PromiseOrValue<BigNumberish$1>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, request: IVault$2.ExitPoolRequestStruct, outputReferences: VaultActions.OutputReferenceStruct[], overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        gaugeClaimRewards(gauges: PromiseOrValue<string>[], overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        gaugeDeposit(gauge: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        gaugeMint(gauges: PromiseOrValue<string>[], outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        gaugeSetMinterApproval(approval: PromiseOrValue<boolean>, user: PromiseOrValue<string>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        gaugeWithdraw(gauge: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        getEntrypoint(overrides?: CallOverrides): Promise<BigNumber$1>;
        getVault(overrides?: CallOverrides): Promise<BigNumber$1>;
        joinPool(poolId: PromiseOrValue<BytesLike>, kind: PromiseOrValue<BigNumberish$1>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, request: IVault$2.JoinPoolRequestStruct, value: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        manageUserBalance(ops: IVault$2.UserBalanceOpStruct[], value: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        peekChainedReferenceValue(ref: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        setRelayerApproval(relayer: PromiseOrValue<string>, approved: PromiseOrValue<boolean>, authorisation: PromiseOrValue<BytesLike>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        stakeETH(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        stakeETHAndWrap(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        swap(singleSwap: IVault$2.SingleSwapStruct, funds: IVault$2.FundManagementStruct, limit: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, value: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        unwrapAaveStaticToken(staticToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, toUnderlying: PromiseOrValue<boolean>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        unwrapCompoundV2(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        unwrapERC4626(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        unwrapEuler(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        unwrapGearbox(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, dieselAmount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        unwrapReaperVaultToken(vaultToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        unwrapShareToken(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        unwrapTetu(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        unwrapUnbuttonToken(wrapperToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        unwrapWstETH(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        unwrapYearn(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        vaultPermit(token: PromiseOrValue<string>, owner: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        vaultPermitDAI(token: PromiseOrValue<string>, holder: PromiseOrValue<string>, nonce: PromiseOrValue<BigNumberish$1>, expiry: PromiseOrValue<BigNumberish$1>, allowed: PromiseOrValue<boolean>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        wrapAaveDynamicToken(staticToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, fromUnderlying: PromiseOrValue<boolean>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        wrapCompoundV2(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        wrapERC4626(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        wrapEuler(wrappedToken: PromiseOrValue<string>, eulerProtocol: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        wrapGearbox(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, mainAmount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        wrapReaperVaultToken(vaultToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        wrapShareToken(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        wrapStETH(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        wrapTetu(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        wrapUnbuttonToken(wrapperToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, uAmount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        wrapYearn(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
    };
    populateTransaction: {
        approveVault(token: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        batchSwap(kind: PromiseOrValue<BigNumberish$1>, swaps: IVault$2.BatchSwapStepStruct[], assets: PromiseOrValue<string>[], funds: IVault$2.FundManagementStruct, limits: PromiseOrValue<BigNumberish$1>[], deadline: PromiseOrValue<BigNumberish$1>, value: PromiseOrValue<BigNumberish$1>, outputReferences: VaultActions.OutputReferenceStruct[], overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        exitPool(poolId: PromiseOrValue<BytesLike>, kind: PromiseOrValue<BigNumberish$1>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, request: IVault$2.ExitPoolRequestStruct, outputReferences: VaultActions.OutputReferenceStruct[], overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        gaugeClaimRewards(gauges: PromiseOrValue<string>[], overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        gaugeDeposit(gauge: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        gaugeMint(gauges: PromiseOrValue<string>[], outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        gaugeSetMinterApproval(approval: PromiseOrValue<boolean>, user: PromiseOrValue<string>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        gaugeWithdraw(gauge: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        getEntrypoint(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getVault(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        joinPool(poolId: PromiseOrValue<BytesLike>, kind: PromiseOrValue<BigNumberish$1>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, request: IVault$2.JoinPoolRequestStruct, value: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        manageUserBalance(ops: IVault$2.UserBalanceOpStruct[], value: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        peekChainedReferenceValue(ref: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        setRelayerApproval(relayer: PromiseOrValue<string>, approved: PromiseOrValue<boolean>, authorisation: PromiseOrValue<BytesLike>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        stakeETH(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        stakeETHAndWrap(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        swap(singleSwap: IVault$2.SingleSwapStruct, funds: IVault$2.FundManagementStruct, limit: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, value: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        unwrapAaveStaticToken(staticToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, toUnderlying: PromiseOrValue<boolean>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        unwrapCompoundV2(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        unwrapERC4626(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        unwrapEuler(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        unwrapGearbox(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, dieselAmount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        unwrapReaperVaultToken(vaultToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        unwrapShareToken(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        unwrapTetu(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        unwrapUnbuttonToken(wrapperToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        unwrapWstETH(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        unwrapYearn(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        vaultPermit(token: PromiseOrValue<string>, owner: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        vaultPermitDAI(token: PromiseOrValue<string>, holder: PromiseOrValue<string>, nonce: PromiseOrValue<BigNumberish$1>, expiry: PromiseOrValue<BigNumberish$1>, allowed: PromiseOrValue<boolean>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        wrapAaveDynamicToken(staticToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, fromUnderlying: PromiseOrValue<boolean>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        wrapCompoundV2(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        wrapERC4626(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        wrapEuler(wrappedToken: PromiseOrValue<string>, eulerProtocol: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        wrapGearbox(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, mainAmount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        wrapReaperVaultToken(vaultToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        wrapShareToken(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        wrapStETH(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        wrapTetu(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        wrapUnbuttonToken(wrapperToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, uAmount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        wrapYearn(wrappedToken: PromiseOrValue<string>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, outputReference: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
    };
}

declare namespace IPoolSwapStructs$a {
    type SwapRequestStruct = {
        kind: PromiseOrValue<BigNumberish$1>;
        tokenIn: PromiseOrValue<string>;
        tokenOut: PromiseOrValue<string>;
        amount: PromiseOrValue<BigNumberish$1>;
        poolId: PromiseOrValue<BytesLike>;
        lastChangeBlock: PromiseOrValue<BigNumberish$1>;
        from: PromiseOrValue<string>;
        to: PromiseOrValue<string>;
        userData: PromiseOrValue<BytesLike>;
    };
    type SwapRequestStructOutput = [
        number,
        string,
        string,
        BigNumber$1,
        string,
        BigNumber$1,
        string,
        string,
        string
    ] & {
        kind: number;
        tokenIn: string;
        tokenOut: string;
        amount: BigNumber$1;
        poolId: string;
        lastChangeBlock: BigNumber$1;
        from: string;
        to: string;
        userData: string;
    };
}
interface ComposableStablePoolInterface extends utils.Interface {
    functions: {
        "DELEGATE_PROTOCOL_SWAP_FEES_SENTINEL()": FunctionFragment;
        "DOMAIN_SEPARATOR()": FunctionFragment;
        "allowance(address,address)": FunctionFragment;
        "approve(address,uint256)": FunctionFragment;
        "balanceOf(address)": FunctionFragment;
        "decimals()": FunctionFragment;
        "decreaseAllowance(address,uint256)": FunctionFragment;
        "disableRecoveryMode()": FunctionFragment;
        "enableRecoveryMode()": FunctionFragment;
        "getActionId(bytes4)": FunctionFragment;
        "getActualSupply()": FunctionFragment;
        "getAmplificationParameter()": FunctionFragment;
        "getAuthorizer()": FunctionFragment;
        "getBptIndex()": FunctionFragment;
        "getDomainSeparator()": FunctionFragment;
        "getLastJoinExitData()": FunctionFragment;
        "getMinimumBpt()": FunctionFragment;
        "getNextNonce(address)": FunctionFragment;
        "getOwner()": FunctionFragment;
        "getPausedState()": FunctionFragment;
        "getPoolId()": FunctionFragment;
        "getProtocolFeePercentageCache(uint256)": FunctionFragment;
        "getProtocolFeesCollector()": FunctionFragment;
        "getProtocolSwapFeeDelegation()": FunctionFragment;
        "getRate()": FunctionFragment;
        "getRateProviders()": FunctionFragment;
        "getScalingFactors()": FunctionFragment;
        "getSwapFeePercentage()": FunctionFragment;
        "getTokenRate(address)": FunctionFragment;
        "getTokenRateCache(address)": FunctionFragment;
        "getVault()": FunctionFragment;
        "inRecoveryMode()": FunctionFragment;
        "increaseAllowance(address,uint256)": FunctionFragment;
        "isTokenExemptFromYieldProtocolFee(address)": FunctionFragment;
        "name()": FunctionFragment;
        "nonces(address)": FunctionFragment;
        "onExitPool(bytes32,address,address,uint256[],uint256,uint256,bytes)": FunctionFragment;
        "onJoinPool(bytes32,address,address,uint256[],uint256,uint256,bytes)": FunctionFragment;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)": FunctionFragment;
        "pause()": FunctionFragment;
        "permit(address,address,uint256,uint256,uint8,bytes32,bytes32)": FunctionFragment;
        "queryExit(bytes32,address,address,uint256[],uint256,uint256,bytes)": FunctionFragment;
        "queryJoin(bytes32,address,address,uint256[],uint256,uint256,bytes)": FunctionFragment;
        "setAssetManagerPoolConfig(address,bytes)": FunctionFragment;
        "setSwapFeePercentage(uint256)": FunctionFragment;
        "setTokenRateCacheDuration(address,uint256)": FunctionFragment;
        "startAmplificationParameterUpdate(uint256,uint256)": FunctionFragment;
        "stopAmplificationParameterUpdate()": FunctionFragment;
        "symbol()": FunctionFragment;
        "totalSupply()": FunctionFragment;
        "transfer(address,uint256)": FunctionFragment;
        "transferFrom(address,address,uint256)": FunctionFragment;
        "unpause()": FunctionFragment;
        "updateProtocolFeePercentageCache()": FunctionFragment;
        "updateTokenRateCache(address)": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "DELEGATE_PROTOCOL_SWAP_FEES_SENTINEL" | "DOMAIN_SEPARATOR" | "allowance" | "approve" | "balanceOf" | "decimals" | "decreaseAllowance" | "disableRecoveryMode" | "enableRecoveryMode" | "getActionId" | "getActualSupply" | "getAmplificationParameter" | "getAuthorizer" | "getBptIndex" | "getDomainSeparator" | "getLastJoinExitData" | "getMinimumBpt" | "getNextNonce" | "getOwner" | "getPausedState" | "getPoolId" | "getProtocolFeePercentageCache" | "getProtocolFeesCollector" | "getProtocolSwapFeeDelegation" | "getRate" | "getRateProviders" | "getScalingFactors" | "getSwapFeePercentage" | "getTokenRate" | "getTokenRateCache" | "getVault" | "inRecoveryMode" | "increaseAllowance" | "isTokenExemptFromYieldProtocolFee" | "name" | "nonces" | "onExitPool" | "onJoinPool" | "onSwap" | "pause" | "permit" | "queryExit" | "queryJoin" | "setAssetManagerPoolConfig" | "setSwapFeePercentage" | "setTokenRateCacheDuration" | "startAmplificationParameterUpdate" | "stopAmplificationParameterUpdate" | "symbol" | "totalSupply" | "transfer" | "transferFrom" | "unpause" | "updateProtocolFeePercentageCache" | "updateTokenRateCache"): FunctionFragment;
    encodeFunctionData(functionFragment: "DELEGATE_PROTOCOL_SWAP_FEES_SENTINEL", values?: undefined): string;
    encodeFunctionData(functionFragment: "DOMAIN_SEPARATOR", values?: undefined): string;
    encodeFunctionData(functionFragment: "allowance", values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "approve", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "balanceOf", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "decimals", values?: undefined): string;
    encodeFunctionData(functionFragment: "decreaseAllowance", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "disableRecoveryMode", values?: undefined): string;
    encodeFunctionData(functionFragment: "enableRecoveryMode", values?: undefined): string;
    encodeFunctionData(functionFragment: "getActionId", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "getActualSupply", values?: undefined): string;
    encodeFunctionData(functionFragment: "getAmplificationParameter", values?: undefined): string;
    encodeFunctionData(functionFragment: "getAuthorizer", values?: undefined): string;
    encodeFunctionData(functionFragment: "getBptIndex", values?: undefined): string;
    encodeFunctionData(functionFragment: "getDomainSeparator", values?: undefined): string;
    encodeFunctionData(functionFragment: "getLastJoinExitData", values?: undefined): string;
    encodeFunctionData(functionFragment: "getMinimumBpt", values?: undefined): string;
    encodeFunctionData(functionFragment: "getNextNonce", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "getOwner", values?: undefined): string;
    encodeFunctionData(functionFragment: "getPausedState", values?: undefined): string;
    encodeFunctionData(functionFragment: "getPoolId", values?: undefined): string;
    encodeFunctionData(functionFragment: "getProtocolFeePercentageCache", values: [PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "getProtocolFeesCollector", values?: undefined): string;
    encodeFunctionData(functionFragment: "getProtocolSwapFeeDelegation", values?: undefined): string;
    encodeFunctionData(functionFragment: "getRate", values?: undefined): string;
    encodeFunctionData(functionFragment: "getRateProviders", values?: undefined): string;
    encodeFunctionData(functionFragment: "getScalingFactors", values?: undefined): string;
    encodeFunctionData(functionFragment: "getSwapFeePercentage", values?: undefined): string;
    encodeFunctionData(functionFragment: "getTokenRate", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "getTokenRateCache", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "getVault", values?: undefined): string;
    encodeFunctionData(functionFragment: "inRecoveryMode", values?: undefined): string;
    encodeFunctionData(functionFragment: "increaseAllowance", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "isTokenExemptFromYieldProtocolFee", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "name", values?: undefined): string;
    encodeFunctionData(functionFragment: "nonces", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "onExitPool", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "onJoinPool", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "onSwap", values: [
        IPoolSwapStructs$a.SwapRequestStruct,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "pause", values?: undefined): string;
    encodeFunctionData(functionFragment: "permit", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "queryExit", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "queryJoin", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "setAssetManagerPoolConfig", values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "setSwapFeePercentage", values: [PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "setTokenRateCacheDuration", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "startAmplificationParameterUpdate", values: [PromiseOrValue<BigNumberish$1>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "stopAmplificationParameterUpdate", values?: undefined): string;
    encodeFunctionData(functionFragment: "symbol", values?: undefined): string;
    encodeFunctionData(functionFragment: "totalSupply", values?: undefined): string;
    encodeFunctionData(functionFragment: "transfer", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "transferFrom", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "unpause", values?: undefined): string;
    encodeFunctionData(functionFragment: "updateProtocolFeePercentageCache", values?: undefined): string;
    encodeFunctionData(functionFragment: "updateTokenRateCache", values: [PromiseOrValue<string>]): string;
    decodeFunctionResult(functionFragment: "DELEGATE_PROTOCOL_SWAP_FEES_SENTINEL", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "DOMAIN_SEPARATOR", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "allowance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "approve", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "balanceOf", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "decimals", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "decreaseAllowance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "disableRecoveryMode", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "enableRecoveryMode", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getActionId", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getActualSupply", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getAmplificationParameter", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getAuthorizer", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getBptIndex", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getDomainSeparator", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getLastJoinExitData", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getMinimumBpt", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getNextNonce", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getOwner", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getPausedState", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getPoolId", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getProtocolFeePercentageCache", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getProtocolFeesCollector", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getProtocolSwapFeeDelegation", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getRate", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getRateProviders", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getScalingFactors", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getSwapFeePercentage", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getTokenRate", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getTokenRateCache", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getVault", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "inRecoveryMode", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "increaseAllowance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isTokenExemptFromYieldProtocolFee", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "name", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "nonces", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "onExitPool", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "onJoinPool", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "onSwap", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "pause", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "permit", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "queryExit", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "queryJoin", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setAssetManagerPoolConfig", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setSwapFeePercentage", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setTokenRateCacheDuration", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "startAmplificationParameterUpdate", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "stopAmplificationParameterUpdate", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "symbol", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "totalSupply", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "transfer", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "transferFrom", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "unpause", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "updateProtocolFeePercentageCache", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "updateTokenRateCache", data: BytesLike): Result;
    events: {
        "AmpUpdateStarted(uint256,uint256,uint256,uint256)": EventFragment;
        "AmpUpdateStopped(uint256)": EventFragment;
        "Approval(address,address,uint256)": EventFragment;
        "PausedStateChanged(bool)": EventFragment;
        "ProtocolFeePercentageCacheUpdated(uint256,uint256)": EventFragment;
        "RecoveryModeStateChanged(bool)": EventFragment;
        "SwapFeePercentageChanged(uint256)": EventFragment;
        "TokenRateCacheUpdated(uint256,uint256)": EventFragment;
        "TokenRateProviderSet(uint256,address,uint256)": EventFragment;
        "Transfer(address,address,uint256)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "AmpUpdateStarted"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "AmpUpdateStopped"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Approval"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "PausedStateChanged"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "ProtocolFeePercentageCacheUpdated"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "RecoveryModeStateChanged"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "SwapFeePercentageChanged"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "TokenRateCacheUpdated"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "TokenRateProviderSet"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Transfer"): EventFragment;
}
interface AmpUpdateStartedEventObject$1 {
    startValue: BigNumber$1;
    endValue: BigNumber$1;
    startTime: BigNumber$1;
    endTime: BigNumber$1;
}
type AmpUpdateStartedEvent$1 = TypedEvent<[
    BigNumber$1,
    BigNumber$1,
    BigNumber$1,
    BigNumber$1
], AmpUpdateStartedEventObject$1>;
type AmpUpdateStartedEventFilter$1 = TypedEventFilter<AmpUpdateStartedEvent$1>;
interface AmpUpdateStoppedEventObject$1 {
    currentValue: BigNumber$1;
}
type AmpUpdateStoppedEvent$1 = TypedEvent<[
    BigNumber$1
], AmpUpdateStoppedEventObject$1>;
type AmpUpdateStoppedEventFilter$1 = TypedEventFilter<AmpUpdateStoppedEvent$1>;
interface ApprovalEventObject$c {
    owner: string;
    spender: string;
    value: BigNumber$1;
}
type ApprovalEvent$c = TypedEvent<[
    string,
    string,
    BigNumber$1
], ApprovalEventObject$c>;
type ApprovalEventFilter$c = TypedEventFilter<ApprovalEvent$c>;
interface PausedStateChangedEventObject$9 {
    paused: boolean;
}
type PausedStateChangedEvent$9 = TypedEvent<[
    boolean
], PausedStateChangedEventObject$9>;
type PausedStateChangedEventFilter$9 = TypedEventFilter<PausedStateChangedEvent$9>;
interface ProtocolFeePercentageCacheUpdatedEventObject$1 {
    feeType: BigNumber$1;
    protocolFeePercentage: BigNumber$1;
}
type ProtocolFeePercentageCacheUpdatedEvent$1 = TypedEvent<[
    BigNumber$1,
    BigNumber$1
], ProtocolFeePercentageCacheUpdatedEventObject$1>;
type ProtocolFeePercentageCacheUpdatedEventFilter$1 = TypedEventFilter<ProtocolFeePercentageCacheUpdatedEvent$1>;
interface RecoveryModeStateChangedEventObject$5 {
    enabled: boolean;
}
type RecoveryModeStateChangedEvent$5 = TypedEvent<[
    boolean
], RecoveryModeStateChangedEventObject$5>;
type RecoveryModeStateChangedEventFilter$5 = TypedEventFilter<RecoveryModeStateChangedEvent$5>;
interface SwapFeePercentageChangedEventObject$8 {
    swapFeePercentage: BigNumber$1;
}
type SwapFeePercentageChangedEvent$8 = TypedEvent<[
    BigNumber$1
], SwapFeePercentageChangedEventObject$8>;
type SwapFeePercentageChangedEventFilter$8 = TypedEventFilter<SwapFeePercentageChangedEvent$8>;
interface TokenRateCacheUpdatedEventObject {
    tokenIndex: BigNumber$1;
    rate: BigNumber$1;
}
type TokenRateCacheUpdatedEvent = TypedEvent<[
    BigNumber$1,
    BigNumber$1
], TokenRateCacheUpdatedEventObject>;
type TokenRateCacheUpdatedEventFilter = TypedEventFilter<TokenRateCacheUpdatedEvent>;
interface TokenRateProviderSetEventObject {
    tokenIndex: BigNumber$1;
    provider: string;
    cacheDuration: BigNumber$1;
}
type TokenRateProviderSetEvent = TypedEvent<[
    BigNumber$1,
    string,
    BigNumber$1
], TokenRateProviderSetEventObject>;
type TokenRateProviderSetEventFilter = TypedEventFilter<TokenRateProviderSetEvent>;
interface TransferEventObject$c {
    from: string;
    to: string;
    value: BigNumber$1;
}
type TransferEvent$c = TypedEvent<[
    string,
    string,
    BigNumber$1
], TransferEventObject$c>;
type TransferEventFilter$c = TypedEventFilter<TransferEvent$c>;
declare namespace ComposableStablePool {
    type NewPoolParamsStruct = {
        vault: PromiseOrValue<string>;
        protocolFeeProvider: PromiseOrValue<string>;
        name: PromiseOrValue<string>;
        symbol: PromiseOrValue<string>;
        tokens: PromiseOrValue<string>[];
        rateProviders: PromiseOrValue<string>[];
        tokenRateCacheDurations: PromiseOrValue<BigNumberish$1>[];
        exemptFromYieldProtocolFeeFlags: PromiseOrValue<boolean>[];
        amplificationParameter: PromiseOrValue<BigNumberish$1>;
        swapFeePercentage: PromiseOrValue<BigNumberish$1>;
        pauseWindowDuration: PromiseOrValue<BigNumberish$1>;
        bufferPeriodDuration: PromiseOrValue<BigNumberish$1>;
        owner: PromiseOrValue<string>;
    };
    type NewPoolParamsStructOutput = [
        string,
        string,
        string,
        string,
        string[],
        string[],
        BigNumber$1[],
        boolean[],
        BigNumber$1,
        BigNumber$1,
        BigNumber$1,
        BigNumber$1,
        string
    ] & {
        vault: string;
        protocolFeeProvider: string;
        name: string;
        symbol: string;
        tokens: string[];
        rateProviders: string[];
        tokenRateCacheDurations: BigNumber$1[];
        exemptFromYieldProtocolFeeFlags: boolean[];
        amplificationParameter: BigNumber$1;
        swapFeePercentage: BigNumber$1;
        pauseWindowDuration: BigNumber$1;
        bufferPeriodDuration: BigNumber$1;
        owner: string;
    };
}
interface ComposableStablePool extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: ComposableStablePoolInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        DELEGATE_PROTOCOL_SWAP_FEES_SENTINEL(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<[string]>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        decimals(overrides?: CallOverrides): Promise<[number]>;
        decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        disableRecoveryMode(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        enableRecoveryMode(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[string]>;
        getActualSupply(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getAmplificationParameter(overrides?: CallOverrides): Promise<[
            BigNumber$1,
            boolean,
            BigNumber$1
        ] & {
            value: BigNumber$1;
            isUpdating: boolean;
            precision: BigNumber$1;
        }>;
        getAuthorizer(overrides?: CallOverrides): Promise<[string]>;
        getBptIndex(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getDomainSeparator(overrides?: CallOverrides): Promise<[string]>;
        getLastJoinExitData(overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1
        ] & {
            lastJoinExitAmplification: BigNumber$1;
            lastPostJoinExitInvariant: BigNumber$1;
        }>;
        getMinimumBpt(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getNextNonce(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getOwner(overrides?: CallOverrides): Promise<[string]>;
        getPausedState(overrides?: CallOverrides): Promise<[
            boolean,
            BigNumber$1,
            BigNumber$1
        ] & {
            paused: boolean;
            pauseWindowEndTime: BigNumber$1;
            bufferPeriodEndTime: BigNumber$1;
        }>;
        getPoolId(overrides?: CallOverrides): Promise<[string]>;
        getProtocolFeePercentageCache(feeType: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getProtocolFeesCollector(overrides?: CallOverrides): Promise<[string]>;
        getProtocolSwapFeeDelegation(overrides?: CallOverrides): Promise<[boolean]>;
        getRate(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getRateProviders(overrides?: CallOverrides): Promise<[string[]]>;
        getScalingFactors(overrides?: CallOverrides): Promise<[BigNumber$1[]]>;
        getSwapFeePercentage(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getTokenRate(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getTokenRateCache(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1,
            BigNumber$1,
            BigNumber$1
        ] & {
            rate: BigNumber$1;
            oldRate: BigNumber$1;
            duration: BigNumber$1;
            expires: BigNumber$1;
        }>;
        getVault(overrides?: CallOverrides): Promise<[string]>;
        inRecoveryMode(overrides?: CallOverrides): Promise<[boolean]>;
        increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        isTokenExemptFromYieldProtocolFee(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;
        name(overrides?: CallOverrides): Promise<[string]>;
        nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        onJoinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        onSwap(swapRequest: IPoolSwapStructs$a.SwapRequestStruct, balances: PromiseOrValue<BigNumberish$1>[], indexIn: PromiseOrValue<BigNumberish$1>, indexOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        pause(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        queryExit(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        queryJoin(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setAssetManagerPoolConfig(token: PromiseOrValue<string>, poolConfig: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setSwapFeePercentage(swapFeePercentage: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setTokenRateCacheDuration(token: PromiseOrValue<string>, duration: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        startAmplificationParameterUpdate(rawEndValue: PromiseOrValue<BigNumberish$1>, endTime: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        stopAmplificationParameterUpdate(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        symbol(overrides?: CallOverrides): Promise<[string]>;
        totalSupply(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        unpause(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        updateProtocolFeePercentageCache(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        updateTokenRateCache(token: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
    };
    DELEGATE_PROTOCOL_SWAP_FEES_SENTINEL(overrides?: CallOverrides): Promise<BigNumber$1>;
    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;
    allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    decimals(overrides?: CallOverrides): Promise<number>;
    decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    disableRecoveryMode(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    enableRecoveryMode(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
    getActualSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
    getAmplificationParameter(overrides?: CallOverrides): Promise<[
        BigNumber$1,
        boolean,
        BigNumber$1
    ] & {
        value: BigNumber$1;
        isUpdating: boolean;
        precision: BigNumber$1;
    }>;
    getAuthorizer(overrides?: CallOverrides): Promise<string>;
    getBptIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
    getDomainSeparator(overrides?: CallOverrides): Promise<string>;
    getLastJoinExitData(overrides?: CallOverrides): Promise<[
        BigNumber$1,
        BigNumber$1
    ] & {
        lastJoinExitAmplification: BigNumber$1;
        lastPostJoinExitInvariant: BigNumber$1;
    }>;
    getMinimumBpt(overrides?: CallOverrides): Promise<BigNumber$1>;
    getNextNonce(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    getOwner(overrides?: CallOverrides): Promise<string>;
    getPausedState(overrides?: CallOverrides): Promise<[
        boolean,
        BigNumber$1,
        BigNumber$1
    ] & {
        paused: boolean;
        pauseWindowEndTime: BigNumber$1;
        bufferPeriodEndTime: BigNumber$1;
    }>;
    getPoolId(overrides?: CallOverrides): Promise<string>;
    getProtocolFeePercentageCache(feeType: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
    getProtocolFeesCollector(overrides?: CallOverrides): Promise<string>;
    getProtocolSwapFeeDelegation(overrides?: CallOverrides): Promise<boolean>;
    getRate(overrides?: CallOverrides): Promise<BigNumber$1>;
    getRateProviders(overrides?: CallOverrides): Promise<string[]>;
    getScalingFactors(overrides?: CallOverrides): Promise<BigNumber$1[]>;
    getSwapFeePercentage(overrides?: CallOverrides): Promise<BigNumber$1>;
    getTokenRate(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    getTokenRateCache(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[
        BigNumber$1,
        BigNumber$1,
        BigNumber$1,
        BigNumber$1
    ] & {
        rate: BigNumber$1;
        oldRate: BigNumber$1;
        duration: BigNumber$1;
        expires: BigNumber$1;
    }>;
    getVault(overrides?: CallOverrides): Promise<string>;
    inRecoveryMode(overrides?: CallOverrides): Promise<boolean>;
    increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    isTokenExemptFromYieldProtocolFee(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
    name(overrides?: CallOverrides): Promise<string>;
    nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    onJoinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    onSwap(swapRequest: IPoolSwapStructs$a.SwapRequestStruct, balances: PromiseOrValue<BigNumberish$1>[], indexIn: PromiseOrValue<BigNumberish$1>, indexOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    pause(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    queryExit(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    queryJoin(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setAssetManagerPoolConfig(token: PromiseOrValue<string>, poolConfig: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setSwapFeePercentage(swapFeePercentage: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setTokenRateCacheDuration(token: PromiseOrValue<string>, duration: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    startAmplificationParameterUpdate(rawEndValue: PromiseOrValue<BigNumberish$1>, endTime: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    stopAmplificationParameterUpdate(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    symbol(overrides?: CallOverrides): Promise<string>;
    totalSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
    transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    unpause(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    updateProtocolFeePercentageCache(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    updateTokenRateCache(token: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        DELEGATE_PROTOCOL_SWAP_FEES_SENTINEL(overrides?: CallOverrides): Promise<BigNumber$1>;
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        decimals(overrides?: CallOverrides): Promise<number>;
        decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        disableRecoveryMode(overrides?: CallOverrides): Promise<void>;
        enableRecoveryMode(overrides?: CallOverrides): Promise<void>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
        getActualSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
        getAmplificationParameter(overrides?: CallOverrides): Promise<[
            BigNumber$1,
            boolean,
            BigNumber$1
        ] & {
            value: BigNumber$1;
            isUpdating: boolean;
            precision: BigNumber$1;
        }>;
        getAuthorizer(overrides?: CallOverrides): Promise<string>;
        getBptIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
        getDomainSeparator(overrides?: CallOverrides): Promise<string>;
        getLastJoinExitData(overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1
        ] & {
            lastJoinExitAmplification: BigNumber$1;
            lastPostJoinExitInvariant: BigNumber$1;
        }>;
        getMinimumBpt(overrides?: CallOverrides): Promise<BigNumber$1>;
        getNextNonce(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getOwner(overrides?: CallOverrides): Promise<string>;
        getPausedState(overrides?: CallOverrides): Promise<[
            boolean,
            BigNumber$1,
            BigNumber$1
        ] & {
            paused: boolean;
            pauseWindowEndTime: BigNumber$1;
            bufferPeriodEndTime: BigNumber$1;
        }>;
        getPoolId(overrides?: CallOverrides): Promise<string>;
        getProtocolFeePercentageCache(feeType: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getProtocolFeesCollector(overrides?: CallOverrides): Promise<string>;
        getProtocolSwapFeeDelegation(overrides?: CallOverrides): Promise<boolean>;
        getRate(overrides?: CallOverrides): Promise<BigNumber$1>;
        getRateProviders(overrides?: CallOverrides): Promise<string[]>;
        getScalingFactors(overrides?: CallOverrides): Promise<BigNumber$1[]>;
        getSwapFeePercentage(overrides?: CallOverrides): Promise<BigNumber$1>;
        getTokenRate(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getTokenRateCache(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1,
            BigNumber$1,
            BigNumber$1
        ] & {
            rate: BigNumber$1;
            oldRate: BigNumber$1;
            duration: BigNumber$1;
            expires: BigNumber$1;
        }>;
        getVault(overrides?: CallOverrides): Promise<string>;
        inRecoveryMode(overrides?: CallOverrides): Promise<boolean>;
        increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        isTokenExemptFromYieldProtocolFee(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
        name(overrides?: CallOverrides): Promise<string>;
        nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[BigNumber$1[], BigNumber$1[]]>;
        onJoinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[BigNumber$1[], BigNumber$1[]]>;
        onSwap(swapRequest: IPoolSwapStructs$a.SwapRequestStruct, balances: PromiseOrValue<BigNumberish$1>[], indexIn: PromiseOrValue<BigNumberish$1>, indexOut: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        pause(overrides?: CallOverrides): Promise<void>;
        permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<void>;
        queryExit(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1[]
        ] & {
            bptIn: BigNumber$1;
            amountsOut: BigNumber$1[];
        }>;
        queryJoin(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1[]
        ] & {
            bptOut: BigNumber$1;
            amountsIn: BigNumber$1[];
        }>;
        setAssetManagerPoolConfig(token: PromiseOrValue<string>, poolConfig: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<void>;
        setSwapFeePercentage(swapFeePercentage: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        setTokenRateCacheDuration(token: PromiseOrValue<string>, duration: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        startAmplificationParameterUpdate(rawEndValue: PromiseOrValue<BigNumberish$1>, endTime: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        stopAmplificationParameterUpdate(overrides?: CallOverrides): Promise<void>;
        symbol(overrides?: CallOverrides): Promise<string>;
        totalSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
        transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        unpause(overrides?: CallOverrides): Promise<void>;
        updateProtocolFeePercentageCache(overrides?: CallOverrides): Promise<void>;
        updateTokenRateCache(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
    };
    filters: {
        "AmpUpdateStarted(uint256,uint256,uint256,uint256)"(startValue?: null, endValue?: null, startTime?: null, endTime?: null): AmpUpdateStartedEventFilter$1;
        AmpUpdateStarted(startValue?: null, endValue?: null, startTime?: null, endTime?: null): AmpUpdateStartedEventFilter$1;
        "AmpUpdateStopped(uint256)"(currentValue?: null): AmpUpdateStoppedEventFilter$1;
        AmpUpdateStopped(currentValue?: null): AmpUpdateStoppedEventFilter$1;
        "Approval(address,address,uint256)"(owner?: PromiseOrValue<string> | null, spender?: PromiseOrValue<string> | null, value?: null): ApprovalEventFilter$c;
        Approval(owner?: PromiseOrValue<string> | null, spender?: PromiseOrValue<string> | null, value?: null): ApprovalEventFilter$c;
        "PausedStateChanged(bool)"(paused?: null): PausedStateChangedEventFilter$9;
        PausedStateChanged(paused?: null): PausedStateChangedEventFilter$9;
        "ProtocolFeePercentageCacheUpdated(uint256,uint256)"(feeType?: PromiseOrValue<BigNumberish$1> | null, protocolFeePercentage?: null): ProtocolFeePercentageCacheUpdatedEventFilter$1;
        ProtocolFeePercentageCacheUpdated(feeType?: PromiseOrValue<BigNumberish$1> | null, protocolFeePercentage?: null): ProtocolFeePercentageCacheUpdatedEventFilter$1;
        "RecoveryModeStateChanged(bool)"(enabled?: null): RecoveryModeStateChangedEventFilter$5;
        RecoveryModeStateChanged(enabled?: null): RecoveryModeStateChangedEventFilter$5;
        "SwapFeePercentageChanged(uint256)"(swapFeePercentage?: null): SwapFeePercentageChangedEventFilter$8;
        SwapFeePercentageChanged(swapFeePercentage?: null): SwapFeePercentageChangedEventFilter$8;
        "TokenRateCacheUpdated(uint256,uint256)"(tokenIndex?: PromiseOrValue<BigNumberish$1> | null, rate?: null): TokenRateCacheUpdatedEventFilter;
        TokenRateCacheUpdated(tokenIndex?: PromiseOrValue<BigNumberish$1> | null, rate?: null): TokenRateCacheUpdatedEventFilter;
        "TokenRateProviderSet(uint256,address,uint256)"(tokenIndex?: PromiseOrValue<BigNumberish$1> | null, provider?: PromiseOrValue<string> | null, cacheDuration?: null): TokenRateProviderSetEventFilter;
        TokenRateProviderSet(tokenIndex?: PromiseOrValue<BigNumberish$1> | null, provider?: PromiseOrValue<string> | null, cacheDuration?: null): TokenRateProviderSetEventFilter;
        "Transfer(address,address,uint256)"(from?: PromiseOrValue<string> | null, to?: PromiseOrValue<string> | null, value?: null): TransferEventFilter$c;
        Transfer(from?: PromiseOrValue<string> | null, to?: PromiseOrValue<string> | null, value?: null): TransferEventFilter$c;
    };
    estimateGas: {
        DELEGATE_PROTOCOL_SWAP_FEES_SENTINEL(overrides?: CallOverrides): Promise<BigNumber$1>;
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<BigNumber$1>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        decimals(overrides?: CallOverrides): Promise<BigNumber$1>;
        decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        disableRecoveryMode(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        enableRecoveryMode(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getActualSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
        getAmplificationParameter(overrides?: CallOverrides): Promise<BigNumber$1>;
        getAuthorizer(overrides?: CallOverrides): Promise<BigNumber$1>;
        getBptIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
        getDomainSeparator(overrides?: CallOverrides): Promise<BigNumber$1>;
        getLastJoinExitData(overrides?: CallOverrides): Promise<BigNumber$1>;
        getMinimumBpt(overrides?: CallOverrides): Promise<BigNumber$1>;
        getNextNonce(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getOwner(overrides?: CallOverrides): Promise<BigNumber$1>;
        getPausedState(overrides?: CallOverrides): Promise<BigNumber$1>;
        getPoolId(overrides?: CallOverrides): Promise<BigNumber$1>;
        getProtocolFeePercentageCache(feeType: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getProtocolFeesCollector(overrides?: CallOverrides): Promise<BigNumber$1>;
        getProtocolSwapFeeDelegation(overrides?: CallOverrides): Promise<BigNumber$1>;
        getRate(overrides?: CallOverrides): Promise<BigNumber$1>;
        getRateProviders(overrides?: CallOverrides): Promise<BigNumber$1>;
        getScalingFactors(overrides?: CallOverrides): Promise<BigNumber$1>;
        getSwapFeePercentage(overrides?: CallOverrides): Promise<BigNumber$1>;
        getTokenRate(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getTokenRateCache(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getVault(overrides?: CallOverrides): Promise<BigNumber$1>;
        inRecoveryMode(overrides?: CallOverrides): Promise<BigNumber$1>;
        increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        isTokenExemptFromYieldProtocolFee(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        name(overrides?: CallOverrides): Promise<BigNumber$1>;
        nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        onJoinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        onSwap(swapRequest: IPoolSwapStructs$a.SwapRequestStruct, balances: PromiseOrValue<BigNumberish$1>[], indexIn: PromiseOrValue<BigNumberish$1>, indexOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        pause(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        queryExit(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        queryJoin(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        setAssetManagerPoolConfig(token: PromiseOrValue<string>, poolConfig: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        setSwapFeePercentage(swapFeePercentage: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        setTokenRateCacheDuration(token: PromiseOrValue<string>, duration: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        startAmplificationParameterUpdate(rawEndValue: PromiseOrValue<BigNumberish$1>, endTime: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        stopAmplificationParameterUpdate(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        symbol(overrides?: CallOverrides): Promise<BigNumber$1>;
        totalSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
        transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        unpause(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        updateProtocolFeePercentageCache(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        updateTokenRateCache(token: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
    };
    populateTransaction: {
        DELEGATE_PROTOCOL_SWAP_FEES_SENTINEL(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        decimals(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        disableRecoveryMode(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        enableRecoveryMode(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getActualSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getAmplificationParameter(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getAuthorizer(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getBptIndex(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getDomainSeparator(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getLastJoinExitData(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getMinimumBpt(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getNextNonce(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getOwner(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getPausedState(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getPoolId(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getProtocolFeePercentageCache(feeType: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getProtocolFeesCollector(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getProtocolSwapFeeDelegation(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getRate(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getRateProviders(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getScalingFactors(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getSwapFeePercentage(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getTokenRate(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getTokenRateCache(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getVault(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        inRecoveryMode(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        isTokenExemptFromYieldProtocolFee(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        name(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        onJoinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        onSwap(swapRequest: IPoolSwapStructs$a.SwapRequestStruct, balances: PromiseOrValue<BigNumberish$1>[], indexIn: PromiseOrValue<BigNumberish$1>, indexOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        pause(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        queryExit(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        queryJoin(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setAssetManagerPoolConfig(token: PromiseOrValue<string>, poolConfig: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setSwapFeePercentage(swapFeePercentage: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setTokenRateCacheDuration(token: PromiseOrValue<string>, duration: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        startAmplificationParameterUpdate(rawEndValue: PromiseOrValue<BigNumberish$1>, endTime: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        stopAmplificationParameterUpdate(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        symbol(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        totalSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        unpause(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        updateProtocolFeePercentageCache(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        updateTokenRateCache(token: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
    };
}

interface ComposableStablePoolFactoryInterface extends utils.Interface {
    functions: {
        "create(string,string,address[],uint256,address[],uint256[],bool[],uint256,address,bytes32)": FunctionFragment;
        "disable()": FunctionFragment;
        "getActionId(bytes4)": FunctionFragment;
        "getAuthorizer()": FunctionFragment;
        "getCreationCode()": FunctionFragment;
        "getCreationCodeContracts()": FunctionFragment;
        "getPauseConfiguration()": FunctionFragment;
        "getPoolVersion()": FunctionFragment;
        "getProtocolFeePercentagesProvider()": FunctionFragment;
        "getVault()": FunctionFragment;
        "isDisabled()": FunctionFragment;
        "isPoolFromFactory(address)": FunctionFragment;
        "version()": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "create" | "disable" | "getActionId" | "getAuthorizer" | "getCreationCode" | "getCreationCodeContracts" | "getPauseConfiguration" | "getPoolVersion" | "getProtocolFeePercentagesProvider" | "getVault" | "isDisabled" | "isPoolFromFactory" | "version"): FunctionFragment;
    encodeFunctionData(functionFragment: "create", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<string>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<string>[],
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<boolean>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<string>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "disable", values?: undefined): string;
    encodeFunctionData(functionFragment: "getActionId", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "getAuthorizer", values?: undefined): string;
    encodeFunctionData(functionFragment: "getCreationCode", values?: undefined): string;
    encodeFunctionData(functionFragment: "getCreationCodeContracts", values?: undefined): string;
    encodeFunctionData(functionFragment: "getPauseConfiguration", values?: undefined): string;
    encodeFunctionData(functionFragment: "getPoolVersion", values?: undefined): string;
    encodeFunctionData(functionFragment: "getProtocolFeePercentagesProvider", values?: undefined): string;
    encodeFunctionData(functionFragment: "getVault", values?: undefined): string;
    encodeFunctionData(functionFragment: "isDisabled", values?: undefined): string;
    encodeFunctionData(functionFragment: "isPoolFromFactory", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "version", values?: undefined): string;
    decodeFunctionResult(functionFragment: "create", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "disable", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getActionId", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getAuthorizer", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getCreationCode", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getCreationCodeContracts", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getPauseConfiguration", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getPoolVersion", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getProtocolFeePercentagesProvider", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getVault", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isDisabled", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isPoolFromFactory", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "version", data: BytesLike): Result;
    events: {
        "FactoryDisabled()": EventFragment;
        "PoolCreated(address)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "FactoryDisabled"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "PoolCreated"): EventFragment;
}
interface FactoryDisabledEventObject$5 {
}
type FactoryDisabledEvent$5 = TypedEvent<[], FactoryDisabledEventObject$5>;
type FactoryDisabledEventFilter$5 = TypedEventFilter<FactoryDisabledEvent$5>;
interface PoolCreatedEventObject$5 {
    pool: string;
}
type PoolCreatedEvent$5 = TypedEvent<[string], PoolCreatedEventObject$5>;
type PoolCreatedEventFilter$5 = TypedEventFilter<PoolCreatedEvent$5>;
interface ComposableStablePoolFactory extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: ComposableStablePoolFactoryInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        create(name: PromiseOrValue<string>, symbol: PromiseOrValue<string>, tokens: PromiseOrValue<string>[], amplificationParameter: PromiseOrValue<BigNumberish$1>, rateProviders: PromiseOrValue<string>[], tokenRateCacheDurations: PromiseOrValue<BigNumberish$1>[], exemptFromYieldProtocolFeeFlags: PromiseOrValue<boolean>[], swapFeePercentage: PromiseOrValue<BigNumberish$1>, owner: PromiseOrValue<string>, salt: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        disable(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[string]>;
        getAuthorizer(overrides?: CallOverrides): Promise<[string]>;
        getCreationCode(overrides?: CallOverrides): Promise<[string]>;
        getCreationCodeContracts(overrides?: CallOverrides): Promise<[string, string] & {
            contractA: string;
            contractB: string;
        }>;
        getPauseConfiguration(overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1
        ] & {
            pauseWindowDuration: BigNumber$1;
            bufferPeriodDuration: BigNumber$1;
        }>;
        getPoolVersion(overrides?: CallOverrides): Promise<[string]>;
        getProtocolFeePercentagesProvider(overrides?: CallOverrides): Promise<[string]>;
        getVault(overrides?: CallOverrides): Promise<[string]>;
        isDisabled(overrides?: CallOverrides): Promise<[boolean]>;
        isPoolFromFactory(pool: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;
        version(overrides?: CallOverrides): Promise<[string]>;
    };
    create(name: PromiseOrValue<string>, symbol: PromiseOrValue<string>, tokens: PromiseOrValue<string>[], amplificationParameter: PromiseOrValue<BigNumberish$1>, rateProviders: PromiseOrValue<string>[], tokenRateCacheDurations: PromiseOrValue<BigNumberish$1>[], exemptFromYieldProtocolFeeFlags: PromiseOrValue<boolean>[], swapFeePercentage: PromiseOrValue<BigNumberish$1>, owner: PromiseOrValue<string>, salt: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    disable(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
    getAuthorizer(overrides?: CallOverrides): Promise<string>;
    getCreationCode(overrides?: CallOverrides): Promise<string>;
    getCreationCodeContracts(overrides?: CallOverrides): Promise<[string, string] & {
        contractA: string;
        contractB: string;
    }>;
    getPauseConfiguration(overrides?: CallOverrides): Promise<[
        BigNumber$1,
        BigNumber$1
    ] & {
        pauseWindowDuration: BigNumber$1;
        bufferPeriodDuration: BigNumber$1;
    }>;
    getPoolVersion(overrides?: CallOverrides): Promise<string>;
    getProtocolFeePercentagesProvider(overrides?: CallOverrides): Promise<string>;
    getVault(overrides?: CallOverrides): Promise<string>;
    isDisabled(overrides?: CallOverrides): Promise<boolean>;
    isPoolFromFactory(pool: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
    version(overrides?: CallOverrides): Promise<string>;
    callStatic: {
        create(name: PromiseOrValue<string>, symbol: PromiseOrValue<string>, tokens: PromiseOrValue<string>[], amplificationParameter: PromiseOrValue<BigNumberish$1>, rateProviders: PromiseOrValue<string>[], tokenRateCacheDurations: PromiseOrValue<BigNumberish$1>[], exemptFromYieldProtocolFeeFlags: PromiseOrValue<boolean>[], swapFeePercentage: PromiseOrValue<BigNumberish$1>, owner: PromiseOrValue<string>, salt: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
        disable(overrides?: CallOverrides): Promise<void>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
        getAuthorizer(overrides?: CallOverrides): Promise<string>;
        getCreationCode(overrides?: CallOverrides): Promise<string>;
        getCreationCodeContracts(overrides?: CallOverrides): Promise<[string, string] & {
            contractA: string;
            contractB: string;
        }>;
        getPauseConfiguration(overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1
        ] & {
            pauseWindowDuration: BigNumber$1;
            bufferPeriodDuration: BigNumber$1;
        }>;
        getPoolVersion(overrides?: CallOverrides): Promise<string>;
        getProtocolFeePercentagesProvider(overrides?: CallOverrides): Promise<string>;
        getVault(overrides?: CallOverrides): Promise<string>;
        isDisabled(overrides?: CallOverrides): Promise<boolean>;
        isPoolFromFactory(pool: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
        version(overrides?: CallOverrides): Promise<string>;
    };
    filters: {
        "FactoryDisabled()"(): FactoryDisabledEventFilter$5;
        FactoryDisabled(): FactoryDisabledEventFilter$5;
        "PoolCreated(address)"(pool?: PromiseOrValue<string> | null): PoolCreatedEventFilter$5;
        PoolCreated(pool?: PromiseOrValue<string> | null): PoolCreatedEventFilter$5;
    };
    estimateGas: {
        create(name: PromiseOrValue<string>, symbol: PromiseOrValue<string>, tokens: PromiseOrValue<string>[], amplificationParameter: PromiseOrValue<BigNumberish$1>, rateProviders: PromiseOrValue<string>[], tokenRateCacheDurations: PromiseOrValue<BigNumberish$1>[], exemptFromYieldProtocolFeeFlags: PromiseOrValue<boolean>[], swapFeePercentage: PromiseOrValue<BigNumberish$1>, owner: PromiseOrValue<string>, salt: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        disable(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getAuthorizer(overrides?: CallOverrides): Promise<BigNumber$1>;
        getCreationCode(overrides?: CallOverrides): Promise<BigNumber$1>;
        getCreationCodeContracts(overrides?: CallOverrides): Promise<BigNumber$1>;
        getPauseConfiguration(overrides?: CallOverrides): Promise<BigNumber$1>;
        getPoolVersion(overrides?: CallOverrides): Promise<BigNumber$1>;
        getProtocolFeePercentagesProvider(overrides?: CallOverrides): Promise<BigNumber$1>;
        getVault(overrides?: CallOverrides): Promise<BigNumber$1>;
        isDisabled(overrides?: CallOverrides): Promise<BigNumber$1>;
        isPoolFromFactory(pool: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        version(overrides?: CallOverrides): Promise<BigNumber$1>;
    };
    populateTransaction: {
        create(name: PromiseOrValue<string>, symbol: PromiseOrValue<string>, tokens: PromiseOrValue<string>[], amplificationParameter: PromiseOrValue<BigNumberish$1>, rateProviders: PromiseOrValue<string>[], tokenRateCacheDurations: PromiseOrValue<BigNumberish$1>[], exemptFromYieldProtocolFeeFlags: PromiseOrValue<boolean>[], swapFeePercentage: PromiseOrValue<BigNumberish$1>, owner: PromiseOrValue<string>, salt: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        disable(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getAuthorizer(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getCreationCode(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getCreationCodeContracts(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getPauseConfiguration(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getPoolVersion(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getProtocolFeePercentagesProvider(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getVault(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        isDisabled(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        isPoolFromFactory(pool: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        version(overrides?: CallOverrides): Promise<PopulatedTransaction>;
    };
}

declare namespace IPoolSwapStructs$9 {
    type SwapRequestStruct = {
        kind: PromiseOrValue<BigNumberish$1>;
        tokenIn: PromiseOrValue<string>;
        tokenOut: PromiseOrValue<string>;
        amount: PromiseOrValue<BigNumberish$1>;
        poolId: PromiseOrValue<BytesLike>;
        lastChangeBlock: PromiseOrValue<BigNumberish$1>;
        from: PromiseOrValue<string>;
        to: PromiseOrValue<string>;
        userData: PromiseOrValue<BytesLike>;
    };
    type SwapRequestStructOutput = [
        number,
        string,
        string,
        BigNumber$1,
        string,
        BigNumber$1,
        string,
        string,
        string
    ] & {
        kind: number;
        tokenIn: string;
        tokenOut: string;
        amount: BigNumber$1;
        poolId: string;
        lastChangeBlock: BigNumber$1;
        from: string;
        to: string;
        userData: string;
    };
}
interface ConvergentCurvePoolInterface extends utils.Interface {
    functions: {
        "DOMAIN_SEPARATOR()": FunctionFragment;
        "FEE_BOUND()": FunctionFragment;
        "allowance(address,address)": FunctionFragment;
        "approve(address,uint256)": FunctionFragment;
        "balanceOf(address)": FunctionFragment;
        "bond()": FunctionFragment;
        "bondDecimals()": FunctionFragment;
        "decimals()": FunctionFragment;
        "decreaseApproval(address,uint256)": FunctionFragment;
        "expiration()": FunctionFragment;
        "feesBond()": FunctionFragment;
        "feesUnderlying()": FunctionFragment;
        "getPoolId()": FunctionFragment;
        "getVault()": FunctionFragment;
        "governance()": FunctionFragment;
        "increaseApproval(address,uint256)": FunctionFragment;
        "name()": FunctionFragment;
        "nonces(address)": FunctionFragment;
        "onExitPool(bytes32,address,address,uint256[],uint256,uint256,bytes)": FunctionFragment;
        "onJoinPool(bytes32,address,address,uint256[],uint256,uint256,bytes)": FunctionFragment;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)": FunctionFragment;
        "percentFee()": FunctionFragment;
        "percentFeeGov()": FunctionFragment;
        "permit(address,address,uint256,uint256,uint8,bytes32,bytes32)": FunctionFragment;
        "solveTradeInvariant(uint256,uint256,uint256,bool)": FunctionFragment;
        "symbol()": FunctionFragment;
        "totalSupply()": FunctionFragment;
        "transfer(address,uint256)": FunctionFragment;
        "transferFrom(address,address,uint256)": FunctionFragment;
        "underlying()": FunctionFragment;
        "underlyingDecimals()": FunctionFragment;
        "unitSeconds()": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "DOMAIN_SEPARATOR" | "FEE_BOUND" | "allowance" | "approve" | "balanceOf" | "bond" | "bondDecimals" | "decimals" | "decreaseApproval" | "expiration" | "feesBond" | "feesUnderlying" | "getPoolId" | "getVault" | "governance" | "increaseApproval" | "name" | "nonces" | "onExitPool" | "onJoinPool" | "onSwap" | "percentFee" | "percentFeeGov" | "permit" | "solveTradeInvariant" | "symbol" | "totalSupply" | "transfer" | "transferFrom" | "underlying" | "underlyingDecimals" | "unitSeconds"): FunctionFragment;
    encodeFunctionData(functionFragment: "DOMAIN_SEPARATOR", values?: undefined): string;
    encodeFunctionData(functionFragment: "FEE_BOUND", values?: undefined): string;
    encodeFunctionData(functionFragment: "allowance", values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "approve", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "balanceOf", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "bond", values?: undefined): string;
    encodeFunctionData(functionFragment: "bondDecimals", values?: undefined): string;
    encodeFunctionData(functionFragment: "decimals", values?: undefined): string;
    encodeFunctionData(functionFragment: "decreaseApproval", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "expiration", values?: undefined): string;
    encodeFunctionData(functionFragment: "feesBond", values?: undefined): string;
    encodeFunctionData(functionFragment: "feesUnderlying", values?: undefined): string;
    encodeFunctionData(functionFragment: "getPoolId", values?: undefined): string;
    encodeFunctionData(functionFragment: "getVault", values?: undefined): string;
    encodeFunctionData(functionFragment: "governance", values?: undefined): string;
    encodeFunctionData(functionFragment: "increaseApproval", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "name", values?: undefined): string;
    encodeFunctionData(functionFragment: "nonces", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "onExitPool", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "onJoinPool", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "onSwap", values: [
        IPoolSwapStructs$9.SwapRequestStruct,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "percentFee", values?: undefined): string;
    encodeFunctionData(functionFragment: "percentFeeGov", values?: undefined): string;
    encodeFunctionData(functionFragment: "permit", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "solveTradeInvariant", values: [
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<boolean>
    ]): string;
    encodeFunctionData(functionFragment: "symbol", values?: undefined): string;
    encodeFunctionData(functionFragment: "totalSupply", values?: undefined): string;
    encodeFunctionData(functionFragment: "transfer", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "transferFrom", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "underlying", values?: undefined): string;
    encodeFunctionData(functionFragment: "underlyingDecimals", values?: undefined): string;
    encodeFunctionData(functionFragment: "unitSeconds", values?: undefined): string;
    decodeFunctionResult(functionFragment: "DOMAIN_SEPARATOR", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "FEE_BOUND", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "allowance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "approve", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "balanceOf", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "bond", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "bondDecimals", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "decimals", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "decreaseApproval", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "expiration", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "feesBond", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "feesUnderlying", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getPoolId", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getVault", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "governance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "increaseApproval", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "name", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "nonces", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "onExitPool", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "onJoinPool", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "onSwap", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "percentFee", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "percentFeeGov", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "permit", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "solveTradeInvariant", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "symbol", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "totalSupply", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "transfer", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "transferFrom", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "underlying", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "underlyingDecimals", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "unitSeconds", data: BytesLike): Result;
    events: {
        "Approval(address,address,uint256)": EventFragment;
        "FeeCollection(uint256,uint256,uint256,uint256)": EventFragment;
        "Transfer(address,address,uint256)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "Approval"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "FeeCollection"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Transfer"): EventFragment;
}
interface ApprovalEventObject$b {
    owner: string;
    spender: string;
    value: BigNumber$1;
}
type ApprovalEvent$b = TypedEvent<[
    string,
    string,
    BigNumber$1
], ApprovalEventObject$b>;
type ApprovalEventFilter$b = TypedEventFilter<ApprovalEvent$b>;
interface FeeCollectionEventObject {
    collectedBase: BigNumber$1;
    collectedBond: BigNumber$1;
    remainingBase: BigNumber$1;
    remainingBond: BigNumber$1;
}
type FeeCollectionEvent = TypedEvent<[
    BigNumber$1,
    BigNumber$1,
    BigNumber$1,
    BigNumber$1
], FeeCollectionEventObject>;
type FeeCollectionEventFilter = TypedEventFilter<FeeCollectionEvent>;
interface TransferEventObject$b {
    from: string;
    to: string;
    value: BigNumber$1;
}
type TransferEvent$b = TypedEvent<[
    string,
    string,
    BigNumber$1
], TransferEventObject$b>;
type TransferEventFilter$b = TypedEventFilter<TransferEvent$b>;
interface ConvergentCurvePool extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: ConvergentCurvePoolInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<[string]>;
        FEE_BOUND(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        bond(overrides?: CallOverrides): Promise<[string]>;
        bondDecimals(overrides?: CallOverrides): Promise<[number]>;
        decimals(overrides?: CallOverrides): Promise<[number]>;
        decreaseApproval(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        expiration(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        feesBond(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        feesUnderlying(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getPoolId(overrides?: CallOverrides): Promise<[string]>;
        getVault(overrides?: CallOverrides): Promise<[string]>;
        governance(overrides?: CallOverrides): Promise<[string]>;
        increaseApproval(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        name(overrides?: CallOverrides): Promise<[string]>;
        nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        onExitPool(poolId: PromiseOrValue<BytesLike>, arg1: PromiseOrValue<string>, recipient: PromiseOrValue<string>, currentBalances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, protocolSwapFee: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        onJoinPool(poolId: PromiseOrValue<BytesLike>, arg1: PromiseOrValue<string>, recipient: PromiseOrValue<string>, currentBalances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, protocolSwapFee: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        onSwap(swapRequest: IPoolSwapStructs$9.SwapRequestStruct, currentBalanceTokenIn: PromiseOrValue<BigNumberish$1>, currentBalanceTokenOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        percentFee(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        percentFeeGov(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        solveTradeInvariant(amountX: PromiseOrValue<BigNumberish$1>, reserveX: PromiseOrValue<BigNumberish$1>, reserveY: PromiseOrValue<BigNumberish$1>, out: PromiseOrValue<boolean>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        symbol(overrides?: CallOverrides): Promise<[string]>;
        totalSupply(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        underlying(overrides?: CallOverrides): Promise<[string]>;
        underlyingDecimals(overrides?: CallOverrides): Promise<[number]>;
        unitSeconds(overrides?: CallOverrides): Promise<[BigNumber$1]>;
    };
    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;
    FEE_BOUND(overrides?: CallOverrides): Promise<BigNumber$1>;
    allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    bond(overrides?: CallOverrides): Promise<string>;
    bondDecimals(overrides?: CallOverrides): Promise<number>;
    decimals(overrides?: CallOverrides): Promise<number>;
    decreaseApproval(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    expiration(overrides?: CallOverrides): Promise<BigNumber$1>;
    feesBond(overrides?: CallOverrides): Promise<BigNumber$1>;
    feesUnderlying(overrides?: CallOverrides): Promise<BigNumber$1>;
    getPoolId(overrides?: CallOverrides): Promise<string>;
    getVault(overrides?: CallOverrides): Promise<string>;
    governance(overrides?: CallOverrides): Promise<string>;
    increaseApproval(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    name(overrides?: CallOverrides): Promise<string>;
    nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    onExitPool(poolId: PromiseOrValue<BytesLike>, arg1: PromiseOrValue<string>, recipient: PromiseOrValue<string>, currentBalances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, protocolSwapFee: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    onJoinPool(poolId: PromiseOrValue<BytesLike>, arg1: PromiseOrValue<string>, recipient: PromiseOrValue<string>, currentBalances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, protocolSwapFee: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    onSwap(swapRequest: IPoolSwapStructs$9.SwapRequestStruct, currentBalanceTokenIn: PromiseOrValue<BigNumberish$1>, currentBalanceTokenOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    percentFee(overrides?: CallOverrides): Promise<BigNumber$1>;
    percentFeeGov(overrides?: CallOverrides): Promise<BigNumber$1>;
    permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    solveTradeInvariant(amountX: PromiseOrValue<BigNumberish$1>, reserveX: PromiseOrValue<BigNumberish$1>, reserveY: PromiseOrValue<BigNumberish$1>, out: PromiseOrValue<boolean>, overrides?: CallOverrides): Promise<BigNumber$1>;
    symbol(overrides?: CallOverrides): Promise<string>;
    totalSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
    transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    underlying(overrides?: CallOverrides): Promise<string>;
    underlyingDecimals(overrides?: CallOverrides): Promise<number>;
    unitSeconds(overrides?: CallOverrides): Promise<BigNumber$1>;
    callStatic: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;
        FEE_BOUND(overrides?: CallOverrides): Promise<BigNumber$1>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        bond(overrides?: CallOverrides): Promise<string>;
        bondDecimals(overrides?: CallOverrides): Promise<number>;
        decimals(overrides?: CallOverrides): Promise<number>;
        decreaseApproval(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        expiration(overrides?: CallOverrides): Promise<BigNumber$1>;
        feesBond(overrides?: CallOverrides): Promise<BigNumber$1>;
        feesUnderlying(overrides?: CallOverrides): Promise<BigNumber$1>;
        getPoolId(overrides?: CallOverrides): Promise<string>;
        getVault(overrides?: CallOverrides): Promise<string>;
        governance(overrides?: CallOverrides): Promise<string>;
        increaseApproval(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        name(overrides?: CallOverrides): Promise<string>;
        nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        onExitPool(poolId: PromiseOrValue<BytesLike>, arg1: PromiseOrValue<string>, recipient: PromiseOrValue<string>, currentBalances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, protocolSwapFee: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[
            BigNumber$1[],
            BigNumber$1[]
        ] & {
            amountsOut: BigNumber$1[];
            dueProtocolFeeAmounts: BigNumber$1[];
        }>;
        onJoinPool(poolId: PromiseOrValue<BytesLike>, arg1: PromiseOrValue<string>, recipient: PromiseOrValue<string>, currentBalances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, protocolSwapFee: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[
            BigNumber$1[],
            BigNumber$1[]
        ] & {
            amountsIn: BigNumber$1[];
            dueProtocolFeeAmounts: BigNumber$1[];
        }>;
        onSwap(swapRequest: IPoolSwapStructs$9.SwapRequestStruct, currentBalanceTokenIn: PromiseOrValue<BigNumberish$1>, currentBalanceTokenOut: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        percentFee(overrides?: CallOverrides): Promise<BigNumber$1>;
        percentFeeGov(overrides?: CallOverrides): Promise<BigNumber$1>;
        permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<void>;
        solveTradeInvariant(amountX: PromiseOrValue<BigNumberish$1>, reserveX: PromiseOrValue<BigNumberish$1>, reserveY: PromiseOrValue<BigNumberish$1>, out: PromiseOrValue<boolean>, overrides?: CallOverrides): Promise<BigNumber$1>;
        symbol(overrides?: CallOverrides): Promise<string>;
        totalSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
        transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        underlying(overrides?: CallOverrides): Promise<string>;
        underlyingDecimals(overrides?: CallOverrides): Promise<number>;
        unitSeconds(overrides?: CallOverrides): Promise<BigNumber$1>;
    };
    filters: {
        "Approval(address,address,uint256)"(owner?: PromiseOrValue<string> | null, spender?: PromiseOrValue<string> | null, value?: null): ApprovalEventFilter$b;
        Approval(owner?: PromiseOrValue<string> | null, spender?: PromiseOrValue<string> | null, value?: null): ApprovalEventFilter$b;
        "FeeCollection(uint256,uint256,uint256,uint256)"(collectedBase?: null, collectedBond?: null, remainingBase?: null, remainingBond?: null): FeeCollectionEventFilter;
        FeeCollection(collectedBase?: null, collectedBond?: null, remainingBase?: null, remainingBond?: null): FeeCollectionEventFilter;
        "Transfer(address,address,uint256)"(from?: PromiseOrValue<string> | null, to?: PromiseOrValue<string> | null, value?: null): TransferEventFilter$b;
        Transfer(from?: PromiseOrValue<string> | null, to?: PromiseOrValue<string> | null, value?: null): TransferEventFilter$b;
    };
    estimateGas: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<BigNumber$1>;
        FEE_BOUND(overrides?: CallOverrides): Promise<BigNumber$1>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        bond(overrides?: CallOverrides): Promise<BigNumber$1>;
        bondDecimals(overrides?: CallOverrides): Promise<BigNumber$1>;
        decimals(overrides?: CallOverrides): Promise<BigNumber$1>;
        decreaseApproval(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        expiration(overrides?: CallOverrides): Promise<BigNumber$1>;
        feesBond(overrides?: CallOverrides): Promise<BigNumber$1>;
        feesUnderlying(overrides?: CallOverrides): Promise<BigNumber$1>;
        getPoolId(overrides?: CallOverrides): Promise<BigNumber$1>;
        getVault(overrides?: CallOverrides): Promise<BigNumber$1>;
        governance(overrides?: CallOverrides): Promise<BigNumber$1>;
        increaseApproval(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        name(overrides?: CallOverrides): Promise<BigNumber$1>;
        nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        onExitPool(poolId: PromiseOrValue<BytesLike>, arg1: PromiseOrValue<string>, recipient: PromiseOrValue<string>, currentBalances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, protocolSwapFee: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        onJoinPool(poolId: PromiseOrValue<BytesLike>, arg1: PromiseOrValue<string>, recipient: PromiseOrValue<string>, currentBalances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, protocolSwapFee: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        onSwap(swapRequest: IPoolSwapStructs$9.SwapRequestStruct, currentBalanceTokenIn: PromiseOrValue<BigNumberish$1>, currentBalanceTokenOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        percentFee(overrides?: CallOverrides): Promise<BigNumber$1>;
        percentFeeGov(overrides?: CallOverrides): Promise<BigNumber$1>;
        permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        solveTradeInvariant(amountX: PromiseOrValue<BigNumberish$1>, reserveX: PromiseOrValue<BigNumberish$1>, reserveY: PromiseOrValue<BigNumberish$1>, out: PromiseOrValue<boolean>, overrides?: CallOverrides): Promise<BigNumber$1>;
        symbol(overrides?: CallOverrides): Promise<BigNumber$1>;
        totalSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
        transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        underlying(overrides?: CallOverrides): Promise<BigNumber$1>;
        underlyingDecimals(overrides?: CallOverrides): Promise<BigNumber$1>;
        unitSeconds(overrides?: CallOverrides): Promise<BigNumber$1>;
    };
    populateTransaction: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        FEE_BOUND(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        bond(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        bondDecimals(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        decimals(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        decreaseApproval(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        expiration(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        feesBond(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        feesUnderlying(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getPoolId(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getVault(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        governance(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        increaseApproval(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        name(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        onExitPool(poolId: PromiseOrValue<BytesLike>, arg1: PromiseOrValue<string>, recipient: PromiseOrValue<string>, currentBalances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, protocolSwapFee: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        onJoinPool(poolId: PromiseOrValue<BytesLike>, arg1: PromiseOrValue<string>, recipient: PromiseOrValue<string>, currentBalances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, protocolSwapFee: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        onSwap(swapRequest: IPoolSwapStructs$9.SwapRequestStruct, currentBalanceTokenIn: PromiseOrValue<BigNumberish$1>, currentBalanceTokenOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        percentFee(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        percentFeeGov(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        solveTradeInvariant(amountX: PromiseOrValue<BigNumberish$1>, reserveX: PromiseOrValue<BigNumberish$1>, reserveY: PromiseOrValue<BigNumberish$1>, out: PromiseOrValue<boolean>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        symbol(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        totalSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        underlying(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        underlyingDecimals(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        unitSeconds(overrides?: CallOverrides): Promise<PopulatedTransaction>;
    };
}

interface ERC20Interface extends utils.Interface {
    functions: {
        "name()": FunctionFragment;
        "approve(address,uint256)": FunctionFragment;
        "totalSupply()": FunctionFragment;
        "transferFrom(address,address,uint256)": FunctionFragment;
        "decimals()": FunctionFragment;
        "balanceOf(address)": FunctionFragment;
        "symbol()": FunctionFragment;
        "transfer(address,uint256)": FunctionFragment;
        "allowance(address,address)": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "name" | "approve" | "totalSupply" | "transferFrom" | "decimals" | "balanceOf" | "symbol" | "transfer" | "allowance"): FunctionFragment;
    encodeFunctionData(functionFragment: "name", values?: undefined): string;
    encodeFunctionData(functionFragment: "approve", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "totalSupply", values?: undefined): string;
    encodeFunctionData(functionFragment: "transferFrom", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "decimals", values?: undefined): string;
    encodeFunctionData(functionFragment: "balanceOf", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "symbol", values?: undefined): string;
    encodeFunctionData(functionFragment: "transfer", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "allowance", values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
    decodeFunctionResult(functionFragment: "name", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "approve", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "totalSupply", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "transferFrom", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "decimals", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "balanceOf", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "symbol", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "transfer", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "allowance", data: BytesLike): Result;
    events: {
        "Approval(address,address,uint256)": EventFragment;
        "Transfer(address,address,uint256)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "Approval"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Transfer"): EventFragment;
}
interface ApprovalEventObject$a {
    owner: string;
    spender: string;
    value: BigNumber$1;
}
type ApprovalEvent$a = TypedEvent<[
    string,
    string,
    BigNumber$1
], ApprovalEventObject$a>;
type ApprovalEventFilter$a = TypedEventFilter<ApprovalEvent$a>;
interface TransferEventObject$a {
    from: string;
    to: string;
    value: BigNumber$1;
}
type TransferEvent$a = TypedEvent<[
    string,
    string,
    BigNumber$1
], TransferEventObject$a>;
type TransferEventFilter$a = TypedEventFilter<TransferEvent$a>;
interface ERC20 extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: ERC20Interface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        name(overrides?: CallOverrides): Promise<[string]>;
        approve(_spender: PromiseOrValue<string>, _value: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        totalSupply(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        transferFrom(_from: PromiseOrValue<string>, _to: PromiseOrValue<string>, _value: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        decimals(overrides?: CallOverrides): Promise<[number]>;
        balanceOf(_owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1] & {
            balance: BigNumber$1;
        }>;
        symbol(overrides?: CallOverrides): Promise<[string]>;
        transfer(_to: PromiseOrValue<string>, _value: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        allowance(_owner: PromiseOrValue<string>, _spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
    };
    name(overrides?: CallOverrides): Promise<string>;
    approve(_spender: PromiseOrValue<string>, _value: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    totalSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
    transferFrom(_from: PromiseOrValue<string>, _to: PromiseOrValue<string>, _value: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    decimals(overrides?: CallOverrides): Promise<number>;
    balanceOf(_owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    symbol(overrides?: CallOverrides): Promise<string>;
    transfer(_to: PromiseOrValue<string>, _value: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    allowance(_owner: PromiseOrValue<string>, _spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    callStatic: {
        name(overrides?: CallOverrides): Promise<string>;
        approve(_spender: PromiseOrValue<string>, _value: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        totalSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
        transferFrom(_from: PromiseOrValue<string>, _to: PromiseOrValue<string>, _value: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        decimals(overrides?: CallOverrides): Promise<number>;
        balanceOf(_owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        symbol(overrides?: CallOverrides): Promise<string>;
        transfer(_to: PromiseOrValue<string>, _value: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        allowance(_owner: PromiseOrValue<string>, _spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    };
    filters: {
        "Approval(address,address,uint256)"(owner?: PromiseOrValue<string> | null, spender?: PromiseOrValue<string> | null, value?: null): ApprovalEventFilter$a;
        Approval(owner?: PromiseOrValue<string> | null, spender?: PromiseOrValue<string> | null, value?: null): ApprovalEventFilter$a;
        "Transfer(address,address,uint256)"(from?: PromiseOrValue<string> | null, to?: PromiseOrValue<string> | null, value?: null): TransferEventFilter$a;
        Transfer(from?: PromiseOrValue<string> | null, to?: PromiseOrValue<string> | null, value?: null): TransferEventFilter$a;
    };
    estimateGas: {
        name(overrides?: CallOverrides): Promise<BigNumber$1>;
        approve(_spender: PromiseOrValue<string>, _value: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        totalSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
        transferFrom(_from: PromiseOrValue<string>, _to: PromiseOrValue<string>, _value: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        decimals(overrides?: CallOverrides): Promise<BigNumber$1>;
        balanceOf(_owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        symbol(overrides?: CallOverrides): Promise<BigNumber$1>;
        transfer(_to: PromiseOrValue<string>, _value: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        allowance(_owner: PromiseOrValue<string>, _spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    };
    populateTransaction: {
        name(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        approve(_spender: PromiseOrValue<string>, _value: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        totalSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        transferFrom(_from: PromiseOrValue<string>, _to: PromiseOrValue<string>, _value: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        decimals(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        balanceOf(_owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        symbol(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        transfer(_to: PromiseOrValue<string>, _value: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        allowance(_owner: PromiseOrValue<string>, _spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
    };
}

declare namespace IPoolSwapStructs$8 {
    type SwapRequestStruct = {
        kind: PromiseOrValue<BigNumberish$1>;
        tokenIn: PromiseOrValue<string>;
        tokenOut: PromiseOrValue<string>;
        amount: PromiseOrValue<BigNumberish$1>;
        poolId: PromiseOrValue<BytesLike>;
        lastChangeBlock: PromiseOrValue<BigNumberish$1>;
        from: PromiseOrValue<string>;
        to: PromiseOrValue<string>;
        userData: PromiseOrValue<BytesLike>;
    };
    type SwapRequestStructOutput = [
        number,
        string,
        string,
        BigNumber$1,
        string,
        BigNumber$1,
        string,
        string,
        string
    ] & {
        kind: number;
        tokenIn: string;
        tokenOut: string;
        amount: BigNumber$1;
        poolId: string;
        lastChangeBlock: BigNumber$1;
        from: string;
        to: string;
        userData: string;
    };
}
interface ERC4626LinearPoolInterface extends utils.Interface {
    functions: {
        "DOMAIN_SEPARATOR()": FunctionFragment;
        "allowance(address,address)": FunctionFragment;
        "approve(address,uint256)": FunctionFragment;
        "balanceOf(address)": FunctionFragment;
        "decimals()": FunctionFragment;
        "decreaseAllowance(address,uint256)": FunctionFragment;
        "disableRecoveryMode()": FunctionFragment;
        "enableRecoveryMode()": FunctionFragment;
        "getActionId(bytes4)": FunctionFragment;
        "getAuthorizer()": FunctionFragment;
        "getBptIndex()": FunctionFragment;
        "getDomainSeparator()": FunctionFragment;
        "getMainIndex()": FunctionFragment;
        "getMainToken()": FunctionFragment;
        "getNextNonce(address)": FunctionFragment;
        "getOwner()": FunctionFragment;
        "getPausedState()": FunctionFragment;
        "getPoolId()": FunctionFragment;
        "getProtocolFeesCollector()": FunctionFragment;
        "getRate()": FunctionFragment;
        "getScalingFactors()": FunctionFragment;
        "getSwapFeePercentage()": FunctionFragment;
        "getTargets()": FunctionFragment;
        "getVault()": FunctionFragment;
        "getVirtualSupply()": FunctionFragment;
        "getWrappedIndex()": FunctionFragment;
        "getWrappedToken()": FunctionFragment;
        "getWrappedTokenRate()": FunctionFragment;
        "inRecoveryMode()": FunctionFragment;
        "increaseAllowance(address,uint256)": FunctionFragment;
        "initialize()": FunctionFragment;
        "name()": FunctionFragment;
        "nonces(address)": FunctionFragment;
        "onExitPool(bytes32,address,address,uint256[],uint256,uint256,bytes)": FunctionFragment;
        "onJoinPool(bytes32,address,address,uint256[],uint256,uint256,bytes)": FunctionFragment;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)": FunctionFragment;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)": FunctionFragment;
        "pause()": FunctionFragment;
        "permit(address,address,uint256,uint256,uint8,bytes32,bytes32)": FunctionFragment;
        "queryExit(bytes32,address,address,uint256[],uint256,uint256,bytes)": FunctionFragment;
        "queryJoin(bytes32,address,address,uint256[],uint256,uint256,bytes)": FunctionFragment;
        "setSwapFeePercentage(uint256)": FunctionFragment;
        "setTargets(uint256,uint256)": FunctionFragment;
        "symbol()": FunctionFragment;
        "totalSupply()": FunctionFragment;
        "transfer(address,uint256)": FunctionFragment;
        "transferFrom(address,address,uint256)": FunctionFragment;
        "unpause()": FunctionFragment;
        "version()": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "DOMAIN_SEPARATOR" | "allowance" | "approve" | "balanceOf" | "decimals" | "decreaseAllowance" | "disableRecoveryMode" | "enableRecoveryMode" | "getActionId" | "getAuthorizer" | "getBptIndex" | "getDomainSeparator" | "getMainIndex" | "getMainToken" | "getNextNonce" | "getOwner" | "getPausedState" | "getPoolId" | "getProtocolFeesCollector" | "getRate" | "getScalingFactors" | "getSwapFeePercentage" | "getTargets" | "getVault" | "getVirtualSupply" | "getWrappedIndex" | "getWrappedToken" | "getWrappedTokenRate" | "inRecoveryMode" | "increaseAllowance" | "initialize" | "name" | "nonces" | "onExitPool" | "onJoinPool" | "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)" | "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)" | "pause" | "permit" | "queryExit" | "queryJoin" | "setSwapFeePercentage" | "setTargets" | "symbol" | "totalSupply" | "transfer" | "transferFrom" | "unpause" | "version"): FunctionFragment;
    encodeFunctionData(functionFragment: "DOMAIN_SEPARATOR", values?: undefined): string;
    encodeFunctionData(functionFragment: "allowance", values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "approve", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "balanceOf", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "decimals", values?: undefined): string;
    encodeFunctionData(functionFragment: "decreaseAllowance", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "disableRecoveryMode", values?: undefined): string;
    encodeFunctionData(functionFragment: "enableRecoveryMode", values?: undefined): string;
    encodeFunctionData(functionFragment: "getActionId", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "getAuthorizer", values?: undefined): string;
    encodeFunctionData(functionFragment: "getBptIndex", values?: undefined): string;
    encodeFunctionData(functionFragment: "getDomainSeparator", values?: undefined): string;
    encodeFunctionData(functionFragment: "getMainIndex", values?: undefined): string;
    encodeFunctionData(functionFragment: "getMainToken", values?: undefined): string;
    encodeFunctionData(functionFragment: "getNextNonce", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "getOwner", values?: undefined): string;
    encodeFunctionData(functionFragment: "getPausedState", values?: undefined): string;
    encodeFunctionData(functionFragment: "getPoolId", values?: undefined): string;
    encodeFunctionData(functionFragment: "getProtocolFeesCollector", values?: undefined): string;
    encodeFunctionData(functionFragment: "getRate", values?: undefined): string;
    encodeFunctionData(functionFragment: "getScalingFactors", values?: undefined): string;
    encodeFunctionData(functionFragment: "getSwapFeePercentage", values?: undefined): string;
    encodeFunctionData(functionFragment: "getTargets", values?: undefined): string;
    encodeFunctionData(functionFragment: "getVault", values?: undefined): string;
    encodeFunctionData(functionFragment: "getVirtualSupply", values?: undefined): string;
    encodeFunctionData(functionFragment: "getWrappedIndex", values?: undefined): string;
    encodeFunctionData(functionFragment: "getWrappedToken", values?: undefined): string;
    encodeFunctionData(functionFragment: "getWrappedTokenRate", values?: undefined): string;
    encodeFunctionData(functionFragment: "inRecoveryMode", values?: undefined): string;
    encodeFunctionData(functionFragment: "increaseAllowance", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "initialize", values?: undefined): string;
    encodeFunctionData(functionFragment: "name", values?: undefined): string;
    encodeFunctionData(functionFragment: "nonces", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "onExitPool", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "onJoinPool", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)", values: [
        IPoolSwapStructs$8.SwapRequestStruct,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)", values: [
        IPoolSwapStructs$8.SwapRequestStruct,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "pause", values?: undefined): string;
    encodeFunctionData(functionFragment: "permit", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "queryExit", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "queryJoin", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "setSwapFeePercentage", values: [PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "setTargets", values: [PromiseOrValue<BigNumberish$1>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "symbol", values?: undefined): string;
    encodeFunctionData(functionFragment: "totalSupply", values?: undefined): string;
    encodeFunctionData(functionFragment: "transfer", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "transferFrom", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "unpause", values?: undefined): string;
    encodeFunctionData(functionFragment: "version", values?: undefined): string;
    decodeFunctionResult(functionFragment: "DOMAIN_SEPARATOR", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "allowance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "approve", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "balanceOf", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "decimals", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "decreaseAllowance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "disableRecoveryMode", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "enableRecoveryMode", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getActionId", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getAuthorizer", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getBptIndex", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getDomainSeparator", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getMainIndex", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getMainToken", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getNextNonce", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getOwner", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getPausedState", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getPoolId", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getProtocolFeesCollector", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getRate", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getScalingFactors", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getSwapFeePercentage", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getTargets", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getVault", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getVirtualSupply", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getWrappedIndex", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getWrappedToken", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getWrappedTokenRate", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "inRecoveryMode", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "increaseAllowance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "name", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "nonces", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "onExitPool", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "onJoinPool", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "pause", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "permit", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "queryExit", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "queryJoin", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setSwapFeePercentage", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setTargets", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "symbol", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "totalSupply", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "transfer", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "transferFrom", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "unpause", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "version", data: BytesLike): Result;
    events: {
        "Approval(address,address,uint256)": EventFragment;
        "PausedStateChanged(bool)": EventFragment;
        "RecoveryModeStateChanged(bool)": EventFragment;
        "SwapFeePercentageChanged(uint256)": EventFragment;
        "TargetsSet(address,uint256,uint256)": EventFragment;
        "Transfer(address,address,uint256)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "Approval"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "PausedStateChanged"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "RecoveryModeStateChanged"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "SwapFeePercentageChanged"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "TargetsSet"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Transfer"): EventFragment;
}
interface ApprovalEventObject$9 {
    owner: string;
    spender: string;
    value: BigNumber$1;
}
type ApprovalEvent$9 = TypedEvent<[
    string,
    string,
    BigNumber$1
], ApprovalEventObject$9>;
type ApprovalEventFilter$9 = TypedEventFilter<ApprovalEvent$9>;
interface PausedStateChangedEventObject$8 {
    paused: boolean;
}
type PausedStateChangedEvent$8 = TypedEvent<[
    boolean
], PausedStateChangedEventObject$8>;
type PausedStateChangedEventFilter$8 = TypedEventFilter<PausedStateChangedEvent$8>;
interface RecoveryModeStateChangedEventObject$4 {
    enabled: boolean;
}
type RecoveryModeStateChangedEvent$4 = TypedEvent<[
    boolean
], RecoveryModeStateChangedEventObject$4>;
type RecoveryModeStateChangedEventFilter$4 = TypedEventFilter<RecoveryModeStateChangedEvent$4>;
interface SwapFeePercentageChangedEventObject$7 {
    swapFeePercentage: BigNumber$1;
}
type SwapFeePercentageChangedEvent$7 = TypedEvent<[
    BigNumber$1
], SwapFeePercentageChangedEventObject$7>;
type SwapFeePercentageChangedEventFilter$7 = TypedEventFilter<SwapFeePercentageChangedEvent$7>;
interface TargetsSetEventObject$4 {
    token: string;
    lowerTarget: BigNumber$1;
    upperTarget: BigNumber$1;
}
type TargetsSetEvent$4 = TypedEvent<[
    string,
    BigNumber$1,
    BigNumber$1
], TargetsSetEventObject$4>;
type TargetsSetEventFilter$4 = TypedEventFilter<TargetsSetEvent$4>;
interface TransferEventObject$9 {
    from: string;
    to: string;
    value: BigNumber$1;
}
type TransferEvent$9 = TypedEvent<[
    string,
    string,
    BigNumber$1
], TransferEventObject$9>;
type TransferEventFilter$9 = TypedEventFilter<TransferEvent$9>;
declare namespace ERC4626LinearPool {
    type ConstructorArgsStruct = {
        vault: PromiseOrValue<string>;
        name: PromiseOrValue<string>;
        symbol: PromiseOrValue<string>;
        mainToken: PromiseOrValue<string>;
        wrappedToken: PromiseOrValue<string>;
        assetManager: PromiseOrValue<string>;
        upperTarget: PromiseOrValue<BigNumberish$1>;
        swapFeePercentage: PromiseOrValue<BigNumberish$1>;
        pauseWindowDuration: PromiseOrValue<BigNumberish$1>;
        bufferPeriodDuration: PromiseOrValue<BigNumberish$1>;
        owner: PromiseOrValue<string>;
        version: PromiseOrValue<string>;
    };
    type ConstructorArgsStructOutput = [
        string,
        string,
        string,
        string,
        string,
        string,
        BigNumber$1,
        BigNumber$1,
        BigNumber$1,
        BigNumber$1,
        string,
        string
    ] & {
        vault: string;
        name: string;
        symbol: string;
        mainToken: string;
        wrappedToken: string;
        assetManager: string;
        upperTarget: BigNumber$1;
        swapFeePercentage: BigNumber$1;
        pauseWindowDuration: BigNumber$1;
        bufferPeriodDuration: BigNumber$1;
        owner: string;
        version: string;
    };
}
interface ERC4626LinearPool extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: ERC4626LinearPoolInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<[string]>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        decimals(overrides?: CallOverrides): Promise<[number]>;
        decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        disableRecoveryMode(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        enableRecoveryMode(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[string]>;
        getAuthorizer(overrides?: CallOverrides): Promise<[string]>;
        getBptIndex(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getDomainSeparator(overrides?: CallOverrides): Promise<[string]>;
        getMainIndex(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getMainToken(overrides?: CallOverrides): Promise<[string]>;
        getNextNonce(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getOwner(overrides?: CallOverrides): Promise<[string]>;
        getPausedState(overrides?: CallOverrides): Promise<[
            boolean,
            BigNumber$1,
            BigNumber$1
        ] & {
            paused: boolean;
            pauseWindowEndTime: BigNumber$1;
            bufferPeriodEndTime: BigNumber$1;
        }>;
        getPoolId(overrides?: CallOverrides): Promise<[string]>;
        getProtocolFeesCollector(overrides?: CallOverrides): Promise<[string]>;
        getRate(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getScalingFactors(overrides?: CallOverrides): Promise<[BigNumber$1[]]>;
        getSwapFeePercentage(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getTargets(overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1
        ] & {
            lowerTarget: BigNumber$1;
            upperTarget: BigNumber$1;
        }>;
        getVault(overrides?: CallOverrides): Promise<[string]>;
        getVirtualSupply(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getWrappedIndex(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getWrappedToken(overrides?: CallOverrides): Promise<[string]>;
        getWrappedTokenRate(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        inRecoveryMode(overrides?: CallOverrides): Promise<[boolean]>;
        increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        initialize(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        name(overrides?: CallOverrides): Promise<[string]>;
        nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        onJoinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)"(request: IPoolSwapStructs$8.SwapRequestStruct, balances: PromiseOrValue<BigNumberish$1>[], indexIn: PromiseOrValue<BigNumberish$1>, indexOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)"(request: IPoolSwapStructs$8.SwapRequestStruct, balanceTokenIn: PromiseOrValue<BigNumberish$1>, balanceTokenOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        pause(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        queryExit(arg0: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        queryJoin(arg0: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setSwapFeePercentage(swapFeePercentage: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setTargets(newLowerTarget: PromiseOrValue<BigNumberish$1>, newUpperTarget: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        symbol(overrides?: CallOverrides): Promise<[string]>;
        totalSupply(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        unpause(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        version(overrides?: CallOverrides): Promise<[string]>;
    };
    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;
    allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    decimals(overrides?: CallOverrides): Promise<number>;
    decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    disableRecoveryMode(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    enableRecoveryMode(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
    getAuthorizer(overrides?: CallOverrides): Promise<string>;
    getBptIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
    getDomainSeparator(overrides?: CallOverrides): Promise<string>;
    getMainIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
    getMainToken(overrides?: CallOverrides): Promise<string>;
    getNextNonce(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    getOwner(overrides?: CallOverrides): Promise<string>;
    getPausedState(overrides?: CallOverrides): Promise<[
        boolean,
        BigNumber$1,
        BigNumber$1
    ] & {
        paused: boolean;
        pauseWindowEndTime: BigNumber$1;
        bufferPeriodEndTime: BigNumber$1;
    }>;
    getPoolId(overrides?: CallOverrides): Promise<string>;
    getProtocolFeesCollector(overrides?: CallOverrides): Promise<string>;
    getRate(overrides?: CallOverrides): Promise<BigNumber$1>;
    getScalingFactors(overrides?: CallOverrides): Promise<BigNumber$1[]>;
    getSwapFeePercentage(overrides?: CallOverrides): Promise<BigNumber$1>;
    getTargets(overrides?: CallOverrides): Promise<[
        BigNumber$1,
        BigNumber$1
    ] & {
        lowerTarget: BigNumber$1;
        upperTarget: BigNumber$1;
    }>;
    getVault(overrides?: CallOverrides): Promise<string>;
    getVirtualSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
    getWrappedIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
    getWrappedToken(overrides?: CallOverrides): Promise<string>;
    getWrappedTokenRate(overrides?: CallOverrides): Promise<BigNumber$1>;
    inRecoveryMode(overrides?: CallOverrides): Promise<boolean>;
    increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    initialize(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    name(overrides?: CallOverrides): Promise<string>;
    nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    onJoinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)"(request: IPoolSwapStructs$8.SwapRequestStruct, balances: PromiseOrValue<BigNumberish$1>[], indexIn: PromiseOrValue<BigNumberish$1>, indexOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)"(request: IPoolSwapStructs$8.SwapRequestStruct, balanceTokenIn: PromiseOrValue<BigNumberish$1>, balanceTokenOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    pause(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    queryExit(arg0: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    queryJoin(arg0: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setSwapFeePercentage(swapFeePercentage: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setTargets(newLowerTarget: PromiseOrValue<BigNumberish$1>, newUpperTarget: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    symbol(overrides?: CallOverrides): Promise<string>;
    totalSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
    transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    unpause(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    version(overrides?: CallOverrides): Promise<string>;
    callStatic: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        decimals(overrides?: CallOverrides): Promise<number>;
        decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        disableRecoveryMode(overrides?: CallOverrides): Promise<void>;
        enableRecoveryMode(overrides?: CallOverrides): Promise<void>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
        getAuthorizer(overrides?: CallOverrides): Promise<string>;
        getBptIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
        getDomainSeparator(overrides?: CallOverrides): Promise<string>;
        getMainIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
        getMainToken(overrides?: CallOverrides): Promise<string>;
        getNextNonce(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getOwner(overrides?: CallOverrides): Promise<string>;
        getPausedState(overrides?: CallOverrides): Promise<[
            boolean,
            BigNumber$1,
            BigNumber$1
        ] & {
            paused: boolean;
            pauseWindowEndTime: BigNumber$1;
            bufferPeriodEndTime: BigNumber$1;
        }>;
        getPoolId(overrides?: CallOverrides): Promise<string>;
        getProtocolFeesCollector(overrides?: CallOverrides): Promise<string>;
        getRate(overrides?: CallOverrides): Promise<BigNumber$1>;
        getScalingFactors(overrides?: CallOverrides): Promise<BigNumber$1[]>;
        getSwapFeePercentage(overrides?: CallOverrides): Promise<BigNumber$1>;
        getTargets(overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1
        ] & {
            lowerTarget: BigNumber$1;
            upperTarget: BigNumber$1;
        }>;
        getVault(overrides?: CallOverrides): Promise<string>;
        getVirtualSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
        getWrappedIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
        getWrappedToken(overrides?: CallOverrides): Promise<string>;
        getWrappedTokenRate(overrides?: CallOverrides): Promise<BigNumber$1>;
        inRecoveryMode(overrides?: CallOverrides): Promise<boolean>;
        increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        initialize(overrides?: CallOverrides): Promise<void>;
        name(overrides?: CallOverrides): Promise<string>;
        nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[
            BigNumber$1[],
            BigNumber$1[]
        ] & {
            amountsOut: BigNumber$1[];
            dueProtocolFees: BigNumber$1[];
        }>;
        onJoinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[
            BigNumber$1[],
            BigNumber$1[]
        ] & {
            amountsIn: BigNumber$1[];
            dueProtocolFees: BigNumber$1[];
        }>;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)"(request: IPoolSwapStructs$8.SwapRequestStruct, balances: PromiseOrValue<BigNumberish$1>[], indexIn: PromiseOrValue<BigNumberish$1>, indexOut: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)"(request: IPoolSwapStructs$8.SwapRequestStruct, balanceTokenIn: PromiseOrValue<BigNumberish$1>, balanceTokenOut: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        pause(overrides?: CallOverrides): Promise<void>;
        permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<void>;
        queryExit(arg0: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1[]
        ] & {
            bptIn: BigNumber$1;
            amountsOut: BigNumber$1[];
        }>;
        queryJoin(arg0: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1[]
        ] & {
            bptOut: BigNumber$1;
            amountsIn: BigNumber$1[];
        }>;
        setSwapFeePercentage(swapFeePercentage: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        setTargets(newLowerTarget: PromiseOrValue<BigNumberish$1>, newUpperTarget: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        symbol(overrides?: CallOverrides): Promise<string>;
        totalSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
        transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        unpause(overrides?: CallOverrides): Promise<void>;
        version(overrides?: CallOverrides): Promise<string>;
    };
    filters: {
        "Approval(address,address,uint256)"(owner?: PromiseOrValue<string> | null, spender?: PromiseOrValue<string> | null, value?: null): ApprovalEventFilter$9;
        Approval(owner?: PromiseOrValue<string> | null, spender?: PromiseOrValue<string> | null, value?: null): ApprovalEventFilter$9;
        "PausedStateChanged(bool)"(paused?: null): PausedStateChangedEventFilter$8;
        PausedStateChanged(paused?: null): PausedStateChangedEventFilter$8;
        "RecoveryModeStateChanged(bool)"(enabled?: null): RecoveryModeStateChangedEventFilter$4;
        RecoveryModeStateChanged(enabled?: null): RecoveryModeStateChangedEventFilter$4;
        "SwapFeePercentageChanged(uint256)"(swapFeePercentage?: null): SwapFeePercentageChangedEventFilter$7;
        SwapFeePercentageChanged(swapFeePercentage?: null): SwapFeePercentageChangedEventFilter$7;
        "TargetsSet(address,uint256,uint256)"(token?: PromiseOrValue<string> | null, lowerTarget?: null, upperTarget?: null): TargetsSetEventFilter$4;
        TargetsSet(token?: PromiseOrValue<string> | null, lowerTarget?: null, upperTarget?: null): TargetsSetEventFilter$4;
        "Transfer(address,address,uint256)"(from?: PromiseOrValue<string> | null, to?: PromiseOrValue<string> | null, value?: null): TransferEventFilter$9;
        Transfer(from?: PromiseOrValue<string> | null, to?: PromiseOrValue<string> | null, value?: null): TransferEventFilter$9;
    };
    estimateGas: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<BigNumber$1>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        decimals(overrides?: CallOverrides): Promise<BigNumber$1>;
        decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        disableRecoveryMode(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        enableRecoveryMode(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getAuthorizer(overrides?: CallOverrides): Promise<BigNumber$1>;
        getBptIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
        getDomainSeparator(overrides?: CallOverrides): Promise<BigNumber$1>;
        getMainIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
        getMainToken(overrides?: CallOverrides): Promise<BigNumber$1>;
        getNextNonce(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getOwner(overrides?: CallOverrides): Promise<BigNumber$1>;
        getPausedState(overrides?: CallOverrides): Promise<BigNumber$1>;
        getPoolId(overrides?: CallOverrides): Promise<BigNumber$1>;
        getProtocolFeesCollector(overrides?: CallOverrides): Promise<BigNumber$1>;
        getRate(overrides?: CallOverrides): Promise<BigNumber$1>;
        getScalingFactors(overrides?: CallOverrides): Promise<BigNumber$1>;
        getSwapFeePercentage(overrides?: CallOverrides): Promise<BigNumber$1>;
        getTargets(overrides?: CallOverrides): Promise<BigNumber$1>;
        getVault(overrides?: CallOverrides): Promise<BigNumber$1>;
        getVirtualSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
        getWrappedIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
        getWrappedToken(overrides?: CallOverrides): Promise<BigNumber$1>;
        getWrappedTokenRate(overrides?: CallOverrides): Promise<BigNumber$1>;
        inRecoveryMode(overrides?: CallOverrides): Promise<BigNumber$1>;
        increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        initialize(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        name(overrides?: CallOverrides): Promise<BigNumber$1>;
        nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        onJoinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)"(request: IPoolSwapStructs$8.SwapRequestStruct, balances: PromiseOrValue<BigNumberish$1>[], indexIn: PromiseOrValue<BigNumberish$1>, indexOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)"(request: IPoolSwapStructs$8.SwapRequestStruct, balanceTokenIn: PromiseOrValue<BigNumberish$1>, balanceTokenOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        pause(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        queryExit(arg0: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        queryJoin(arg0: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        setSwapFeePercentage(swapFeePercentage: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        setTargets(newLowerTarget: PromiseOrValue<BigNumberish$1>, newUpperTarget: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        symbol(overrides?: CallOverrides): Promise<BigNumber$1>;
        totalSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
        transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        unpause(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        version(overrides?: CallOverrides): Promise<BigNumber$1>;
    };
    populateTransaction: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        decimals(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        disableRecoveryMode(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        enableRecoveryMode(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getAuthorizer(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getBptIndex(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getDomainSeparator(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getMainIndex(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getMainToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getNextNonce(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getOwner(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getPausedState(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getPoolId(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getProtocolFeesCollector(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getRate(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getScalingFactors(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getSwapFeePercentage(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getTargets(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getVault(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getVirtualSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getWrappedIndex(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getWrappedToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getWrappedTokenRate(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        inRecoveryMode(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        initialize(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        name(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        onJoinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)"(request: IPoolSwapStructs$8.SwapRequestStruct, balances: PromiseOrValue<BigNumberish$1>[], indexIn: PromiseOrValue<BigNumberish$1>, indexOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)"(request: IPoolSwapStructs$8.SwapRequestStruct, balanceTokenIn: PromiseOrValue<BigNumberish$1>, balanceTokenOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        pause(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        queryExit(arg0: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        queryJoin(arg0: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setSwapFeePercentage(swapFeePercentage: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setTargets(newLowerTarget: PromiseOrValue<BigNumberish$1>, newUpperTarget: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        symbol(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        totalSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        unpause(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        version(overrides?: CallOverrides): Promise<PopulatedTransaction>;
    };
}

interface ERC4626LinearPoolFactoryInterface extends utils.Interface {
    functions: {
        "create(string,string,address,address,uint256,uint256,address,uint256,bytes32)": FunctionFragment;
        "disable()": FunctionFragment;
        "getActionId(bytes4)": FunctionFragment;
        "getAuthorizer()": FunctionFragment;
        "getCreationCode()": FunctionFragment;
        "getCreationCodeContracts()": FunctionFragment;
        "getLastCreatedPool()": FunctionFragment;
        "getPauseConfiguration()": FunctionFragment;
        "getPoolVersion()": FunctionFragment;
        "getProtocolFeePercentagesProvider()": FunctionFragment;
        "getVault()": FunctionFragment;
        "isDisabled()": FunctionFragment;
        "isPoolFromFactory(address)": FunctionFragment;
        "version()": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "create" | "disable" | "getActionId" | "getAuthorizer" | "getCreationCode" | "getCreationCodeContracts" | "getLastCreatedPool" | "getPauseConfiguration" | "getPoolVersion" | "getProtocolFeePercentagesProvider" | "getVault" | "isDisabled" | "isPoolFromFactory" | "version"): FunctionFragment;
    encodeFunctionData(functionFragment: "create", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "disable", values?: undefined): string;
    encodeFunctionData(functionFragment: "getActionId", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "getAuthorizer", values?: undefined): string;
    encodeFunctionData(functionFragment: "getCreationCode", values?: undefined): string;
    encodeFunctionData(functionFragment: "getCreationCodeContracts", values?: undefined): string;
    encodeFunctionData(functionFragment: "getLastCreatedPool", values?: undefined): string;
    encodeFunctionData(functionFragment: "getPauseConfiguration", values?: undefined): string;
    encodeFunctionData(functionFragment: "getPoolVersion", values?: undefined): string;
    encodeFunctionData(functionFragment: "getProtocolFeePercentagesProvider", values?: undefined): string;
    encodeFunctionData(functionFragment: "getVault", values?: undefined): string;
    encodeFunctionData(functionFragment: "isDisabled", values?: undefined): string;
    encodeFunctionData(functionFragment: "isPoolFromFactory", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "version", values?: undefined): string;
    decodeFunctionResult(functionFragment: "create", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "disable", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getActionId", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getAuthorizer", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getCreationCode", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getCreationCodeContracts", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getLastCreatedPool", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getPauseConfiguration", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getPoolVersion", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getProtocolFeePercentagesProvider", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getVault", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isDisabled", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isPoolFromFactory", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "version", data: BytesLike): Result;
    events: {
        "Erc4626LinearPoolCreated(address,uint256)": EventFragment;
        "FactoryDisabled()": EventFragment;
        "PoolCreated(address)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "Erc4626LinearPoolCreated"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "FactoryDisabled"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "PoolCreated"): EventFragment;
}
interface Erc4626LinearPoolCreatedEventObject {
    pool: string;
    protocolId: BigNumber$1;
}
type Erc4626LinearPoolCreatedEvent = TypedEvent<[
    string,
    BigNumber$1
], Erc4626LinearPoolCreatedEventObject>;
type Erc4626LinearPoolCreatedEventFilter = TypedEventFilter<Erc4626LinearPoolCreatedEvent>;
interface FactoryDisabledEventObject$4 {
}
type FactoryDisabledEvent$4 = TypedEvent<[], FactoryDisabledEventObject$4>;
type FactoryDisabledEventFilter$4 = TypedEventFilter<FactoryDisabledEvent$4>;
interface PoolCreatedEventObject$4 {
    pool: string;
}
type PoolCreatedEvent$4 = TypedEvent<[string], PoolCreatedEventObject$4>;
type PoolCreatedEventFilter$4 = TypedEventFilter<PoolCreatedEvent$4>;
interface ERC4626LinearPoolFactory extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: ERC4626LinearPoolFactoryInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        create(name: PromiseOrValue<string>, symbol: PromiseOrValue<string>, mainToken: PromiseOrValue<string>, wrappedToken: PromiseOrValue<string>, upperTarget: PromiseOrValue<BigNumberish$1>, swapFeePercentage: PromiseOrValue<BigNumberish$1>, owner: PromiseOrValue<string>, protocolId: PromiseOrValue<BigNumberish$1>, salt: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        disable(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[string]>;
        getAuthorizer(overrides?: CallOverrides): Promise<[string]>;
        getCreationCode(overrides?: CallOverrides): Promise<[string]>;
        getCreationCodeContracts(overrides?: CallOverrides): Promise<[string, string] & {
            contractA: string;
            contractB: string;
        }>;
        getLastCreatedPool(overrides?: CallOverrides): Promise<[string]>;
        getPauseConfiguration(overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1
        ] & {
            pauseWindowDuration: BigNumber$1;
            bufferPeriodDuration: BigNumber$1;
        }>;
        getPoolVersion(overrides?: CallOverrides): Promise<[string]>;
        getProtocolFeePercentagesProvider(overrides?: CallOverrides): Promise<[string]>;
        getVault(overrides?: CallOverrides): Promise<[string]>;
        isDisabled(overrides?: CallOverrides): Promise<[boolean]>;
        isPoolFromFactory(pool: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;
        version(overrides?: CallOverrides): Promise<[string]>;
    };
    create(name: PromiseOrValue<string>, symbol: PromiseOrValue<string>, mainToken: PromiseOrValue<string>, wrappedToken: PromiseOrValue<string>, upperTarget: PromiseOrValue<BigNumberish$1>, swapFeePercentage: PromiseOrValue<BigNumberish$1>, owner: PromiseOrValue<string>, protocolId: PromiseOrValue<BigNumberish$1>, salt: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    disable(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
    getAuthorizer(overrides?: CallOverrides): Promise<string>;
    getCreationCode(overrides?: CallOverrides): Promise<string>;
    getCreationCodeContracts(overrides?: CallOverrides): Promise<[string, string] & {
        contractA: string;
        contractB: string;
    }>;
    getLastCreatedPool(overrides?: CallOverrides): Promise<string>;
    getPauseConfiguration(overrides?: CallOverrides): Promise<[
        BigNumber$1,
        BigNumber$1
    ] & {
        pauseWindowDuration: BigNumber$1;
        bufferPeriodDuration: BigNumber$1;
    }>;
    getPoolVersion(overrides?: CallOverrides): Promise<string>;
    getProtocolFeePercentagesProvider(overrides?: CallOverrides): Promise<string>;
    getVault(overrides?: CallOverrides): Promise<string>;
    isDisabled(overrides?: CallOverrides): Promise<boolean>;
    isPoolFromFactory(pool: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
    version(overrides?: CallOverrides): Promise<string>;
    callStatic: {
        create(name: PromiseOrValue<string>, symbol: PromiseOrValue<string>, mainToken: PromiseOrValue<string>, wrappedToken: PromiseOrValue<string>, upperTarget: PromiseOrValue<BigNumberish$1>, swapFeePercentage: PromiseOrValue<BigNumberish$1>, owner: PromiseOrValue<string>, protocolId: PromiseOrValue<BigNumberish$1>, salt: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
        disable(overrides?: CallOverrides): Promise<void>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
        getAuthorizer(overrides?: CallOverrides): Promise<string>;
        getCreationCode(overrides?: CallOverrides): Promise<string>;
        getCreationCodeContracts(overrides?: CallOverrides): Promise<[string, string] & {
            contractA: string;
            contractB: string;
        }>;
        getLastCreatedPool(overrides?: CallOverrides): Promise<string>;
        getPauseConfiguration(overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1
        ] & {
            pauseWindowDuration: BigNumber$1;
            bufferPeriodDuration: BigNumber$1;
        }>;
        getPoolVersion(overrides?: CallOverrides): Promise<string>;
        getProtocolFeePercentagesProvider(overrides?: CallOverrides): Promise<string>;
        getVault(overrides?: CallOverrides): Promise<string>;
        isDisabled(overrides?: CallOverrides): Promise<boolean>;
        isPoolFromFactory(pool: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
        version(overrides?: CallOverrides): Promise<string>;
    };
    filters: {
        "Erc4626LinearPoolCreated(address,uint256)"(pool?: PromiseOrValue<string> | null, protocolId?: PromiseOrValue<BigNumberish$1> | null): Erc4626LinearPoolCreatedEventFilter;
        Erc4626LinearPoolCreated(pool?: PromiseOrValue<string> | null, protocolId?: PromiseOrValue<BigNumberish$1> | null): Erc4626LinearPoolCreatedEventFilter;
        "FactoryDisabled()"(): FactoryDisabledEventFilter$4;
        FactoryDisabled(): FactoryDisabledEventFilter$4;
        "PoolCreated(address)"(pool?: PromiseOrValue<string> | null): PoolCreatedEventFilter$4;
        PoolCreated(pool?: PromiseOrValue<string> | null): PoolCreatedEventFilter$4;
    };
    estimateGas: {
        create(name: PromiseOrValue<string>, symbol: PromiseOrValue<string>, mainToken: PromiseOrValue<string>, wrappedToken: PromiseOrValue<string>, upperTarget: PromiseOrValue<BigNumberish$1>, swapFeePercentage: PromiseOrValue<BigNumberish$1>, owner: PromiseOrValue<string>, protocolId: PromiseOrValue<BigNumberish$1>, salt: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        disable(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getAuthorizer(overrides?: CallOverrides): Promise<BigNumber$1>;
        getCreationCode(overrides?: CallOverrides): Promise<BigNumber$1>;
        getCreationCodeContracts(overrides?: CallOverrides): Promise<BigNumber$1>;
        getLastCreatedPool(overrides?: CallOverrides): Promise<BigNumber$1>;
        getPauseConfiguration(overrides?: CallOverrides): Promise<BigNumber$1>;
        getPoolVersion(overrides?: CallOverrides): Promise<BigNumber$1>;
        getProtocolFeePercentagesProvider(overrides?: CallOverrides): Promise<BigNumber$1>;
        getVault(overrides?: CallOverrides): Promise<BigNumber$1>;
        isDisabled(overrides?: CallOverrides): Promise<BigNumber$1>;
        isPoolFromFactory(pool: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        version(overrides?: CallOverrides): Promise<BigNumber$1>;
    };
    populateTransaction: {
        create(name: PromiseOrValue<string>, symbol: PromiseOrValue<string>, mainToken: PromiseOrValue<string>, wrappedToken: PromiseOrValue<string>, upperTarget: PromiseOrValue<BigNumberish$1>, swapFeePercentage: PromiseOrValue<BigNumberish$1>, owner: PromiseOrValue<string>, protocolId: PromiseOrValue<BigNumberish$1>, salt: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        disable(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getAuthorizer(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getCreationCode(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getCreationCodeContracts(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getLastCreatedPool(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getPauseConfiguration(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getPoolVersion(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getProtocolFeePercentagesProvider(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getVault(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        isDisabled(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        isPoolFromFactory(pool: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        version(overrides?: CallOverrides): Promise<PopulatedTransaction>;
    };
}

declare namespace IPoolSwapStructs$7 {
    type SwapRequestStruct = {
        kind: PromiseOrValue<BigNumberish$1>;
        tokenIn: PromiseOrValue<string>;
        tokenOut: PromiseOrValue<string>;
        amount: PromiseOrValue<BigNumberish$1>;
        poolId: PromiseOrValue<BytesLike>;
        lastChangeBlock: PromiseOrValue<BigNumberish$1>;
        from: PromiseOrValue<string>;
        to: PromiseOrValue<string>;
        userData: PromiseOrValue<BytesLike>;
    };
    type SwapRequestStructOutput = [
        number,
        string,
        string,
        BigNumber$1,
        string,
        BigNumber$1,
        string,
        string,
        string
    ] & {
        kind: number;
        tokenIn: string;
        tokenOut: string;
        amount: BigNumber$1;
        poolId: string;
        lastChangeBlock: BigNumber$1;
        from: string;
        to: string;
        userData: string;
    };
}
interface EulerLinearPoolInterface extends utils.Interface {
    functions: {
        "DOMAIN_SEPARATOR()": FunctionFragment;
        "allowance(address,address)": FunctionFragment;
        "approve(address,uint256)": FunctionFragment;
        "balanceOf(address)": FunctionFragment;
        "decimals()": FunctionFragment;
        "decreaseAllowance(address,uint256)": FunctionFragment;
        "disableRecoveryMode()": FunctionFragment;
        "enableRecoveryMode()": FunctionFragment;
        "getActionId(bytes4)": FunctionFragment;
        "getAuthorizer()": FunctionFragment;
        "getBptIndex()": FunctionFragment;
        "getDomainSeparator()": FunctionFragment;
        "getMainIndex()": FunctionFragment;
        "getMainToken()": FunctionFragment;
        "getNextNonce(address)": FunctionFragment;
        "getOwner()": FunctionFragment;
        "getPausedState()": FunctionFragment;
        "getPoolId()": FunctionFragment;
        "getProtocolFeesCollector()": FunctionFragment;
        "getRate()": FunctionFragment;
        "getScalingFactors()": FunctionFragment;
        "getSwapFeePercentage()": FunctionFragment;
        "getTargets()": FunctionFragment;
        "getVault()": FunctionFragment;
        "getVirtualSupply()": FunctionFragment;
        "getWrappedIndex()": FunctionFragment;
        "getWrappedToken()": FunctionFragment;
        "getWrappedTokenRate()": FunctionFragment;
        "inRecoveryMode()": FunctionFragment;
        "increaseAllowance(address,uint256)": FunctionFragment;
        "initialize()": FunctionFragment;
        "name()": FunctionFragment;
        "nonces(address)": FunctionFragment;
        "onExitPool(bytes32,address,address,uint256[],uint256,uint256,bytes)": FunctionFragment;
        "onJoinPool(bytes32,address,address,uint256[],uint256,uint256,bytes)": FunctionFragment;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)": FunctionFragment;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)": FunctionFragment;
        "pause()": FunctionFragment;
        "permit(address,address,uint256,uint256,uint8,bytes32,bytes32)": FunctionFragment;
        "queryExit(bytes32,address,address,uint256[],uint256,uint256,bytes)": FunctionFragment;
        "queryJoin(bytes32,address,address,uint256[],uint256,uint256,bytes)": FunctionFragment;
        "setSwapFeePercentage(uint256)": FunctionFragment;
        "setTargets(uint256,uint256)": FunctionFragment;
        "symbol()": FunctionFragment;
        "totalSupply()": FunctionFragment;
        "transfer(address,uint256)": FunctionFragment;
        "transferFrom(address,address,uint256)": FunctionFragment;
        "unpause()": FunctionFragment;
        "version()": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "DOMAIN_SEPARATOR" | "allowance" | "approve" | "balanceOf" | "decimals" | "decreaseAllowance" | "disableRecoveryMode" | "enableRecoveryMode" | "getActionId" | "getAuthorizer" | "getBptIndex" | "getDomainSeparator" | "getMainIndex" | "getMainToken" | "getNextNonce" | "getOwner" | "getPausedState" | "getPoolId" | "getProtocolFeesCollector" | "getRate" | "getScalingFactors" | "getSwapFeePercentage" | "getTargets" | "getVault" | "getVirtualSupply" | "getWrappedIndex" | "getWrappedToken" | "getWrappedTokenRate" | "inRecoveryMode" | "increaseAllowance" | "initialize" | "name" | "nonces" | "onExitPool" | "onJoinPool" | "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)" | "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)" | "pause" | "permit" | "queryExit" | "queryJoin" | "setSwapFeePercentage" | "setTargets" | "symbol" | "totalSupply" | "transfer" | "transferFrom" | "unpause" | "version"): FunctionFragment;
    encodeFunctionData(functionFragment: "DOMAIN_SEPARATOR", values?: undefined): string;
    encodeFunctionData(functionFragment: "allowance", values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "approve", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "balanceOf", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "decimals", values?: undefined): string;
    encodeFunctionData(functionFragment: "decreaseAllowance", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "disableRecoveryMode", values?: undefined): string;
    encodeFunctionData(functionFragment: "enableRecoveryMode", values?: undefined): string;
    encodeFunctionData(functionFragment: "getActionId", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "getAuthorizer", values?: undefined): string;
    encodeFunctionData(functionFragment: "getBptIndex", values?: undefined): string;
    encodeFunctionData(functionFragment: "getDomainSeparator", values?: undefined): string;
    encodeFunctionData(functionFragment: "getMainIndex", values?: undefined): string;
    encodeFunctionData(functionFragment: "getMainToken", values?: undefined): string;
    encodeFunctionData(functionFragment: "getNextNonce", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "getOwner", values?: undefined): string;
    encodeFunctionData(functionFragment: "getPausedState", values?: undefined): string;
    encodeFunctionData(functionFragment: "getPoolId", values?: undefined): string;
    encodeFunctionData(functionFragment: "getProtocolFeesCollector", values?: undefined): string;
    encodeFunctionData(functionFragment: "getRate", values?: undefined): string;
    encodeFunctionData(functionFragment: "getScalingFactors", values?: undefined): string;
    encodeFunctionData(functionFragment: "getSwapFeePercentage", values?: undefined): string;
    encodeFunctionData(functionFragment: "getTargets", values?: undefined): string;
    encodeFunctionData(functionFragment: "getVault", values?: undefined): string;
    encodeFunctionData(functionFragment: "getVirtualSupply", values?: undefined): string;
    encodeFunctionData(functionFragment: "getWrappedIndex", values?: undefined): string;
    encodeFunctionData(functionFragment: "getWrappedToken", values?: undefined): string;
    encodeFunctionData(functionFragment: "getWrappedTokenRate", values?: undefined): string;
    encodeFunctionData(functionFragment: "inRecoveryMode", values?: undefined): string;
    encodeFunctionData(functionFragment: "increaseAllowance", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "initialize", values?: undefined): string;
    encodeFunctionData(functionFragment: "name", values?: undefined): string;
    encodeFunctionData(functionFragment: "nonces", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "onExitPool", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "onJoinPool", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)", values: [
        IPoolSwapStructs$7.SwapRequestStruct,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)", values: [
        IPoolSwapStructs$7.SwapRequestStruct,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "pause", values?: undefined): string;
    encodeFunctionData(functionFragment: "permit", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "queryExit", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "queryJoin", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "setSwapFeePercentage", values: [PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "setTargets", values: [PromiseOrValue<BigNumberish$1>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "symbol", values?: undefined): string;
    encodeFunctionData(functionFragment: "totalSupply", values?: undefined): string;
    encodeFunctionData(functionFragment: "transfer", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "transferFrom", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "unpause", values?: undefined): string;
    encodeFunctionData(functionFragment: "version", values?: undefined): string;
    decodeFunctionResult(functionFragment: "DOMAIN_SEPARATOR", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "allowance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "approve", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "balanceOf", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "decimals", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "decreaseAllowance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "disableRecoveryMode", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "enableRecoveryMode", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getActionId", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getAuthorizer", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getBptIndex", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getDomainSeparator", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getMainIndex", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getMainToken", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getNextNonce", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getOwner", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getPausedState", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getPoolId", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getProtocolFeesCollector", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getRate", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getScalingFactors", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getSwapFeePercentage", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getTargets", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getVault", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getVirtualSupply", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getWrappedIndex", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getWrappedToken", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getWrappedTokenRate", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "inRecoveryMode", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "increaseAllowance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "name", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "nonces", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "onExitPool", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "onJoinPool", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "pause", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "permit", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "queryExit", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "queryJoin", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setSwapFeePercentage", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setTargets", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "symbol", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "totalSupply", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "transfer", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "transferFrom", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "unpause", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "version", data: BytesLike): Result;
    events: {
        "Approval(address,address,uint256)": EventFragment;
        "PausedStateChanged(bool)": EventFragment;
        "RecoveryModeStateChanged(bool)": EventFragment;
        "SwapFeePercentageChanged(uint256)": EventFragment;
        "TargetsSet(address,uint256,uint256)": EventFragment;
        "Transfer(address,address,uint256)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "Approval"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "PausedStateChanged"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "RecoveryModeStateChanged"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "SwapFeePercentageChanged"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "TargetsSet"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Transfer"): EventFragment;
}
interface ApprovalEventObject$8 {
    owner: string;
    spender: string;
    value: BigNumber$1;
}
type ApprovalEvent$8 = TypedEvent<[
    string,
    string,
    BigNumber$1
], ApprovalEventObject$8>;
type ApprovalEventFilter$8 = TypedEventFilter<ApprovalEvent$8>;
interface PausedStateChangedEventObject$7 {
    paused: boolean;
}
type PausedStateChangedEvent$7 = TypedEvent<[
    boolean
], PausedStateChangedEventObject$7>;
type PausedStateChangedEventFilter$7 = TypedEventFilter<PausedStateChangedEvent$7>;
interface RecoveryModeStateChangedEventObject$3 {
    enabled: boolean;
}
type RecoveryModeStateChangedEvent$3 = TypedEvent<[
    boolean
], RecoveryModeStateChangedEventObject$3>;
type RecoveryModeStateChangedEventFilter$3 = TypedEventFilter<RecoveryModeStateChangedEvent$3>;
interface SwapFeePercentageChangedEventObject$6 {
    swapFeePercentage: BigNumber$1;
}
type SwapFeePercentageChangedEvent$6 = TypedEvent<[
    BigNumber$1
], SwapFeePercentageChangedEventObject$6>;
type SwapFeePercentageChangedEventFilter$6 = TypedEventFilter<SwapFeePercentageChangedEvent$6>;
interface TargetsSetEventObject$3 {
    token: string;
    lowerTarget: BigNumber$1;
    upperTarget: BigNumber$1;
}
type TargetsSetEvent$3 = TypedEvent<[
    string,
    BigNumber$1,
    BigNumber$1
], TargetsSetEventObject$3>;
type TargetsSetEventFilter$3 = TypedEventFilter<TargetsSetEvent$3>;
interface TransferEventObject$8 {
    from: string;
    to: string;
    value: BigNumber$1;
}
type TransferEvent$8 = TypedEvent<[
    string,
    string,
    BigNumber$1
], TransferEventObject$8>;
type TransferEventFilter$8 = TypedEventFilter<TransferEvent$8>;
declare namespace EulerLinearPool {
    type ConstructorArgsStruct = {
        vault: PromiseOrValue<string>;
        name: PromiseOrValue<string>;
        symbol: PromiseOrValue<string>;
        mainToken: PromiseOrValue<string>;
        wrappedToken: PromiseOrValue<string>;
        assetManager: PromiseOrValue<string>;
        upperTarget: PromiseOrValue<BigNumberish$1>;
        swapFeePercentage: PromiseOrValue<BigNumberish$1>;
        pauseWindowDuration: PromiseOrValue<BigNumberish$1>;
        bufferPeriodDuration: PromiseOrValue<BigNumberish$1>;
        owner: PromiseOrValue<string>;
        version: PromiseOrValue<string>;
    };
    type ConstructorArgsStructOutput = [
        string,
        string,
        string,
        string,
        string,
        string,
        BigNumber$1,
        BigNumber$1,
        BigNumber$1,
        BigNumber$1,
        string,
        string
    ] & {
        vault: string;
        name: string;
        symbol: string;
        mainToken: string;
        wrappedToken: string;
        assetManager: string;
        upperTarget: BigNumber$1;
        swapFeePercentage: BigNumber$1;
        pauseWindowDuration: BigNumber$1;
        bufferPeriodDuration: BigNumber$1;
        owner: string;
        version: string;
    };
}
interface EulerLinearPool extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: EulerLinearPoolInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<[string]>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        decimals(overrides?: CallOverrides): Promise<[number]>;
        decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        disableRecoveryMode(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        enableRecoveryMode(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[string]>;
        getAuthorizer(overrides?: CallOverrides): Promise<[string]>;
        getBptIndex(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getDomainSeparator(overrides?: CallOverrides): Promise<[string]>;
        getMainIndex(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getMainToken(overrides?: CallOverrides): Promise<[string]>;
        getNextNonce(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getOwner(overrides?: CallOverrides): Promise<[string]>;
        getPausedState(overrides?: CallOverrides): Promise<[
            boolean,
            BigNumber$1,
            BigNumber$1
        ] & {
            paused: boolean;
            pauseWindowEndTime: BigNumber$1;
            bufferPeriodEndTime: BigNumber$1;
        }>;
        getPoolId(overrides?: CallOverrides): Promise<[string]>;
        getProtocolFeesCollector(overrides?: CallOverrides): Promise<[string]>;
        getRate(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getScalingFactors(overrides?: CallOverrides): Promise<[BigNumber$1[]]>;
        getSwapFeePercentage(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getTargets(overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1
        ] & {
            lowerTarget: BigNumber$1;
            upperTarget: BigNumber$1;
        }>;
        getVault(overrides?: CallOverrides): Promise<[string]>;
        getVirtualSupply(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getWrappedIndex(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getWrappedToken(overrides?: CallOverrides): Promise<[string]>;
        getWrappedTokenRate(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        inRecoveryMode(overrides?: CallOverrides): Promise<[boolean]>;
        increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        initialize(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        name(overrides?: CallOverrides): Promise<[string]>;
        nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        onJoinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)"(request: IPoolSwapStructs$7.SwapRequestStruct, balances: PromiseOrValue<BigNumberish$1>[], indexIn: PromiseOrValue<BigNumberish$1>, indexOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)"(request: IPoolSwapStructs$7.SwapRequestStruct, balanceTokenIn: PromiseOrValue<BigNumberish$1>, balanceTokenOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        pause(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        queryExit(arg0: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        queryJoin(arg0: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setSwapFeePercentage(swapFeePercentage: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setTargets(newLowerTarget: PromiseOrValue<BigNumberish$1>, newUpperTarget: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        symbol(overrides?: CallOverrides): Promise<[string]>;
        totalSupply(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        unpause(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        version(overrides?: CallOverrides): Promise<[string]>;
    };
    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;
    allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    decimals(overrides?: CallOverrides): Promise<number>;
    decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    disableRecoveryMode(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    enableRecoveryMode(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
    getAuthorizer(overrides?: CallOverrides): Promise<string>;
    getBptIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
    getDomainSeparator(overrides?: CallOverrides): Promise<string>;
    getMainIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
    getMainToken(overrides?: CallOverrides): Promise<string>;
    getNextNonce(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    getOwner(overrides?: CallOverrides): Promise<string>;
    getPausedState(overrides?: CallOverrides): Promise<[
        boolean,
        BigNumber$1,
        BigNumber$1
    ] & {
        paused: boolean;
        pauseWindowEndTime: BigNumber$1;
        bufferPeriodEndTime: BigNumber$1;
    }>;
    getPoolId(overrides?: CallOverrides): Promise<string>;
    getProtocolFeesCollector(overrides?: CallOverrides): Promise<string>;
    getRate(overrides?: CallOverrides): Promise<BigNumber$1>;
    getScalingFactors(overrides?: CallOverrides): Promise<BigNumber$1[]>;
    getSwapFeePercentage(overrides?: CallOverrides): Promise<BigNumber$1>;
    getTargets(overrides?: CallOverrides): Promise<[
        BigNumber$1,
        BigNumber$1
    ] & {
        lowerTarget: BigNumber$1;
        upperTarget: BigNumber$1;
    }>;
    getVault(overrides?: CallOverrides): Promise<string>;
    getVirtualSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
    getWrappedIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
    getWrappedToken(overrides?: CallOverrides): Promise<string>;
    getWrappedTokenRate(overrides?: CallOverrides): Promise<BigNumber$1>;
    inRecoveryMode(overrides?: CallOverrides): Promise<boolean>;
    increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    initialize(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    name(overrides?: CallOverrides): Promise<string>;
    nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    onJoinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)"(request: IPoolSwapStructs$7.SwapRequestStruct, balances: PromiseOrValue<BigNumberish$1>[], indexIn: PromiseOrValue<BigNumberish$1>, indexOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)"(request: IPoolSwapStructs$7.SwapRequestStruct, balanceTokenIn: PromiseOrValue<BigNumberish$1>, balanceTokenOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    pause(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    queryExit(arg0: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    queryJoin(arg0: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setSwapFeePercentage(swapFeePercentage: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setTargets(newLowerTarget: PromiseOrValue<BigNumberish$1>, newUpperTarget: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    symbol(overrides?: CallOverrides): Promise<string>;
    totalSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
    transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    unpause(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    version(overrides?: CallOverrides): Promise<string>;
    callStatic: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        decimals(overrides?: CallOverrides): Promise<number>;
        decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        disableRecoveryMode(overrides?: CallOverrides): Promise<void>;
        enableRecoveryMode(overrides?: CallOverrides): Promise<void>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
        getAuthorizer(overrides?: CallOverrides): Promise<string>;
        getBptIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
        getDomainSeparator(overrides?: CallOverrides): Promise<string>;
        getMainIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
        getMainToken(overrides?: CallOverrides): Promise<string>;
        getNextNonce(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getOwner(overrides?: CallOverrides): Promise<string>;
        getPausedState(overrides?: CallOverrides): Promise<[
            boolean,
            BigNumber$1,
            BigNumber$1
        ] & {
            paused: boolean;
            pauseWindowEndTime: BigNumber$1;
            bufferPeriodEndTime: BigNumber$1;
        }>;
        getPoolId(overrides?: CallOverrides): Promise<string>;
        getProtocolFeesCollector(overrides?: CallOverrides): Promise<string>;
        getRate(overrides?: CallOverrides): Promise<BigNumber$1>;
        getScalingFactors(overrides?: CallOverrides): Promise<BigNumber$1[]>;
        getSwapFeePercentage(overrides?: CallOverrides): Promise<BigNumber$1>;
        getTargets(overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1
        ] & {
            lowerTarget: BigNumber$1;
            upperTarget: BigNumber$1;
        }>;
        getVault(overrides?: CallOverrides): Promise<string>;
        getVirtualSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
        getWrappedIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
        getWrappedToken(overrides?: CallOverrides): Promise<string>;
        getWrappedTokenRate(overrides?: CallOverrides): Promise<BigNumber$1>;
        inRecoveryMode(overrides?: CallOverrides): Promise<boolean>;
        increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        initialize(overrides?: CallOverrides): Promise<void>;
        name(overrides?: CallOverrides): Promise<string>;
        nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[
            BigNumber$1[],
            BigNumber$1[]
        ] & {
            amountsOut: BigNumber$1[];
            dueProtocolFees: BigNumber$1[];
        }>;
        onJoinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[
            BigNumber$1[],
            BigNumber$1[]
        ] & {
            amountsIn: BigNumber$1[];
            dueProtocolFees: BigNumber$1[];
        }>;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)"(request: IPoolSwapStructs$7.SwapRequestStruct, balances: PromiseOrValue<BigNumberish$1>[], indexIn: PromiseOrValue<BigNumberish$1>, indexOut: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)"(request: IPoolSwapStructs$7.SwapRequestStruct, balanceTokenIn: PromiseOrValue<BigNumberish$1>, balanceTokenOut: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        pause(overrides?: CallOverrides): Promise<void>;
        permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<void>;
        queryExit(arg0: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1[]
        ] & {
            bptIn: BigNumber$1;
            amountsOut: BigNumber$1[];
        }>;
        queryJoin(arg0: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1[]
        ] & {
            bptOut: BigNumber$1;
            amountsIn: BigNumber$1[];
        }>;
        setSwapFeePercentage(swapFeePercentage: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        setTargets(newLowerTarget: PromiseOrValue<BigNumberish$1>, newUpperTarget: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        symbol(overrides?: CallOverrides): Promise<string>;
        totalSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
        transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        unpause(overrides?: CallOverrides): Promise<void>;
        version(overrides?: CallOverrides): Promise<string>;
    };
    filters: {
        "Approval(address,address,uint256)"(owner?: PromiseOrValue<string> | null, spender?: PromiseOrValue<string> | null, value?: null): ApprovalEventFilter$8;
        Approval(owner?: PromiseOrValue<string> | null, spender?: PromiseOrValue<string> | null, value?: null): ApprovalEventFilter$8;
        "PausedStateChanged(bool)"(paused?: null): PausedStateChangedEventFilter$7;
        PausedStateChanged(paused?: null): PausedStateChangedEventFilter$7;
        "RecoveryModeStateChanged(bool)"(enabled?: null): RecoveryModeStateChangedEventFilter$3;
        RecoveryModeStateChanged(enabled?: null): RecoveryModeStateChangedEventFilter$3;
        "SwapFeePercentageChanged(uint256)"(swapFeePercentage?: null): SwapFeePercentageChangedEventFilter$6;
        SwapFeePercentageChanged(swapFeePercentage?: null): SwapFeePercentageChangedEventFilter$6;
        "TargetsSet(address,uint256,uint256)"(token?: PromiseOrValue<string> | null, lowerTarget?: null, upperTarget?: null): TargetsSetEventFilter$3;
        TargetsSet(token?: PromiseOrValue<string> | null, lowerTarget?: null, upperTarget?: null): TargetsSetEventFilter$3;
        "Transfer(address,address,uint256)"(from?: PromiseOrValue<string> | null, to?: PromiseOrValue<string> | null, value?: null): TransferEventFilter$8;
        Transfer(from?: PromiseOrValue<string> | null, to?: PromiseOrValue<string> | null, value?: null): TransferEventFilter$8;
    };
    estimateGas: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<BigNumber$1>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        decimals(overrides?: CallOverrides): Promise<BigNumber$1>;
        decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        disableRecoveryMode(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        enableRecoveryMode(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getAuthorizer(overrides?: CallOverrides): Promise<BigNumber$1>;
        getBptIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
        getDomainSeparator(overrides?: CallOverrides): Promise<BigNumber$1>;
        getMainIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
        getMainToken(overrides?: CallOverrides): Promise<BigNumber$1>;
        getNextNonce(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getOwner(overrides?: CallOverrides): Promise<BigNumber$1>;
        getPausedState(overrides?: CallOverrides): Promise<BigNumber$1>;
        getPoolId(overrides?: CallOverrides): Promise<BigNumber$1>;
        getProtocolFeesCollector(overrides?: CallOverrides): Promise<BigNumber$1>;
        getRate(overrides?: CallOverrides): Promise<BigNumber$1>;
        getScalingFactors(overrides?: CallOverrides): Promise<BigNumber$1>;
        getSwapFeePercentage(overrides?: CallOverrides): Promise<BigNumber$1>;
        getTargets(overrides?: CallOverrides): Promise<BigNumber$1>;
        getVault(overrides?: CallOverrides): Promise<BigNumber$1>;
        getVirtualSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
        getWrappedIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
        getWrappedToken(overrides?: CallOverrides): Promise<BigNumber$1>;
        getWrappedTokenRate(overrides?: CallOverrides): Promise<BigNumber$1>;
        inRecoveryMode(overrides?: CallOverrides): Promise<BigNumber$1>;
        increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        initialize(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        name(overrides?: CallOverrides): Promise<BigNumber$1>;
        nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        onJoinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)"(request: IPoolSwapStructs$7.SwapRequestStruct, balances: PromiseOrValue<BigNumberish$1>[], indexIn: PromiseOrValue<BigNumberish$1>, indexOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)"(request: IPoolSwapStructs$7.SwapRequestStruct, balanceTokenIn: PromiseOrValue<BigNumberish$1>, balanceTokenOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        pause(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        queryExit(arg0: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        queryJoin(arg0: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        setSwapFeePercentage(swapFeePercentage: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        setTargets(newLowerTarget: PromiseOrValue<BigNumberish$1>, newUpperTarget: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        symbol(overrides?: CallOverrides): Promise<BigNumber$1>;
        totalSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
        transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        unpause(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        version(overrides?: CallOverrides): Promise<BigNumber$1>;
    };
    populateTransaction: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        decimals(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        disableRecoveryMode(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        enableRecoveryMode(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getAuthorizer(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getBptIndex(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getDomainSeparator(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getMainIndex(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getMainToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getNextNonce(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getOwner(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getPausedState(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getPoolId(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getProtocolFeesCollector(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getRate(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getScalingFactors(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getSwapFeePercentage(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getTargets(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getVault(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getVirtualSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getWrappedIndex(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getWrappedToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getWrappedTokenRate(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        inRecoveryMode(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        initialize(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        name(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        onJoinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)"(request: IPoolSwapStructs$7.SwapRequestStruct, balances: PromiseOrValue<BigNumberish$1>[], indexIn: PromiseOrValue<BigNumberish$1>, indexOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)"(request: IPoolSwapStructs$7.SwapRequestStruct, balanceTokenIn: PromiseOrValue<BigNumberish$1>, balanceTokenOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        pause(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        queryExit(arg0: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        queryJoin(arg0: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setSwapFeePercentage(swapFeePercentage: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setTargets(newLowerTarget: PromiseOrValue<BigNumberish$1>, newUpperTarget: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        symbol(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        totalSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        unpause(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        version(overrides?: CallOverrides): Promise<PopulatedTransaction>;
    };
}

interface EulerLinearPoolFactoryInterface extends utils.Interface {
    functions: {
        "create(string,string,address,address,uint256,uint256,address,uint256)": FunctionFragment;
        "disable()": FunctionFragment;
        "eulerProtocol()": FunctionFragment;
        "getActionId(bytes4)": FunctionFragment;
        "getAuthorizer()": FunctionFragment;
        "getCreationCode()": FunctionFragment;
        "getCreationCodeContracts()": FunctionFragment;
        "getLastCreatedPool()": FunctionFragment;
        "getPauseConfiguration()": FunctionFragment;
        "getPoolVersion()": FunctionFragment;
        "getProtocolFeePercentagesProvider()": FunctionFragment;
        "getVault()": FunctionFragment;
        "isDisabled()": FunctionFragment;
        "isPoolFromFactory(address)": FunctionFragment;
        "version()": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "create" | "disable" | "eulerProtocol" | "getActionId" | "getAuthorizer" | "getCreationCode" | "getCreationCodeContracts" | "getLastCreatedPool" | "getPauseConfiguration" | "getPoolVersion" | "getProtocolFeePercentagesProvider" | "getVault" | "isDisabled" | "isPoolFromFactory" | "version"): FunctionFragment;
    encodeFunctionData(functionFragment: "create", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "disable", values?: undefined): string;
    encodeFunctionData(functionFragment: "eulerProtocol", values?: undefined): string;
    encodeFunctionData(functionFragment: "getActionId", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "getAuthorizer", values?: undefined): string;
    encodeFunctionData(functionFragment: "getCreationCode", values?: undefined): string;
    encodeFunctionData(functionFragment: "getCreationCodeContracts", values?: undefined): string;
    encodeFunctionData(functionFragment: "getLastCreatedPool", values?: undefined): string;
    encodeFunctionData(functionFragment: "getPauseConfiguration", values?: undefined): string;
    encodeFunctionData(functionFragment: "getPoolVersion", values?: undefined): string;
    encodeFunctionData(functionFragment: "getProtocolFeePercentagesProvider", values?: undefined): string;
    encodeFunctionData(functionFragment: "getVault", values?: undefined): string;
    encodeFunctionData(functionFragment: "isDisabled", values?: undefined): string;
    encodeFunctionData(functionFragment: "isPoolFromFactory", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "version", values?: undefined): string;
    decodeFunctionResult(functionFragment: "create", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "disable", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "eulerProtocol", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getActionId", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getAuthorizer", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getCreationCode", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getCreationCodeContracts", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getLastCreatedPool", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getPauseConfiguration", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getPoolVersion", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getProtocolFeePercentagesProvider", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getVault", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isDisabled", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isPoolFromFactory", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "version", data: BytesLike): Result;
    events: {
        "EulerLinearPoolCreated(address,uint256)": EventFragment;
        "FactoryDisabled()": EventFragment;
        "PoolCreated(address)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "EulerLinearPoolCreated"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "FactoryDisabled"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "PoolCreated"): EventFragment;
}
interface EulerLinearPoolCreatedEventObject {
    pool: string;
    protocolId: BigNumber$1;
}
type EulerLinearPoolCreatedEvent = TypedEvent<[
    string,
    BigNumber$1
], EulerLinearPoolCreatedEventObject>;
type EulerLinearPoolCreatedEventFilter = TypedEventFilter<EulerLinearPoolCreatedEvent>;
interface FactoryDisabledEventObject$3 {
}
type FactoryDisabledEvent$3 = TypedEvent<[], FactoryDisabledEventObject$3>;
type FactoryDisabledEventFilter$3 = TypedEventFilter<FactoryDisabledEvent$3>;
interface PoolCreatedEventObject$3 {
    pool: string;
}
type PoolCreatedEvent$3 = TypedEvent<[string], PoolCreatedEventObject$3>;
type PoolCreatedEventFilter$3 = TypedEventFilter<PoolCreatedEvent$3>;
interface EulerLinearPoolFactory extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: EulerLinearPoolFactoryInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        create(name: PromiseOrValue<string>, symbol: PromiseOrValue<string>, mainToken: PromiseOrValue<string>, wrappedToken: PromiseOrValue<string>, upperTarget: PromiseOrValue<BigNumberish$1>, swapFeePercentage: PromiseOrValue<BigNumberish$1>, owner: PromiseOrValue<string>, protocolId: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        disable(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        eulerProtocol(overrides?: CallOverrides): Promise<[string]>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[string]>;
        getAuthorizer(overrides?: CallOverrides): Promise<[string]>;
        getCreationCode(overrides?: CallOverrides): Promise<[string]>;
        getCreationCodeContracts(overrides?: CallOverrides): Promise<[string, string] & {
            contractA: string;
            contractB: string;
        }>;
        getLastCreatedPool(overrides?: CallOverrides): Promise<[string]>;
        getPauseConfiguration(overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1
        ] & {
            pauseWindowDuration: BigNumber$1;
            bufferPeriodDuration: BigNumber$1;
        }>;
        getPoolVersion(overrides?: CallOverrides): Promise<[string]>;
        getProtocolFeePercentagesProvider(overrides?: CallOverrides): Promise<[string]>;
        getVault(overrides?: CallOverrides): Promise<[string]>;
        isDisabled(overrides?: CallOverrides): Promise<[boolean]>;
        isPoolFromFactory(pool: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;
        version(overrides?: CallOverrides): Promise<[string]>;
    };
    create(name: PromiseOrValue<string>, symbol: PromiseOrValue<string>, mainToken: PromiseOrValue<string>, wrappedToken: PromiseOrValue<string>, upperTarget: PromiseOrValue<BigNumberish$1>, swapFeePercentage: PromiseOrValue<BigNumberish$1>, owner: PromiseOrValue<string>, protocolId: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    disable(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    eulerProtocol(overrides?: CallOverrides): Promise<string>;
    getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
    getAuthorizer(overrides?: CallOverrides): Promise<string>;
    getCreationCode(overrides?: CallOverrides): Promise<string>;
    getCreationCodeContracts(overrides?: CallOverrides): Promise<[string, string] & {
        contractA: string;
        contractB: string;
    }>;
    getLastCreatedPool(overrides?: CallOverrides): Promise<string>;
    getPauseConfiguration(overrides?: CallOverrides): Promise<[
        BigNumber$1,
        BigNumber$1
    ] & {
        pauseWindowDuration: BigNumber$1;
        bufferPeriodDuration: BigNumber$1;
    }>;
    getPoolVersion(overrides?: CallOverrides): Promise<string>;
    getProtocolFeePercentagesProvider(overrides?: CallOverrides): Promise<string>;
    getVault(overrides?: CallOverrides): Promise<string>;
    isDisabled(overrides?: CallOverrides): Promise<boolean>;
    isPoolFromFactory(pool: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
    version(overrides?: CallOverrides): Promise<string>;
    callStatic: {
        create(name: PromiseOrValue<string>, symbol: PromiseOrValue<string>, mainToken: PromiseOrValue<string>, wrappedToken: PromiseOrValue<string>, upperTarget: PromiseOrValue<BigNumberish$1>, swapFeePercentage: PromiseOrValue<BigNumberish$1>, owner: PromiseOrValue<string>, protocolId: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<string>;
        disable(overrides?: CallOverrides): Promise<void>;
        eulerProtocol(overrides?: CallOverrides): Promise<string>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
        getAuthorizer(overrides?: CallOverrides): Promise<string>;
        getCreationCode(overrides?: CallOverrides): Promise<string>;
        getCreationCodeContracts(overrides?: CallOverrides): Promise<[string, string] & {
            contractA: string;
            contractB: string;
        }>;
        getLastCreatedPool(overrides?: CallOverrides): Promise<string>;
        getPauseConfiguration(overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1
        ] & {
            pauseWindowDuration: BigNumber$1;
            bufferPeriodDuration: BigNumber$1;
        }>;
        getPoolVersion(overrides?: CallOverrides): Promise<string>;
        getProtocolFeePercentagesProvider(overrides?: CallOverrides): Promise<string>;
        getVault(overrides?: CallOverrides): Promise<string>;
        isDisabled(overrides?: CallOverrides): Promise<boolean>;
        isPoolFromFactory(pool: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
        version(overrides?: CallOverrides): Promise<string>;
    };
    filters: {
        "EulerLinearPoolCreated(address,uint256)"(pool?: PromiseOrValue<string> | null, protocolId?: PromiseOrValue<BigNumberish$1> | null): EulerLinearPoolCreatedEventFilter;
        EulerLinearPoolCreated(pool?: PromiseOrValue<string> | null, protocolId?: PromiseOrValue<BigNumberish$1> | null): EulerLinearPoolCreatedEventFilter;
        "FactoryDisabled()"(): FactoryDisabledEventFilter$3;
        FactoryDisabled(): FactoryDisabledEventFilter$3;
        "PoolCreated(address)"(pool?: PromiseOrValue<string> | null): PoolCreatedEventFilter$3;
        PoolCreated(pool?: PromiseOrValue<string> | null): PoolCreatedEventFilter$3;
    };
    estimateGas: {
        create(name: PromiseOrValue<string>, symbol: PromiseOrValue<string>, mainToken: PromiseOrValue<string>, wrappedToken: PromiseOrValue<string>, upperTarget: PromiseOrValue<BigNumberish$1>, swapFeePercentage: PromiseOrValue<BigNumberish$1>, owner: PromiseOrValue<string>, protocolId: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        disable(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        eulerProtocol(overrides?: CallOverrides): Promise<BigNumber$1>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getAuthorizer(overrides?: CallOverrides): Promise<BigNumber$1>;
        getCreationCode(overrides?: CallOverrides): Promise<BigNumber$1>;
        getCreationCodeContracts(overrides?: CallOverrides): Promise<BigNumber$1>;
        getLastCreatedPool(overrides?: CallOverrides): Promise<BigNumber$1>;
        getPauseConfiguration(overrides?: CallOverrides): Promise<BigNumber$1>;
        getPoolVersion(overrides?: CallOverrides): Promise<BigNumber$1>;
        getProtocolFeePercentagesProvider(overrides?: CallOverrides): Promise<BigNumber$1>;
        getVault(overrides?: CallOverrides): Promise<BigNumber$1>;
        isDisabled(overrides?: CallOverrides): Promise<BigNumber$1>;
        isPoolFromFactory(pool: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        version(overrides?: CallOverrides): Promise<BigNumber$1>;
    };
    populateTransaction: {
        create(name: PromiseOrValue<string>, symbol: PromiseOrValue<string>, mainToken: PromiseOrValue<string>, wrappedToken: PromiseOrValue<string>, upperTarget: PromiseOrValue<BigNumberish$1>, swapFeePercentage: PromiseOrValue<BigNumberish$1>, owner: PromiseOrValue<string>, protocolId: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        disable(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        eulerProtocol(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getAuthorizer(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getCreationCode(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getCreationCodeContracts(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getLastCreatedPool(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getPauseConfiguration(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getPoolVersion(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getProtocolFeePercentagesProvider(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getVault(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        isDisabled(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        isPoolFromFactory(pool: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        version(overrides?: CallOverrides): Promise<PopulatedTransaction>;
    };
}

declare namespace IPoolSwapStructs$6 {
    type SwapRequestStruct = {
        kind: PromiseOrValue<BigNumberish$1>;
        tokenIn: PromiseOrValue<string>;
        tokenOut: PromiseOrValue<string>;
        amount: PromiseOrValue<BigNumberish$1>;
        poolId: PromiseOrValue<BytesLike>;
        lastChangeBlock: PromiseOrValue<BigNumberish$1>;
        from: PromiseOrValue<string>;
        to: PromiseOrValue<string>;
        userData: PromiseOrValue<BytesLike>;
    };
    type SwapRequestStructOutput = [
        number,
        string,
        string,
        BigNumber$1,
        string,
        BigNumber$1,
        string,
        string,
        string
    ] & {
        kind: number;
        tokenIn: string;
        tokenOut: string;
        amount: BigNumber$1;
        poolId: string;
        lastChangeBlock: BigNumber$1;
        from: string;
        to: string;
        userData: string;
    };
}
interface FXPoolInterface extends utils.Interface {
    functions: {
        "DOMAIN_SEPARATOR()": FunctionFragment;
        "allowance(address,address)": FunctionFragment;
        "approve(address,uint256)": FunctionFragment;
        "assimilator(address)": FunctionFragment;
        "balanceOf(address)": FunctionFragment;
        "collectorAddress()": FunctionFragment;
        "curve()": FunctionFragment;
        "decimals()": FunctionFragment;
        "decreaseAllowance(address,uint256)": FunctionFragment;
        "derivatives(uint256)": FunctionFragment;
        "emergency()": FunctionFragment;
        "getPoolId()": FunctionFragment;
        "getVault()": FunctionFragment;
        "increaseAllowance(address,uint256)": FunctionFragment;
        "initialize(address[],uint256[])": FunctionFragment;
        "liquidity()": FunctionFragment;
        "name()": FunctionFragment;
        "nonces(address)": FunctionFragment;
        "numeraires(uint256)": FunctionFragment;
        "onExitPool(bytes32,address,address,uint256[],uint256,uint256,bytes)": FunctionFragment;
        "onJoinPool(bytes32,address,address,uint256[],uint256,uint256,bytes)": FunctionFragment;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)": FunctionFragment;
        "owner()": FunctionFragment;
        "paused()": FunctionFragment;
        "permit(address,address,uint256,uint256,uint8,bytes32,bytes32)": FunctionFragment;
        "protocolPercentFee()": FunctionFragment;
        "renounceOwnership()": FunctionFragment;
        "reserves(uint256)": FunctionFragment;
        "setCap(uint256)": FunctionFragment;
        "setCollectorAddress(address)": FunctionFragment;
        "setEmergency(bool)": FunctionFragment;
        "setParams(uint256,uint256,uint256,uint256,uint256)": FunctionFragment;
        "setPaused()": FunctionFragment;
        "setProtocolPercentFee(uint256)": FunctionFragment;
        "symbol()": FunctionFragment;
        "totalSupply()": FunctionFragment;
        "totalUnclaimedFeesInNumeraire()": FunctionFragment;
        "transfer(address,uint256)": FunctionFragment;
        "transferFrom(address,address,uint256)": FunctionFragment;
        "transferOwnership(address)": FunctionFragment;
        "viewDeposit(uint256)": FunctionFragment;
        "viewParameters()": FunctionFragment;
        "viewWithdraw(uint256)": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "DOMAIN_SEPARATOR" | "allowance" | "approve" | "assimilator" | "balanceOf" | "collectorAddress" | "curve" | "decimals" | "decreaseAllowance" | "derivatives" | "emergency" | "getPoolId" | "getVault" | "increaseAllowance" | "initialize" | "liquidity" | "name" | "nonces" | "numeraires" | "onExitPool" | "onJoinPool" | "onSwap" | "owner" | "paused" | "permit" | "protocolPercentFee" | "renounceOwnership" | "reserves" | "setCap" | "setCollectorAddress" | "setEmergency" | "setParams" | "setPaused" | "setProtocolPercentFee" | "symbol" | "totalSupply" | "totalUnclaimedFeesInNumeraire" | "transfer" | "transferFrom" | "transferOwnership" | "viewDeposit" | "viewParameters" | "viewWithdraw"): FunctionFragment;
    encodeFunctionData(functionFragment: "DOMAIN_SEPARATOR", values?: undefined): string;
    encodeFunctionData(functionFragment: "allowance", values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "approve", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "assimilator", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "balanceOf", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "collectorAddress", values?: undefined): string;
    encodeFunctionData(functionFragment: "curve", values?: undefined): string;
    encodeFunctionData(functionFragment: "decimals", values?: undefined): string;
    encodeFunctionData(functionFragment: "decreaseAllowance", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "derivatives", values: [PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "emergency", values?: undefined): string;
    encodeFunctionData(functionFragment: "getPoolId", values?: undefined): string;
    encodeFunctionData(functionFragment: "getVault", values?: undefined): string;
    encodeFunctionData(functionFragment: "increaseAllowance", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "initialize", values: [PromiseOrValue<string>[], PromiseOrValue<BigNumberish$1>[]]): string;
    encodeFunctionData(functionFragment: "liquidity", values?: undefined): string;
    encodeFunctionData(functionFragment: "name", values?: undefined): string;
    encodeFunctionData(functionFragment: "nonces", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "numeraires", values: [PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "onExitPool", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "onJoinPool", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "onSwap", values: [
        IPoolSwapStructs$6.SwapRequestStruct,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "owner", values?: undefined): string;
    encodeFunctionData(functionFragment: "paused", values?: undefined): string;
    encodeFunctionData(functionFragment: "permit", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "protocolPercentFee", values?: undefined): string;
    encodeFunctionData(functionFragment: "renounceOwnership", values?: undefined): string;
    encodeFunctionData(functionFragment: "reserves", values: [PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "setCap", values: [PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "setCollectorAddress", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "setEmergency", values: [PromiseOrValue<boolean>]): string;
    encodeFunctionData(functionFragment: "setParams", values: [
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "setPaused", values?: undefined): string;
    encodeFunctionData(functionFragment: "setProtocolPercentFee", values: [PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "symbol", values?: undefined): string;
    encodeFunctionData(functionFragment: "totalSupply", values?: undefined): string;
    encodeFunctionData(functionFragment: "totalUnclaimedFeesInNumeraire", values?: undefined): string;
    encodeFunctionData(functionFragment: "transfer", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "transferFrom", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "transferOwnership", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "viewDeposit", values: [PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "viewParameters", values?: undefined): string;
    encodeFunctionData(functionFragment: "viewWithdraw", values: [PromiseOrValue<BigNumberish$1>]): string;
    decodeFunctionResult(functionFragment: "DOMAIN_SEPARATOR", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "allowance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "approve", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "assimilator", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "balanceOf", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "collectorAddress", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "curve", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "decimals", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "decreaseAllowance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "derivatives", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "emergency", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getPoolId", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getVault", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "increaseAllowance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "liquidity", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "name", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "nonces", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "numeraires", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "onExitPool", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "onJoinPool", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "onSwap", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "paused", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "permit", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "protocolPercentFee", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "renounceOwnership", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "reserves", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setCap", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setCollectorAddress", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setEmergency", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setParams", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setPaused", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setProtocolPercentFee", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "symbol", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "totalSupply", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "totalUnclaimedFeesInNumeraire", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "transfer", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "transferFrom", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "transferOwnership", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "viewDeposit", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "viewParameters", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "viewWithdraw", data: BytesLike): Result;
    events: {
        "Approval(address,address,uint256)": EventFragment;
        "AssetIncluded(address,address,uint256)": EventFragment;
        "AssimilatorIncluded(address,address,address,address)": EventFragment;
        "ChangeCollectorAddress(address)": EventFragment;
        "EmergencyAlarm(bool)": EventFragment;
        "EmergencyWithdraw(bytes32,uint256,uint256[])": EventFragment;
        "FeesAccrued(uint256)": EventFragment;
        "FeesCollected(address,uint256)": EventFragment;
        "OnExitPool(bytes32,uint256,uint256[])": EventFragment;
        "OnJoinPool(bytes32,uint256,uint256[])": EventFragment;
        "OwnershipTransferred(address,address)": EventFragment;
        "ParametersSet(uint256,uint256,uint256,uint256,uint256)": EventFragment;
        "Paused(address)": EventFragment;
        "ProtocolFeeShareUpdated(address,uint256)": EventFragment;
        "Trade(address,address,address,uint256,uint256)": EventFragment;
        "Transfer(address,address,uint256)": EventFragment;
        "Unpaused(address)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "Approval"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "AssetIncluded"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "AssimilatorIncluded"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "ChangeCollectorAddress"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "EmergencyAlarm"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "EmergencyWithdraw"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "FeesAccrued"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "FeesCollected"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "OnExitPool"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "OnJoinPool"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "ParametersSet"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Paused"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "ProtocolFeeShareUpdated"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Trade"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Transfer"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Unpaused"): EventFragment;
}
interface ApprovalEventObject$7 {
    owner: string;
    spender: string;
    value: BigNumber$1;
}
type ApprovalEvent$7 = TypedEvent<[
    string,
    string,
    BigNumber$1
], ApprovalEventObject$7>;
type ApprovalEventFilter$7 = TypedEventFilter<ApprovalEvent$7>;
interface AssetIncludedEventObject {
    numeraire: string;
    reserve: string;
    weight: BigNumber$1;
}
type AssetIncludedEvent = TypedEvent<[
    string,
    string,
    BigNumber$1
], AssetIncludedEventObject>;
type AssetIncludedEventFilter = TypedEventFilter<AssetIncludedEvent>;
interface AssimilatorIncludedEventObject {
    derivative: string;
    numeraire: string;
    reserve: string;
    assimilator: string;
}
type AssimilatorIncludedEvent = TypedEvent<[
    string,
    string,
    string,
    string
], AssimilatorIncludedEventObject>;
type AssimilatorIncludedEventFilter = TypedEventFilter<AssimilatorIncludedEvent>;
interface ChangeCollectorAddressEventObject {
    newCollector: string;
}
type ChangeCollectorAddressEvent = TypedEvent<[
    string
], ChangeCollectorAddressEventObject>;
type ChangeCollectorAddressEventFilter = TypedEventFilter<ChangeCollectorAddressEvent>;
interface EmergencyAlarmEventObject {
    isEmergency: boolean;
}
type EmergencyAlarmEvent = TypedEvent<[
    boolean
], EmergencyAlarmEventObject>;
type EmergencyAlarmEventFilter = TypedEventFilter<EmergencyAlarmEvent>;
interface EmergencyWithdrawEventObject {
    poolId: string;
    lptAmountBurned: BigNumber$1;
    amountsWithdrawn: BigNumber$1[];
}
type EmergencyWithdrawEvent = TypedEvent<[
    string,
    BigNumber$1,
    BigNumber$1[]
], EmergencyWithdrawEventObject>;
type EmergencyWithdrawEventFilter = TypedEventFilter<EmergencyWithdrawEvent>;
interface FeesAccruedEventObject {
    feesCollected: BigNumber$1;
}
type FeesAccruedEvent = TypedEvent<[BigNumber$1], FeesAccruedEventObject>;
type FeesAccruedEventFilter = TypedEventFilter<FeesAccruedEvent>;
interface FeesCollectedEventObject {
    recipient: string;
    feesCollected: BigNumber$1;
}
type FeesCollectedEvent = TypedEvent<[
    string,
    BigNumber$1
], FeesCollectedEventObject>;
type FeesCollectedEventFilter = TypedEventFilter<FeesCollectedEvent>;
interface OnExitPoolEventObject {
    poolId: string;
    lptAmountBurned: BigNumber$1;
    amountsWithdrawn: BigNumber$1[];
}
type OnExitPoolEvent = TypedEvent<[
    string,
    BigNumber$1,
    BigNumber$1[]
], OnExitPoolEventObject>;
type OnExitPoolEventFilter = TypedEventFilter<OnExitPoolEvent>;
interface OnJoinPoolEventObject {
    poolId: string;
    lptAmountMinted: BigNumber$1;
    amountsDeposited: BigNumber$1[];
}
type OnJoinPoolEvent = TypedEvent<[
    string,
    BigNumber$1,
    BigNumber$1[]
], OnJoinPoolEventObject>;
type OnJoinPoolEventFilter = TypedEventFilter<OnJoinPoolEvent>;
interface OwnershipTransferredEventObject {
    previousOwner: string;
    newOwner: string;
}
type OwnershipTransferredEvent = TypedEvent<[
    string,
    string
], OwnershipTransferredEventObject>;
type OwnershipTransferredEventFilter = TypedEventFilter<OwnershipTransferredEvent>;
interface ParametersSetEventObject {
    alpha: BigNumber$1;
    beta: BigNumber$1;
    delta: BigNumber$1;
    epsilon: BigNumber$1;
    lambda: BigNumber$1;
}
type ParametersSetEvent = TypedEvent<[
    BigNumber$1,
    BigNumber$1,
    BigNumber$1,
    BigNumber$1,
    BigNumber$1
], ParametersSetEventObject>;
type ParametersSetEventFilter = TypedEventFilter<ParametersSetEvent>;
interface PausedEventObject {
    account: string;
}
type PausedEvent = TypedEvent<[string], PausedEventObject>;
type PausedEventFilter = TypedEventFilter<PausedEvent>;
interface ProtocolFeeShareUpdatedEventObject {
    updater: string;
    newProtocolPercentage: BigNumber$1;
}
type ProtocolFeeShareUpdatedEvent = TypedEvent<[
    string,
    BigNumber$1
], ProtocolFeeShareUpdatedEventObject>;
type ProtocolFeeShareUpdatedEventFilter = TypedEventFilter<ProtocolFeeShareUpdatedEvent>;
interface TradeEventObject {
    trader: string;
    origin: string;
    target: string;
    originAmount: BigNumber$1;
    targetAmount: BigNumber$1;
}
type TradeEvent = TypedEvent<[
    string,
    string,
    string,
    BigNumber$1,
    BigNumber$1
], TradeEventObject>;
type TradeEventFilter = TypedEventFilter<TradeEvent>;
interface TransferEventObject$7 {
    from: string;
    to: string;
    value: BigNumber$1;
}
type TransferEvent$7 = TypedEvent<[
    string,
    string,
    BigNumber$1
], TransferEventObject$7>;
type TransferEventFilter$7 = TypedEventFilter<TransferEvent$7>;
interface UnpausedEventObject {
    account: string;
}
type UnpausedEvent = TypedEvent<[string], UnpausedEventObject>;
type UnpausedEventFilter = TypedEventFilter<UnpausedEvent>;
interface FXPool extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: FXPoolInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<[string]>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        assimilator(_derivative: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[string] & {
            assimilator_: string;
        }>;
        balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        collectorAddress(overrides?: CallOverrides): Promise<[string]>;
        curve(overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1,
            BigNumber$1,
            BigNumber$1,
            BigNumber$1,
            BigNumber$1,
            string,
            string,
            string
        ] & {
            alpha: BigNumber$1;
            beta: BigNumber$1;
            delta: BigNumber$1;
            epsilon: BigNumber$1;
            lambda: BigNumber$1;
            cap: BigNumber$1;
            vault: string;
            fxPoolAddress: string;
            poolId: string;
        }>;
        decimals(overrides?: CallOverrides): Promise<[number]>;
        decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        derivatives(arg0: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<[string]>;
        emergency(overrides?: CallOverrides): Promise<[boolean]>;
        getPoolId(overrides?: CallOverrides): Promise<[string]>;
        getVault(overrides?: CallOverrides): Promise<[string]>;
        increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        initialize(_assets: PromiseOrValue<string>[], _assetWeights: PromiseOrValue<BigNumberish$1>[], overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        liquidity(overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1[]
        ] & {
            total_: BigNumber$1;
            individual_: BigNumber$1[];
        }>;
        name(overrides?: CallOverrides): Promise<[string]>;
        nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        numeraires(arg0: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<[string]>;
        onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, arg3: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        onJoinPool(poolId: PromiseOrValue<BytesLike>, arg1: PromiseOrValue<string>, recipient: PromiseOrValue<string>, arg3: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        onSwap(swapRequest: IPoolSwapStructs$6.SwapRequestStruct, arg1: PromiseOrValue<BigNumberish$1>, arg2: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        owner(overrides?: CallOverrides): Promise<[string]>;
        paused(overrides?: CallOverrides): Promise<[boolean]>;
        permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        protocolPercentFee(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        renounceOwnership(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        reserves(arg0: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<[string]>;
        setCap(_cap: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setCollectorAddress(_collectorAddress: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setEmergency(_emergency: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setParams(_alpha: PromiseOrValue<BigNumberish$1>, _beta: PromiseOrValue<BigNumberish$1>, _feeAtHalt: PromiseOrValue<BigNumberish$1>, _epsilon: PromiseOrValue<BigNumberish$1>, _lambda: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setPaused(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setProtocolPercentFee(_protocolPercentFee: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        symbol(overrides?: CallOverrides): Promise<[string]>;
        totalSupply(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        totalUnclaimedFeesInNumeraire(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        transferOwnership(newOwner: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        viewDeposit(totalDepositNumeraire: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<[BigNumber$1, BigNumber$1[]]>;
        viewParameters(overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1,
            BigNumber$1,
            BigNumber$1,
            BigNumber$1
        ] & {
            alpha_: BigNumber$1;
            beta_: BigNumber$1;
            delta_: BigNumber$1;
            epsilon_: BigNumber$1;
            lambda_: BigNumber$1;
        }>;
        viewWithdraw(_curvesToBurn: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<[BigNumber$1[]]>;
    };
    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;
    allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    assimilator(_derivative: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;
    balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    collectorAddress(overrides?: CallOverrides): Promise<string>;
    curve(overrides?: CallOverrides): Promise<[
        BigNumber$1,
        BigNumber$1,
        BigNumber$1,
        BigNumber$1,
        BigNumber$1,
        BigNumber$1,
        string,
        string,
        string
    ] & {
        alpha: BigNumber$1;
        beta: BigNumber$1;
        delta: BigNumber$1;
        epsilon: BigNumber$1;
        lambda: BigNumber$1;
        cap: BigNumber$1;
        vault: string;
        fxPoolAddress: string;
        poolId: string;
    }>;
    decimals(overrides?: CallOverrides): Promise<number>;
    decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    derivatives(arg0: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<string>;
    emergency(overrides?: CallOverrides): Promise<boolean>;
    getPoolId(overrides?: CallOverrides): Promise<string>;
    getVault(overrides?: CallOverrides): Promise<string>;
    increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    initialize(_assets: PromiseOrValue<string>[], _assetWeights: PromiseOrValue<BigNumberish$1>[], overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    liquidity(overrides?: CallOverrides): Promise<[
        BigNumber$1,
        BigNumber$1[]
    ] & {
        total_: BigNumber$1;
        individual_: BigNumber$1[];
    }>;
    name(overrides?: CallOverrides): Promise<string>;
    nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    numeraires(arg0: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<string>;
    onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, arg3: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    onJoinPool(poolId: PromiseOrValue<BytesLike>, arg1: PromiseOrValue<string>, recipient: PromiseOrValue<string>, arg3: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    onSwap(swapRequest: IPoolSwapStructs$6.SwapRequestStruct, arg1: PromiseOrValue<BigNumberish$1>, arg2: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    owner(overrides?: CallOverrides): Promise<string>;
    paused(overrides?: CallOverrides): Promise<boolean>;
    permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    protocolPercentFee(overrides?: CallOverrides): Promise<BigNumber$1>;
    renounceOwnership(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    reserves(arg0: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<string>;
    setCap(_cap: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setCollectorAddress(_collectorAddress: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setEmergency(_emergency: PromiseOrValue<boolean>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setParams(_alpha: PromiseOrValue<BigNumberish$1>, _beta: PromiseOrValue<BigNumberish$1>, _feeAtHalt: PromiseOrValue<BigNumberish$1>, _epsilon: PromiseOrValue<BigNumberish$1>, _lambda: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setPaused(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setProtocolPercentFee(_protocolPercentFee: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    symbol(overrides?: CallOverrides): Promise<string>;
    totalSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
    totalUnclaimedFeesInNumeraire(overrides?: CallOverrides): Promise<BigNumber$1>;
    transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    transferOwnership(newOwner: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    viewDeposit(totalDepositNumeraire: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<[BigNumber$1, BigNumber$1[]]>;
    viewParameters(overrides?: CallOverrides): Promise<[
        BigNumber$1,
        BigNumber$1,
        BigNumber$1,
        BigNumber$1,
        BigNumber$1
    ] & {
        alpha_: BigNumber$1;
        beta_: BigNumber$1;
        delta_: BigNumber$1;
        epsilon_: BigNumber$1;
        lambda_: BigNumber$1;
    }>;
    viewWithdraw(_curvesToBurn: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1[]>;
    callStatic: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        assimilator(_derivative: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;
        balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        collectorAddress(overrides?: CallOverrides): Promise<string>;
        curve(overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1,
            BigNumber$1,
            BigNumber$1,
            BigNumber$1,
            BigNumber$1,
            string,
            string,
            string
        ] & {
            alpha: BigNumber$1;
            beta: BigNumber$1;
            delta: BigNumber$1;
            epsilon: BigNumber$1;
            lambda: BigNumber$1;
            cap: BigNumber$1;
            vault: string;
            fxPoolAddress: string;
            poolId: string;
        }>;
        decimals(overrides?: CallOverrides): Promise<number>;
        decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        derivatives(arg0: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<string>;
        emergency(overrides?: CallOverrides): Promise<boolean>;
        getPoolId(overrides?: CallOverrides): Promise<string>;
        getVault(overrides?: CallOverrides): Promise<string>;
        increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        initialize(_assets: PromiseOrValue<string>[], _assetWeights: PromiseOrValue<BigNumberish$1>[], overrides?: CallOverrides): Promise<void>;
        liquidity(overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1[]
        ] & {
            total_: BigNumber$1;
            individual_: BigNumber$1[];
        }>;
        name(overrides?: CallOverrides): Promise<string>;
        nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        numeraires(arg0: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<string>;
        onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, arg3: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[
            BigNumber$1[],
            BigNumber$1[]
        ] & {
            amountsOut: BigNumber$1[];
            dueProtocolFeeAmounts: BigNumber$1[];
        }>;
        onJoinPool(poolId: PromiseOrValue<BytesLike>, arg1: PromiseOrValue<string>, recipient: PromiseOrValue<string>, arg3: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[
            BigNumber$1[],
            BigNumber$1[]
        ] & {
            amountsIn: BigNumber$1[];
            dueProtocolFeeAmounts: BigNumber$1[];
        }>;
        onSwap(swapRequest: IPoolSwapStructs$6.SwapRequestStruct, arg1: PromiseOrValue<BigNumberish$1>, arg2: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        owner(overrides?: CallOverrides): Promise<string>;
        paused(overrides?: CallOverrides): Promise<boolean>;
        permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<void>;
        protocolPercentFee(overrides?: CallOverrides): Promise<BigNumber$1>;
        renounceOwnership(overrides?: CallOverrides): Promise<void>;
        reserves(arg0: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<string>;
        setCap(_cap: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        setCollectorAddress(_collectorAddress: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
        setEmergency(_emergency: PromiseOrValue<boolean>, overrides?: CallOverrides): Promise<void>;
        setParams(_alpha: PromiseOrValue<BigNumberish$1>, _beta: PromiseOrValue<BigNumberish$1>, _feeAtHalt: PromiseOrValue<BigNumberish$1>, _epsilon: PromiseOrValue<BigNumberish$1>, _lambda: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        setPaused(overrides?: CallOverrides): Promise<void>;
        setProtocolPercentFee(_protocolPercentFee: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        symbol(overrides?: CallOverrides): Promise<string>;
        totalSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
        totalUnclaimedFeesInNumeraire(overrides?: CallOverrides): Promise<BigNumber$1>;
        transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        transferOwnership(newOwner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
        viewDeposit(totalDepositNumeraire: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<[BigNumber$1, BigNumber$1[]]>;
        viewParameters(overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1,
            BigNumber$1,
            BigNumber$1,
            BigNumber$1
        ] & {
            alpha_: BigNumber$1;
            beta_: BigNumber$1;
            delta_: BigNumber$1;
            epsilon_: BigNumber$1;
            lambda_: BigNumber$1;
        }>;
        viewWithdraw(_curvesToBurn: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1[]>;
    };
    filters: {
        "Approval(address,address,uint256)"(owner?: PromiseOrValue<string> | null, spender?: PromiseOrValue<string> | null, value?: null): ApprovalEventFilter$7;
        Approval(owner?: PromiseOrValue<string> | null, spender?: PromiseOrValue<string> | null, value?: null): ApprovalEventFilter$7;
        "AssetIncluded(address,address,uint256)"(numeraire?: PromiseOrValue<string> | null, reserve?: PromiseOrValue<string> | null, weight?: null): AssetIncludedEventFilter;
        AssetIncluded(numeraire?: PromiseOrValue<string> | null, reserve?: PromiseOrValue<string> | null, weight?: null): AssetIncludedEventFilter;
        "AssimilatorIncluded(address,address,address,address)"(derivative?: PromiseOrValue<string> | null, numeraire?: PromiseOrValue<string> | null, reserve?: PromiseOrValue<string> | null, assimilator?: null): AssimilatorIncludedEventFilter;
        AssimilatorIncluded(derivative?: PromiseOrValue<string> | null, numeraire?: PromiseOrValue<string> | null, reserve?: PromiseOrValue<string> | null, assimilator?: null): AssimilatorIncludedEventFilter;
        "ChangeCollectorAddress(address)"(newCollector?: null): ChangeCollectorAddressEventFilter;
        ChangeCollectorAddress(newCollector?: null): ChangeCollectorAddressEventFilter;
        "EmergencyAlarm(bool)"(isEmergency?: null): EmergencyAlarmEventFilter;
        EmergencyAlarm(isEmergency?: null): EmergencyAlarmEventFilter;
        "EmergencyWithdraw(bytes32,uint256,uint256[])"(poolId?: null, lptAmountBurned?: null, amountsWithdrawn?: null): EmergencyWithdrawEventFilter;
        EmergencyWithdraw(poolId?: null, lptAmountBurned?: null, amountsWithdrawn?: null): EmergencyWithdrawEventFilter;
        "FeesAccrued(uint256)"(feesCollected?: null): FeesAccruedEventFilter;
        FeesAccrued(feesCollected?: null): FeesAccruedEventFilter;
        "FeesCollected(address,uint256)"(recipient?: null, feesCollected?: null): FeesCollectedEventFilter;
        FeesCollected(recipient?: null, feesCollected?: null): FeesCollectedEventFilter;
        "OnExitPool(bytes32,uint256,uint256[])"(poolId?: null, lptAmountBurned?: null, amountsWithdrawn?: null): OnExitPoolEventFilter;
        OnExitPool(poolId?: null, lptAmountBurned?: null, amountsWithdrawn?: null): OnExitPoolEventFilter;
        "OnJoinPool(bytes32,uint256,uint256[])"(poolId?: null, lptAmountMinted?: null, amountsDeposited?: null): OnJoinPoolEventFilter;
        OnJoinPool(poolId?: null, lptAmountMinted?: null, amountsDeposited?: null): OnJoinPoolEventFilter;
        "OwnershipTransferred(address,address)"(previousOwner?: PromiseOrValue<string> | null, newOwner?: PromiseOrValue<string> | null): OwnershipTransferredEventFilter;
        OwnershipTransferred(previousOwner?: PromiseOrValue<string> | null, newOwner?: PromiseOrValue<string> | null): OwnershipTransferredEventFilter;
        "ParametersSet(uint256,uint256,uint256,uint256,uint256)"(alpha?: null, beta?: null, delta?: null, epsilon?: null, lambda?: null): ParametersSetEventFilter;
        ParametersSet(alpha?: null, beta?: null, delta?: null, epsilon?: null, lambda?: null): ParametersSetEventFilter;
        "Paused(address)"(account?: null): PausedEventFilter;
        Paused(account?: null): PausedEventFilter;
        "ProtocolFeeShareUpdated(address,uint256)"(updater?: null, newProtocolPercentage?: null): ProtocolFeeShareUpdatedEventFilter;
        ProtocolFeeShareUpdated(updater?: null, newProtocolPercentage?: null): ProtocolFeeShareUpdatedEventFilter;
        "Trade(address,address,address,uint256,uint256)"(trader?: PromiseOrValue<string> | null, origin?: PromiseOrValue<string> | null, target?: PromiseOrValue<string> | null, originAmount?: null, targetAmount?: null): TradeEventFilter;
        Trade(trader?: PromiseOrValue<string> | null, origin?: PromiseOrValue<string> | null, target?: PromiseOrValue<string> | null, originAmount?: null, targetAmount?: null): TradeEventFilter;
        "Transfer(address,address,uint256)"(from?: PromiseOrValue<string> | null, to?: PromiseOrValue<string> | null, value?: null): TransferEventFilter$7;
        Transfer(from?: PromiseOrValue<string> | null, to?: PromiseOrValue<string> | null, value?: null): TransferEventFilter$7;
        "Unpaused(address)"(account?: null): UnpausedEventFilter;
        Unpaused(account?: null): UnpausedEventFilter;
    };
    estimateGas: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<BigNumber$1>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        assimilator(_derivative: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        collectorAddress(overrides?: CallOverrides): Promise<BigNumber$1>;
        curve(overrides?: CallOverrides): Promise<BigNumber$1>;
        decimals(overrides?: CallOverrides): Promise<BigNumber$1>;
        decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        derivatives(arg0: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        emergency(overrides?: CallOverrides): Promise<BigNumber$1>;
        getPoolId(overrides?: CallOverrides): Promise<BigNumber$1>;
        getVault(overrides?: CallOverrides): Promise<BigNumber$1>;
        increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        initialize(_assets: PromiseOrValue<string>[], _assetWeights: PromiseOrValue<BigNumberish$1>[], overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        liquidity(overrides?: CallOverrides): Promise<BigNumber$1>;
        name(overrides?: CallOverrides): Promise<BigNumber$1>;
        nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        numeraires(arg0: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, arg3: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        onJoinPool(poolId: PromiseOrValue<BytesLike>, arg1: PromiseOrValue<string>, recipient: PromiseOrValue<string>, arg3: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        onSwap(swapRequest: IPoolSwapStructs$6.SwapRequestStruct, arg1: PromiseOrValue<BigNumberish$1>, arg2: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        owner(overrides?: CallOverrides): Promise<BigNumber$1>;
        paused(overrides?: CallOverrides): Promise<BigNumber$1>;
        permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        protocolPercentFee(overrides?: CallOverrides): Promise<BigNumber$1>;
        renounceOwnership(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        reserves(arg0: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        setCap(_cap: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        setCollectorAddress(_collectorAddress: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        setEmergency(_emergency: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        setParams(_alpha: PromiseOrValue<BigNumberish$1>, _beta: PromiseOrValue<BigNumberish$1>, _feeAtHalt: PromiseOrValue<BigNumberish$1>, _epsilon: PromiseOrValue<BigNumberish$1>, _lambda: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        setPaused(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        setProtocolPercentFee(_protocolPercentFee: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        symbol(overrides?: CallOverrides): Promise<BigNumber$1>;
        totalSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
        totalUnclaimedFeesInNumeraire(overrides?: CallOverrides): Promise<BigNumber$1>;
        transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        transferOwnership(newOwner: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        viewDeposit(totalDepositNumeraire: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        viewParameters(overrides?: CallOverrides): Promise<BigNumber$1>;
        viewWithdraw(_curvesToBurn: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
    };
    populateTransaction: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        assimilator(_derivative: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        collectorAddress(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        curve(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        decimals(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        derivatives(arg0: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        emergency(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getPoolId(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getVault(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        initialize(_assets: PromiseOrValue<string>[], _assetWeights: PromiseOrValue<BigNumberish$1>[], overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        liquidity(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        name(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        numeraires(arg0: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, arg3: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        onJoinPool(poolId: PromiseOrValue<BytesLike>, arg1: PromiseOrValue<string>, recipient: PromiseOrValue<string>, arg3: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        onSwap(swapRequest: IPoolSwapStructs$6.SwapRequestStruct, arg1: PromiseOrValue<BigNumberish$1>, arg2: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        paused(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        protocolPercentFee(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        renounceOwnership(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        reserves(arg0: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        setCap(_cap: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setCollectorAddress(_collectorAddress: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setEmergency(_emergency: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setParams(_alpha: PromiseOrValue<BigNumberish$1>, _beta: PromiseOrValue<BigNumberish$1>, _feeAtHalt: PromiseOrValue<BigNumberish$1>, _epsilon: PromiseOrValue<BigNumberish$1>, _lambda: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setPaused(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setProtocolPercentFee(_protocolPercentFee: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        symbol(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        totalSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        totalUnclaimedFeesInNumeraire(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        transferOwnership(newOwner: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        viewDeposit(totalDepositNumeraire: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        viewParameters(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        viewWithdraw(_curvesToBurn: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
    };
}

interface GaugeClaimHelperInterface extends utils.Interface {
    functions: {
        "CLAIM_FREQUENCY()": FunctionFragment;
        "claimRewardsFromGauge(address,address)": FunctionFragment;
        "claimRewardsFromGauges(address[],address)": FunctionFragment;
        "getPendingRewards(address,address,address)": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "CLAIM_FREQUENCY" | "claimRewardsFromGauge" | "claimRewardsFromGauges" | "getPendingRewards"): FunctionFragment;
    encodeFunctionData(functionFragment: "CLAIM_FREQUENCY", values?: undefined): string;
    encodeFunctionData(functionFragment: "claimRewardsFromGauge", values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "claimRewardsFromGauges", values: [PromiseOrValue<string>[], PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "getPendingRewards", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<string>
    ]): string;
    decodeFunctionResult(functionFragment: "CLAIM_FREQUENCY", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "claimRewardsFromGauge", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "claimRewardsFromGauges", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getPendingRewards", data: BytesLike): Result;
    events: {};
}
interface GaugeClaimHelper extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: GaugeClaimHelperInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        CLAIM_FREQUENCY(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        claimRewardsFromGauge(gauge: PromiseOrValue<string>, user: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        claimRewardsFromGauges(gauges: PromiseOrValue<string>[], user: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        getPendingRewards(gauge: PromiseOrValue<string>, user: PromiseOrValue<string>, token: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
    };
    CLAIM_FREQUENCY(overrides?: CallOverrides): Promise<BigNumber$1>;
    claimRewardsFromGauge(gauge: PromiseOrValue<string>, user: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    claimRewardsFromGauges(gauges: PromiseOrValue<string>[], user: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    getPendingRewards(gauge: PromiseOrValue<string>, user: PromiseOrValue<string>, token: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        CLAIM_FREQUENCY(overrides?: CallOverrides): Promise<BigNumber$1>;
        claimRewardsFromGauge(gauge: PromiseOrValue<string>, user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
        claimRewardsFromGauges(gauges: PromiseOrValue<string>[], user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
        getPendingRewards(gauge: PromiseOrValue<string>, user: PromiseOrValue<string>, token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    };
    filters: {};
    estimateGas: {
        CLAIM_FREQUENCY(overrides?: CallOverrides): Promise<BigNumber$1>;
        claimRewardsFromGauge(gauge: PromiseOrValue<string>, user: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        claimRewardsFromGauges(gauges: PromiseOrValue<string>[], user: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        getPendingRewards(gauge: PromiseOrValue<string>, user: PromiseOrValue<string>, token: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
    };
    populateTransaction: {
        CLAIM_FREQUENCY(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        claimRewardsFromGauge(gauge: PromiseOrValue<string>, user: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        claimRewardsFromGauges(gauges: PromiseOrValue<string>[], user: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        getPendingRewards(gauge: PromiseOrValue<string>, user: PromiseOrValue<string>, token: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
    };
}

declare namespace IPoolSwapStructs$5 {
    type SwapRequestStruct = {
        kind: PromiseOrValue<BigNumberish$1>;
        tokenIn: PromiseOrValue<string>;
        tokenOut: PromiseOrValue<string>;
        amount: PromiseOrValue<BigNumberish$1>;
        poolId: PromiseOrValue<BytesLike>;
        lastChangeBlock: PromiseOrValue<BigNumberish$1>;
        from: PromiseOrValue<string>;
        to: PromiseOrValue<string>;
        userData: PromiseOrValue<BytesLike>;
    };
    type SwapRequestStructOutput = [
        number,
        string,
        string,
        BigNumber$1,
        string,
        BigNumber$1,
        string,
        string,
        string
    ] & {
        kind: number;
        tokenIn: string;
        tokenOut: string;
        amount: BigNumber$1;
        poolId: string;
        lastChangeBlock: BigNumber$1;
        from: string;
        to: string;
        userData: string;
    };
}
interface GearboxLinearPoolInterface extends utils.Interface {
    functions: {
        "DOMAIN_SEPARATOR()": FunctionFragment;
        "allowance(address,address)": FunctionFragment;
        "approve(address,uint256)": FunctionFragment;
        "balanceOf(address)": FunctionFragment;
        "decimals()": FunctionFragment;
        "decreaseAllowance(address,uint256)": FunctionFragment;
        "disableRecoveryMode()": FunctionFragment;
        "enableRecoveryMode()": FunctionFragment;
        "getActionId(bytes4)": FunctionFragment;
        "getAuthorizer()": FunctionFragment;
        "getBptIndex()": FunctionFragment;
        "getDomainSeparator()": FunctionFragment;
        "getMainIndex()": FunctionFragment;
        "getMainToken()": FunctionFragment;
        "getNextNonce(address)": FunctionFragment;
        "getOwner()": FunctionFragment;
        "getPausedState()": FunctionFragment;
        "getPoolId()": FunctionFragment;
        "getProtocolFeesCollector()": FunctionFragment;
        "getRate()": FunctionFragment;
        "getScalingFactors()": FunctionFragment;
        "getSwapFeePercentage()": FunctionFragment;
        "getTargets()": FunctionFragment;
        "getVault()": FunctionFragment;
        "getVirtualSupply()": FunctionFragment;
        "getWrappedIndex()": FunctionFragment;
        "getWrappedToken()": FunctionFragment;
        "getWrappedTokenRate()": FunctionFragment;
        "inRecoveryMode()": FunctionFragment;
        "increaseAllowance(address,uint256)": FunctionFragment;
        "initialize()": FunctionFragment;
        "name()": FunctionFragment;
        "nonces(address)": FunctionFragment;
        "onExitPool(bytes32,address,address,uint256[],uint256,uint256,bytes)": FunctionFragment;
        "onJoinPool(bytes32,address,address,uint256[],uint256,uint256,bytes)": FunctionFragment;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)": FunctionFragment;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)": FunctionFragment;
        "pause()": FunctionFragment;
        "permit(address,address,uint256,uint256,uint8,bytes32,bytes32)": FunctionFragment;
        "queryExit(bytes32,address,address,uint256[],uint256,uint256,bytes)": FunctionFragment;
        "queryJoin(bytes32,address,address,uint256[],uint256,uint256,bytes)": FunctionFragment;
        "setSwapFeePercentage(uint256)": FunctionFragment;
        "setTargets(uint256,uint256)": FunctionFragment;
        "symbol()": FunctionFragment;
        "totalSupply()": FunctionFragment;
        "transfer(address,uint256)": FunctionFragment;
        "transferFrom(address,address,uint256)": FunctionFragment;
        "unpause()": FunctionFragment;
        "version()": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "DOMAIN_SEPARATOR" | "allowance" | "approve" | "balanceOf" | "decimals" | "decreaseAllowance" | "disableRecoveryMode" | "enableRecoveryMode" | "getActionId" | "getAuthorizer" | "getBptIndex" | "getDomainSeparator" | "getMainIndex" | "getMainToken" | "getNextNonce" | "getOwner" | "getPausedState" | "getPoolId" | "getProtocolFeesCollector" | "getRate" | "getScalingFactors" | "getSwapFeePercentage" | "getTargets" | "getVault" | "getVirtualSupply" | "getWrappedIndex" | "getWrappedToken" | "getWrappedTokenRate" | "inRecoveryMode" | "increaseAllowance" | "initialize" | "name" | "nonces" | "onExitPool" | "onJoinPool" | "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)" | "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)" | "pause" | "permit" | "queryExit" | "queryJoin" | "setSwapFeePercentage" | "setTargets" | "symbol" | "totalSupply" | "transfer" | "transferFrom" | "unpause" | "version"): FunctionFragment;
    encodeFunctionData(functionFragment: "DOMAIN_SEPARATOR", values?: undefined): string;
    encodeFunctionData(functionFragment: "allowance", values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "approve", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "balanceOf", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "decimals", values?: undefined): string;
    encodeFunctionData(functionFragment: "decreaseAllowance", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "disableRecoveryMode", values?: undefined): string;
    encodeFunctionData(functionFragment: "enableRecoveryMode", values?: undefined): string;
    encodeFunctionData(functionFragment: "getActionId", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "getAuthorizer", values?: undefined): string;
    encodeFunctionData(functionFragment: "getBptIndex", values?: undefined): string;
    encodeFunctionData(functionFragment: "getDomainSeparator", values?: undefined): string;
    encodeFunctionData(functionFragment: "getMainIndex", values?: undefined): string;
    encodeFunctionData(functionFragment: "getMainToken", values?: undefined): string;
    encodeFunctionData(functionFragment: "getNextNonce", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "getOwner", values?: undefined): string;
    encodeFunctionData(functionFragment: "getPausedState", values?: undefined): string;
    encodeFunctionData(functionFragment: "getPoolId", values?: undefined): string;
    encodeFunctionData(functionFragment: "getProtocolFeesCollector", values?: undefined): string;
    encodeFunctionData(functionFragment: "getRate", values?: undefined): string;
    encodeFunctionData(functionFragment: "getScalingFactors", values?: undefined): string;
    encodeFunctionData(functionFragment: "getSwapFeePercentage", values?: undefined): string;
    encodeFunctionData(functionFragment: "getTargets", values?: undefined): string;
    encodeFunctionData(functionFragment: "getVault", values?: undefined): string;
    encodeFunctionData(functionFragment: "getVirtualSupply", values?: undefined): string;
    encodeFunctionData(functionFragment: "getWrappedIndex", values?: undefined): string;
    encodeFunctionData(functionFragment: "getWrappedToken", values?: undefined): string;
    encodeFunctionData(functionFragment: "getWrappedTokenRate", values?: undefined): string;
    encodeFunctionData(functionFragment: "inRecoveryMode", values?: undefined): string;
    encodeFunctionData(functionFragment: "increaseAllowance", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "initialize", values?: undefined): string;
    encodeFunctionData(functionFragment: "name", values?: undefined): string;
    encodeFunctionData(functionFragment: "nonces", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "onExitPool", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "onJoinPool", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)", values: [
        IPoolSwapStructs$5.SwapRequestStruct,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)", values: [
        IPoolSwapStructs$5.SwapRequestStruct,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "pause", values?: undefined): string;
    encodeFunctionData(functionFragment: "permit", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "queryExit", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "queryJoin", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "setSwapFeePercentage", values: [PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "setTargets", values: [PromiseOrValue<BigNumberish$1>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "symbol", values?: undefined): string;
    encodeFunctionData(functionFragment: "totalSupply", values?: undefined): string;
    encodeFunctionData(functionFragment: "transfer", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "transferFrom", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "unpause", values?: undefined): string;
    encodeFunctionData(functionFragment: "version", values?: undefined): string;
    decodeFunctionResult(functionFragment: "DOMAIN_SEPARATOR", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "allowance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "approve", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "balanceOf", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "decimals", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "decreaseAllowance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "disableRecoveryMode", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "enableRecoveryMode", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getActionId", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getAuthorizer", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getBptIndex", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getDomainSeparator", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getMainIndex", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getMainToken", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getNextNonce", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getOwner", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getPausedState", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getPoolId", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getProtocolFeesCollector", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getRate", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getScalingFactors", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getSwapFeePercentage", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getTargets", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getVault", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getVirtualSupply", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getWrappedIndex", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getWrappedToken", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getWrappedTokenRate", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "inRecoveryMode", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "increaseAllowance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "name", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "nonces", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "onExitPool", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "onJoinPool", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "pause", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "permit", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "queryExit", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "queryJoin", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setSwapFeePercentage", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setTargets", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "symbol", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "totalSupply", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "transfer", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "transferFrom", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "unpause", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "version", data: BytesLike): Result;
    events: {
        "Approval(address,address,uint256)": EventFragment;
        "PausedStateChanged(bool)": EventFragment;
        "RecoveryModeStateChanged(bool)": EventFragment;
        "SwapFeePercentageChanged(uint256)": EventFragment;
        "TargetsSet(address,uint256,uint256)": EventFragment;
        "Transfer(address,address,uint256)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "Approval"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "PausedStateChanged"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "RecoveryModeStateChanged"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "SwapFeePercentageChanged"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "TargetsSet"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Transfer"): EventFragment;
}
interface ApprovalEventObject$6 {
    owner: string;
    spender: string;
    value: BigNumber$1;
}
type ApprovalEvent$6 = TypedEvent<[
    string,
    string,
    BigNumber$1
], ApprovalEventObject$6>;
type ApprovalEventFilter$6 = TypedEventFilter<ApprovalEvent$6>;
interface PausedStateChangedEventObject$6 {
    paused: boolean;
}
type PausedStateChangedEvent$6 = TypedEvent<[
    boolean
], PausedStateChangedEventObject$6>;
type PausedStateChangedEventFilter$6 = TypedEventFilter<PausedStateChangedEvent$6>;
interface RecoveryModeStateChangedEventObject$2 {
    enabled: boolean;
}
type RecoveryModeStateChangedEvent$2 = TypedEvent<[
    boolean
], RecoveryModeStateChangedEventObject$2>;
type RecoveryModeStateChangedEventFilter$2 = TypedEventFilter<RecoveryModeStateChangedEvent$2>;
interface SwapFeePercentageChangedEventObject$5 {
    swapFeePercentage: BigNumber$1;
}
type SwapFeePercentageChangedEvent$5 = TypedEvent<[
    BigNumber$1
], SwapFeePercentageChangedEventObject$5>;
type SwapFeePercentageChangedEventFilter$5 = TypedEventFilter<SwapFeePercentageChangedEvent$5>;
interface TargetsSetEventObject$2 {
    token: string;
    lowerTarget: BigNumber$1;
    upperTarget: BigNumber$1;
}
type TargetsSetEvent$2 = TypedEvent<[
    string,
    BigNumber$1,
    BigNumber$1
], TargetsSetEventObject$2>;
type TargetsSetEventFilter$2 = TypedEventFilter<TargetsSetEvent$2>;
interface TransferEventObject$6 {
    from: string;
    to: string;
    value: BigNumber$1;
}
type TransferEvent$6 = TypedEvent<[
    string,
    string,
    BigNumber$1
], TransferEventObject$6>;
type TransferEventFilter$6 = TypedEventFilter<TransferEvent$6>;
declare namespace GearboxLinearPool {
    type ConstructorArgsStruct = {
        vault: PromiseOrValue<string>;
        name: PromiseOrValue<string>;
        symbol: PromiseOrValue<string>;
        mainToken: PromiseOrValue<string>;
        wrappedToken: PromiseOrValue<string>;
        assetManager: PromiseOrValue<string>;
        upperTarget: PromiseOrValue<BigNumberish$1>;
        swapFeePercentage: PromiseOrValue<BigNumberish$1>;
        pauseWindowDuration: PromiseOrValue<BigNumberish$1>;
        bufferPeriodDuration: PromiseOrValue<BigNumberish$1>;
        owner: PromiseOrValue<string>;
        version: PromiseOrValue<string>;
    };
    type ConstructorArgsStructOutput = [
        string,
        string,
        string,
        string,
        string,
        string,
        BigNumber$1,
        BigNumber$1,
        BigNumber$1,
        BigNumber$1,
        string,
        string
    ] & {
        vault: string;
        name: string;
        symbol: string;
        mainToken: string;
        wrappedToken: string;
        assetManager: string;
        upperTarget: BigNumber$1;
        swapFeePercentage: BigNumber$1;
        pauseWindowDuration: BigNumber$1;
        bufferPeriodDuration: BigNumber$1;
        owner: string;
        version: string;
    };
}
interface GearboxLinearPool extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: GearboxLinearPoolInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<[string]>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        decimals(overrides?: CallOverrides): Promise<[number]>;
        decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        disableRecoveryMode(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        enableRecoveryMode(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[string]>;
        getAuthorizer(overrides?: CallOverrides): Promise<[string]>;
        getBptIndex(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getDomainSeparator(overrides?: CallOverrides): Promise<[string]>;
        getMainIndex(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getMainToken(overrides?: CallOverrides): Promise<[string]>;
        getNextNonce(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getOwner(overrides?: CallOverrides): Promise<[string]>;
        getPausedState(overrides?: CallOverrides): Promise<[
            boolean,
            BigNumber$1,
            BigNumber$1
        ] & {
            paused: boolean;
            pauseWindowEndTime: BigNumber$1;
            bufferPeriodEndTime: BigNumber$1;
        }>;
        getPoolId(overrides?: CallOverrides): Promise<[string]>;
        getProtocolFeesCollector(overrides?: CallOverrides): Promise<[string]>;
        getRate(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getScalingFactors(overrides?: CallOverrides): Promise<[BigNumber$1[]]>;
        getSwapFeePercentage(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getTargets(overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1
        ] & {
            lowerTarget: BigNumber$1;
            upperTarget: BigNumber$1;
        }>;
        getVault(overrides?: CallOverrides): Promise<[string]>;
        getVirtualSupply(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getWrappedIndex(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getWrappedToken(overrides?: CallOverrides): Promise<[string]>;
        getWrappedTokenRate(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        inRecoveryMode(overrides?: CallOverrides): Promise<[boolean]>;
        increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        initialize(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        name(overrides?: CallOverrides): Promise<[string]>;
        nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        onJoinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)"(request: IPoolSwapStructs$5.SwapRequestStruct, balances: PromiseOrValue<BigNumberish$1>[], indexIn: PromiseOrValue<BigNumberish$1>, indexOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)"(request: IPoolSwapStructs$5.SwapRequestStruct, balanceTokenIn: PromiseOrValue<BigNumberish$1>, balanceTokenOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        pause(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        queryExit(arg0: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        queryJoin(arg0: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setSwapFeePercentage(swapFeePercentage: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setTargets(newLowerTarget: PromiseOrValue<BigNumberish$1>, newUpperTarget: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        symbol(overrides?: CallOverrides): Promise<[string]>;
        totalSupply(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        unpause(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        version(overrides?: CallOverrides): Promise<[string]>;
    };
    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;
    allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    decimals(overrides?: CallOverrides): Promise<number>;
    decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    disableRecoveryMode(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    enableRecoveryMode(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
    getAuthorizer(overrides?: CallOverrides): Promise<string>;
    getBptIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
    getDomainSeparator(overrides?: CallOverrides): Promise<string>;
    getMainIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
    getMainToken(overrides?: CallOverrides): Promise<string>;
    getNextNonce(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    getOwner(overrides?: CallOverrides): Promise<string>;
    getPausedState(overrides?: CallOverrides): Promise<[
        boolean,
        BigNumber$1,
        BigNumber$1
    ] & {
        paused: boolean;
        pauseWindowEndTime: BigNumber$1;
        bufferPeriodEndTime: BigNumber$1;
    }>;
    getPoolId(overrides?: CallOverrides): Promise<string>;
    getProtocolFeesCollector(overrides?: CallOverrides): Promise<string>;
    getRate(overrides?: CallOverrides): Promise<BigNumber$1>;
    getScalingFactors(overrides?: CallOverrides): Promise<BigNumber$1[]>;
    getSwapFeePercentage(overrides?: CallOverrides): Promise<BigNumber$1>;
    getTargets(overrides?: CallOverrides): Promise<[
        BigNumber$1,
        BigNumber$1
    ] & {
        lowerTarget: BigNumber$1;
        upperTarget: BigNumber$1;
    }>;
    getVault(overrides?: CallOverrides): Promise<string>;
    getVirtualSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
    getWrappedIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
    getWrappedToken(overrides?: CallOverrides): Promise<string>;
    getWrappedTokenRate(overrides?: CallOverrides): Promise<BigNumber$1>;
    inRecoveryMode(overrides?: CallOverrides): Promise<boolean>;
    increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    initialize(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    name(overrides?: CallOverrides): Promise<string>;
    nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    onJoinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)"(request: IPoolSwapStructs$5.SwapRequestStruct, balances: PromiseOrValue<BigNumberish$1>[], indexIn: PromiseOrValue<BigNumberish$1>, indexOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)"(request: IPoolSwapStructs$5.SwapRequestStruct, balanceTokenIn: PromiseOrValue<BigNumberish$1>, balanceTokenOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    pause(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    queryExit(arg0: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    queryJoin(arg0: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setSwapFeePercentage(swapFeePercentage: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setTargets(newLowerTarget: PromiseOrValue<BigNumberish$1>, newUpperTarget: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    symbol(overrides?: CallOverrides): Promise<string>;
    totalSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
    transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    unpause(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    version(overrides?: CallOverrides): Promise<string>;
    callStatic: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        decimals(overrides?: CallOverrides): Promise<number>;
        decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        disableRecoveryMode(overrides?: CallOverrides): Promise<void>;
        enableRecoveryMode(overrides?: CallOverrides): Promise<void>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
        getAuthorizer(overrides?: CallOverrides): Promise<string>;
        getBptIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
        getDomainSeparator(overrides?: CallOverrides): Promise<string>;
        getMainIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
        getMainToken(overrides?: CallOverrides): Promise<string>;
        getNextNonce(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getOwner(overrides?: CallOverrides): Promise<string>;
        getPausedState(overrides?: CallOverrides): Promise<[
            boolean,
            BigNumber$1,
            BigNumber$1
        ] & {
            paused: boolean;
            pauseWindowEndTime: BigNumber$1;
            bufferPeriodEndTime: BigNumber$1;
        }>;
        getPoolId(overrides?: CallOverrides): Promise<string>;
        getProtocolFeesCollector(overrides?: CallOverrides): Promise<string>;
        getRate(overrides?: CallOverrides): Promise<BigNumber$1>;
        getScalingFactors(overrides?: CallOverrides): Promise<BigNumber$1[]>;
        getSwapFeePercentage(overrides?: CallOverrides): Promise<BigNumber$1>;
        getTargets(overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1
        ] & {
            lowerTarget: BigNumber$1;
            upperTarget: BigNumber$1;
        }>;
        getVault(overrides?: CallOverrides): Promise<string>;
        getVirtualSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
        getWrappedIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
        getWrappedToken(overrides?: CallOverrides): Promise<string>;
        getWrappedTokenRate(overrides?: CallOverrides): Promise<BigNumber$1>;
        inRecoveryMode(overrides?: CallOverrides): Promise<boolean>;
        increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        initialize(overrides?: CallOverrides): Promise<void>;
        name(overrides?: CallOverrides): Promise<string>;
        nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[
            BigNumber$1[],
            BigNumber$1[]
        ] & {
            amountsOut: BigNumber$1[];
            dueProtocolFees: BigNumber$1[];
        }>;
        onJoinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[
            BigNumber$1[],
            BigNumber$1[]
        ] & {
            amountsIn: BigNumber$1[];
            dueProtocolFees: BigNumber$1[];
        }>;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)"(request: IPoolSwapStructs$5.SwapRequestStruct, balances: PromiseOrValue<BigNumberish$1>[], indexIn: PromiseOrValue<BigNumberish$1>, indexOut: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)"(request: IPoolSwapStructs$5.SwapRequestStruct, balanceTokenIn: PromiseOrValue<BigNumberish$1>, balanceTokenOut: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        pause(overrides?: CallOverrides): Promise<void>;
        permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<void>;
        queryExit(arg0: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1[]
        ] & {
            bptIn: BigNumber$1;
            amountsOut: BigNumber$1[];
        }>;
        queryJoin(arg0: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1[]
        ] & {
            bptOut: BigNumber$1;
            amountsIn: BigNumber$1[];
        }>;
        setSwapFeePercentage(swapFeePercentage: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        setTargets(newLowerTarget: PromiseOrValue<BigNumberish$1>, newUpperTarget: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        symbol(overrides?: CallOverrides): Promise<string>;
        totalSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
        transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        unpause(overrides?: CallOverrides): Promise<void>;
        version(overrides?: CallOverrides): Promise<string>;
    };
    filters: {
        "Approval(address,address,uint256)"(owner?: PromiseOrValue<string> | null, spender?: PromiseOrValue<string> | null, value?: null): ApprovalEventFilter$6;
        Approval(owner?: PromiseOrValue<string> | null, spender?: PromiseOrValue<string> | null, value?: null): ApprovalEventFilter$6;
        "PausedStateChanged(bool)"(paused?: null): PausedStateChangedEventFilter$6;
        PausedStateChanged(paused?: null): PausedStateChangedEventFilter$6;
        "RecoveryModeStateChanged(bool)"(enabled?: null): RecoveryModeStateChangedEventFilter$2;
        RecoveryModeStateChanged(enabled?: null): RecoveryModeStateChangedEventFilter$2;
        "SwapFeePercentageChanged(uint256)"(swapFeePercentage?: null): SwapFeePercentageChangedEventFilter$5;
        SwapFeePercentageChanged(swapFeePercentage?: null): SwapFeePercentageChangedEventFilter$5;
        "TargetsSet(address,uint256,uint256)"(token?: PromiseOrValue<string> | null, lowerTarget?: null, upperTarget?: null): TargetsSetEventFilter$2;
        TargetsSet(token?: PromiseOrValue<string> | null, lowerTarget?: null, upperTarget?: null): TargetsSetEventFilter$2;
        "Transfer(address,address,uint256)"(from?: PromiseOrValue<string> | null, to?: PromiseOrValue<string> | null, value?: null): TransferEventFilter$6;
        Transfer(from?: PromiseOrValue<string> | null, to?: PromiseOrValue<string> | null, value?: null): TransferEventFilter$6;
    };
    estimateGas: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<BigNumber$1>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        decimals(overrides?: CallOverrides): Promise<BigNumber$1>;
        decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        disableRecoveryMode(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        enableRecoveryMode(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getAuthorizer(overrides?: CallOverrides): Promise<BigNumber$1>;
        getBptIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
        getDomainSeparator(overrides?: CallOverrides): Promise<BigNumber$1>;
        getMainIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
        getMainToken(overrides?: CallOverrides): Promise<BigNumber$1>;
        getNextNonce(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getOwner(overrides?: CallOverrides): Promise<BigNumber$1>;
        getPausedState(overrides?: CallOverrides): Promise<BigNumber$1>;
        getPoolId(overrides?: CallOverrides): Promise<BigNumber$1>;
        getProtocolFeesCollector(overrides?: CallOverrides): Promise<BigNumber$1>;
        getRate(overrides?: CallOverrides): Promise<BigNumber$1>;
        getScalingFactors(overrides?: CallOverrides): Promise<BigNumber$1>;
        getSwapFeePercentage(overrides?: CallOverrides): Promise<BigNumber$1>;
        getTargets(overrides?: CallOverrides): Promise<BigNumber$1>;
        getVault(overrides?: CallOverrides): Promise<BigNumber$1>;
        getVirtualSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
        getWrappedIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
        getWrappedToken(overrides?: CallOverrides): Promise<BigNumber$1>;
        getWrappedTokenRate(overrides?: CallOverrides): Promise<BigNumber$1>;
        inRecoveryMode(overrides?: CallOverrides): Promise<BigNumber$1>;
        increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        initialize(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        name(overrides?: CallOverrides): Promise<BigNumber$1>;
        nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        onJoinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)"(request: IPoolSwapStructs$5.SwapRequestStruct, balances: PromiseOrValue<BigNumberish$1>[], indexIn: PromiseOrValue<BigNumberish$1>, indexOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)"(request: IPoolSwapStructs$5.SwapRequestStruct, balanceTokenIn: PromiseOrValue<BigNumberish$1>, balanceTokenOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        pause(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        queryExit(arg0: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        queryJoin(arg0: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        setSwapFeePercentage(swapFeePercentage: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        setTargets(newLowerTarget: PromiseOrValue<BigNumberish$1>, newUpperTarget: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        symbol(overrides?: CallOverrides): Promise<BigNumber$1>;
        totalSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
        transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        unpause(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        version(overrides?: CallOverrides): Promise<BigNumber$1>;
    };
    populateTransaction: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        decimals(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        disableRecoveryMode(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        enableRecoveryMode(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getAuthorizer(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getBptIndex(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getDomainSeparator(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getMainIndex(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getMainToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getNextNonce(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getOwner(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getPausedState(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getPoolId(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getProtocolFeesCollector(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getRate(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getScalingFactors(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getSwapFeePercentage(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getTargets(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getVault(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getVirtualSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getWrappedIndex(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getWrappedToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getWrappedTokenRate(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        inRecoveryMode(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        initialize(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        name(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        onJoinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)"(request: IPoolSwapStructs$5.SwapRequestStruct, balances: PromiseOrValue<BigNumberish$1>[], indexIn: PromiseOrValue<BigNumberish$1>, indexOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)"(request: IPoolSwapStructs$5.SwapRequestStruct, balanceTokenIn: PromiseOrValue<BigNumberish$1>, balanceTokenOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        pause(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        queryExit(arg0: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        queryJoin(arg0: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setSwapFeePercentage(swapFeePercentage: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setTargets(newLowerTarget: PromiseOrValue<BigNumberish$1>, newUpperTarget: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        symbol(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        totalSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        unpause(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        version(overrides?: CallOverrides): Promise<PopulatedTransaction>;
    };
}

interface GearboxLinearPoolFactoryInterface extends utils.Interface {
    functions: {
        "create(string,string,address,address,uint256,uint256,address,uint256,bytes32)": FunctionFragment;
        "disable()": FunctionFragment;
        "getActionId(bytes4)": FunctionFragment;
        "getAuthorizer()": FunctionFragment;
        "getCreationCode()": FunctionFragment;
        "getCreationCodeContracts()": FunctionFragment;
        "getLastCreatedPool()": FunctionFragment;
        "getPauseConfiguration()": FunctionFragment;
        "getPoolVersion()": FunctionFragment;
        "getProtocolFeePercentagesProvider()": FunctionFragment;
        "getVault()": FunctionFragment;
        "isDisabled()": FunctionFragment;
        "isPoolFromFactory(address)": FunctionFragment;
        "version()": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "create" | "disable" | "getActionId" | "getAuthorizer" | "getCreationCode" | "getCreationCodeContracts" | "getLastCreatedPool" | "getPauseConfiguration" | "getPoolVersion" | "getProtocolFeePercentagesProvider" | "getVault" | "isDisabled" | "isPoolFromFactory" | "version"): FunctionFragment;
    encodeFunctionData(functionFragment: "create", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "disable", values?: undefined): string;
    encodeFunctionData(functionFragment: "getActionId", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "getAuthorizer", values?: undefined): string;
    encodeFunctionData(functionFragment: "getCreationCode", values?: undefined): string;
    encodeFunctionData(functionFragment: "getCreationCodeContracts", values?: undefined): string;
    encodeFunctionData(functionFragment: "getLastCreatedPool", values?: undefined): string;
    encodeFunctionData(functionFragment: "getPauseConfiguration", values?: undefined): string;
    encodeFunctionData(functionFragment: "getPoolVersion", values?: undefined): string;
    encodeFunctionData(functionFragment: "getProtocolFeePercentagesProvider", values?: undefined): string;
    encodeFunctionData(functionFragment: "getVault", values?: undefined): string;
    encodeFunctionData(functionFragment: "isDisabled", values?: undefined): string;
    encodeFunctionData(functionFragment: "isPoolFromFactory", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "version", values?: undefined): string;
    decodeFunctionResult(functionFragment: "create", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "disable", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getActionId", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getAuthorizer", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getCreationCode", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getCreationCodeContracts", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getLastCreatedPool", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getPauseConfiguration", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getPoolVersion", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getProtocolFeePercentagesProvider", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getVault", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isDisabled", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isPoolFromFactory", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "version", data: BytesLike): Result;
    events: {
        "FactoryDisabled()": EventFragment;
        "GearboxLinearPoolCreated(address,uint256)": EventFragment;
        "PoolCreated(address)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "FactoryDisabled"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "GearboxLinearPoolCreated"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "PoolCreated"): EventFragment;
}
interface FactoryDisabledEventObject$2 {
}
type FactoryDisabledEvent$2 = TypedEvent<[], FactoryDisabledEventObject$2>;
type FactoryDisabledEventFilter$2 = TypedEventFilter<FactoryDisabledEvent$2>;
interface GearboxLinearPoolCreatedEventObject {
    pool: string;
    protocolId: BigNumber$1;
}
type GearboxLinearPoolCreatedEvent = TypedEvent<[
    string,
    BigNumber$1
], GearboxLinearPoolCreatedEventObject>;
type GearboxLinearPoolCreatedEventFilter = TypedEventFilter<GearboxLinearPoolCreatedEvent>;
interface PoolCreatedEventObject$2 {
    pool: string;
}
type PoolCreatedEvent$2 = TypedEvent<[string], PoolCreatedEventObject$2>;
type PoolCreatedEventFilter$2 = TypedEventFilter<PoolCreatedEvent$2>;
interface GearboxLinearPoolFactory extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: GearboxLinearPoolFactoryInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        create(name: PromiseOrValue<string>, symbol: PromiseOrValue<string>, mainToken: PromiseOrValue<string>, wrappedToken: PromiseOrValue<string>, upperTarget: PromiseOrValue<BigNumberish$1>, swapFeePercentage: PromiseOrValue<BigNumberish$1>, owner: PromiseOrValue<string>, protocolId: PromiseOrValue<BigNumberish$1>, salt: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        disable(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[string]>;
        getAuthorizer(overrides?: CallOverrides): Promise<[string]>;
        getCreationCode(overrides?: CallOverrides): Promise<[string]>;
        getCreationCodeContracts(overrides?: CallOverrides): Promise<[string, string] & {
            contractA: string;
            contractB: string;
        }>;
        getLastCreatedPool(overrides?: CallOverrides): Promise<[string]>;
        getPauseConfiguration(overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1
        ] & {
            pauseWindowDuration: BigNumber$1;
            bufferPeriodDuration: BigNumber$1;
        }>;
        getPoolVersion(overrides?: CallOverrides): Promise<[string]>;
        getProtocolFeePercentagesProvider(overrides?: CallOverrides): Promise<[string]>;
        getVault(overrides?: CallOverrides): Promise<[string]>;
        isDisabled(overrides?: CallOverrides): Promise<[boolean]>;
        isPoolFromFactory(pool: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;
        version(overrides?: CallOverrides): Promise<[string]>;
    };
    create(name: PromiseOrValue<string>, symbol: PromiseOrValue<string>, mainToken: PromiseOrValue<string>, wrappedToken: PromiseOrValue<string>, upperTarget: PromiseOrValue<BigNumberish$1>, swapFeePercentage: PromiseOrValue<BigNumberish$1>, owner: PromiseOrValue<string>, protocolId: PromiseOrValue<BigNumberish$1>, salt: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    disable(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
    getAuthorizer(overrides?: CallOverrides): Promise<string>;
    getCreationCode(overrides?: CallOverrides): Promise<string>;
    getCreationCodeContracts(overrides?: CallOverrides): Promise<[string, string] & {
        contractA: string;
        contractB: string;
    }>;
    getLastCreatedPool(overrides?: CallOverrides): Promise<string>;
    getPauseConfiguration(overrides?: CallOverrides): Promise<[
        BigNumber$1,
        BigNumber$1
    ] & {
        pauseWindowDuration: BigNumber$1;
        bufferPeriodDuration: BigNumber$1;
    }>;
    getPoolVersion(overrides?: CallOverrides): Promise<string>;
    getProtocolFeePercentagesProvider(overrides?: CallOverrides): Promise<string>;
    getVault(overrides?: CallOverrides): Promise<string>;
    isDisabled(overrides?: CallOverrides): Promise<boolean>;
    isPoolFromFactory(pool: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
    version(overrides?: CallOverrides): Promise<string>;
    callStatic: {
        create(name: PromiseOrValue<string>, symbol: PromiseOrValue<string>, mainToken: PromiseOrValue<string>, wrappedToken: PromiseOrValue<string>, upperTarget: PromiseOrValue<BigNumberish$1>, swapFeePercentage: PromiseOrValue<BigNumberish$1>, owner: PromiseOrValue<string>, protocolId: PromiseOrValue<BigNumberish$1>, salt: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
        disable(overrides?: CallOverrides): Promise<void>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
        getAuthorizer(overrides?: CallOverrides): Promise<string>;
        getCreationCode(overrides?: CallOverrides): Promise<string>;
        getCreationCodeContracts(overrides?: CallOverrides): Promise<[string, string] & {
            contractA: string;
            contractB: string;
        }>;
        getLastCreatedPool(overrides?: CallOverrides): Promise<string>;
        getPauseConfiguration(overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1
        ] & {
            pauseWindowDuration: BigNumber$1;
            bufferPeriodDuration: BigNumber$1;
        }>;
        getPoolVersion(overrides?: CallOverrides): Promise<string>;
        getProtocolFeePercentagesProvider(overrides?: CallOverrides): Promise<string>;
        getVault(overrides?: CallOverrides): Promise<string>;
        isDisabled(overrides?: CallOverrides): Promise<boolean>;
        isPoolFromFactory(pool: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
        version(overrides?: CallOverrides): Promise<string>;
    };
    filters: {
        "FactoryDisabled()"(): FactoryDisabledEventFilter$2;
        FactoryDisabled(): FactoryDisabledEventFilter$2;
        "GearboxLinearPoolCreated(address,uint256)"(pool?: PromiseOrValue<string> | null, protocolId?: PromiseOrValue<BigNumberish$1> | null): GearboxLinearPoolCreatedEventFilter;
        GearboxLinearPoolCreated(pool?: PromiseOrValue<string> | null, protocolId?: PromiseOrValue<BigNumberish$1> | null): GearboxLinearPoolCreatedEventFilter;
        "PoolCreated(address)"(pool?: PromiseOrValue<string> | null): PoolCreatedEventFilter$2;
        PoolCreated(pool?: PromiseOrValue<string> | null): PoolCreatedEventFilter$2;
    };
    estimateGas: {
        create(name: PromiseOrValue<string>, symbol: PromiseOrValue<string>, mainToken: PromiseOrValue<string>, wrappedToken: PromiseOrValue<string>, upperTarget: PromiseOrValue<BigNumberish$1>, swapFeePercentage: PromiseOrValue<BigNumberish$1>, owner: PromiseOrValue<string>, protocolId: PromiseOrValue<BigNumberish$1>, salt: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        disable(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getAuthorizer(overrides?: CallOverrides): Promise<BigNumber$1>;
        getCreationCode(overrides?: CallOverrides): Promise<BigNumber$1>;
        getCreationCodeContracts(overrides?: CallOverrides): Promise<BigNumber$1>;
        getLastCreatedPool(overrides?: CallOverrides): Promise<BigNumber$1>;
        getPauseConfiguration(overrides?: CallOverrides): Promise<BigNumber$1>;
        getPoolVersion(overrides?: CallOverrides): Promise<BigNumber$1>;
        getProtocolFeePercentagesProvider(overrides?: CallOverrides): Promise<BigNumber$1>;
        getVault(overrides?: CallOverrides): Promise<BigNumber$1>;
        isDisabled(overrides?: CallOverrides): Promise<BigNumber$1>;
        isPoolFromFactory(pool: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        version(overrides?: CallOverrides): Promise<BigNumber$1>;
    };
    populateTransaction: {
        create(name: PromiseOrValue<string>, symbol: PromiseOrValue<string>, mainToken: PromiseOrValue<string>, wrappedToken: PromiseOrValue<string>, upperTarget: PromiseOrValue<BigNumberish$1>, swapFeePercentage: PromiseOrValue<BigNumberish$1>, owner: PromiseOrValue<string>, protocolId: PromiseOrValue<BigNumberish$1>, salt: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        disable(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getAuthorizer(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getCreationCode(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getCreationCodeContracts(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getLastCreatedPool(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getPauseConfiguration(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getPoolVersion(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getProtocolFeePercentagesProvider(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getVault(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        isDisabled(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        isPoolFromFactory(pool: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        version(overrides?: CallOverrides): Promise<PopulatedTransaction>;
    };
}

interface GyroConfigInterface extends utils.Interface {
    functions: {
        "acceptGovernance()": FunctionFragment;
        "changeGovernor(address)": FunctionFragment;
        "freeze(bytes32)": FunctionFragment;
        "getAddress(bytes32,address)": FunctionFragment;
        "getAddress(bytes32)": FunctionFragment;
        "getConfigMeta(bytes32)": FunctionFragment;
        "getUint(bytes32)": FunctionFragment;
        "governor()": FunctionFragment;
        "hasKey(bytes32)": FunctionFragment;
        "initialize(address)": FunctionFragment;
        "listKeys()": FunctionFragment;
        "pendingGovernor()": FunctionFragment;
        "setAddress(bytes32,address)": FunctionFragment;
        "setUint(bytes32,uint256)": FunctionFragment;
        "unset(bytes32)": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "acceptGovernance" | "changeGovernor" | "freeze" | "getAddress(bytes32,address)" | "getAddress(bytes32)" | "getConfigMeta" | "getUint" | "governor" | "hasKey" | "initialize" | "listKeys" | "pendingGovernor" | "setAddress" | "setUint" | "unset"): FunctionFragment;
    encodeFunctionData(functionFragment: "acceptGovernance", values?: undefined): string;
    encodeFunctionData(functionFragment: "changeGovernor", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "freeze", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "getAddress(bytes32,address)", values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "getAddress(bytes32)", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "getConfigMeta", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "getUint", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "governor", values?: undefined): string;
    encodeFunctionData(functionFragment: "hasKey", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "initialize", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "listKeys", values?: undefined): string;
    encodeFunctionData(functionFragment: "pendingGovernor", values?: undefined): string;
    encodeFunctionData(functionFragment: "setAddress", values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "setUint", values: [PromiseOrValue<BytesLike>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "unset", values: [PromiseOrValue<BytesLike>]): string;
    decodeFunctionResult(functionFragment: "acceptGovernance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "changeGovernor", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "freeze", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getAddress(bytes32,address)", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getAddress(bytes32)", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getConfigMeta", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getUint", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "governor", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "hasKey", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "listKeys", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "pendingGovernor", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setAddress", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setUint", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "unset", data: BytesLike): Result;
    events: {
        "ConfigChanged(bytes32,uint256,uint256)": EventFragment;
        "ConfigFrozen(bytes32)": EventFragment;
        "ConfigUnset(bytes32)": EventFragment;
        "GovernorChangeRequested(address)": EventFragment;
        "GovernorChanged(address,address)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "ConfigChanged"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "ConfigFrozen"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "ConfigUnset"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "GovernorChangeRequested"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "GovernorChanged"): EventFragment;
}
interface ConfigChangedEventObject {
    key: string;
    previousValue: BigNumber$1;
    newValue: BigNumber$1;
}
type ConfigChangedEvent = TypedEvent<[
    string,
    BigNumber$1,
    BigNumber$1
], ConfigChangedEventObject>;
type ConfigChangedEventFilter = TypedEventFilter<ConfigChangedEvent>;
interface ConfigFrozenEventObject {
    key: string;
}
type ConfigFrozenEvent = TypedEvent<[string], ConfigFrozenEventObject>;
type ConfigFrozenEventFilter = TypedEventFilter<ConfigFrozenEvent>;
interface ConfigUnsetEventObject {
    key: string;
}
type ConfigUnsetEvent = TypedEvent<[string], ConfigUnsetEventObject>;
type ConfigUnsetEventFilter = TypedEventFilter<ConfigUnsetEvent>;
interface GovernorChangeRequestedEventObject {
    newGovernor: string;
}
type GovernorChangeRequestedEvent = TypedEvent<[
    string
], GovernorChangeRequestedEventObject>;
type GovernorChangeRequestedEventFilter = TypedEventFilter<GovernorChangeRequestedEvent>;
interface GovernorChangedEventObject {
    oldGovernor: string;
    newGovernor: string;
}
type GovernorChangedEvent = TypedEvent<[
    string,
    string
], GovernorChangedEventObject>;
type GovernorChangedEventFilter = TypedEventFilter<GovernorChangedEvent>;
interface GyroConfig extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: GyroConfigInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        acceptGovernance(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        changeGovernor(newGovernor: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        freeze(key: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        "getAddress(bytes32,address)"(key: PromiseOrValue<BytesLike>, defaultValue: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[string]>;
        "getAddress(bytes32)"(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[string]>;
        getConfigMeta(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[number, boolean]>;
        getUint(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        governor(overrides?: CallOverrides): Promise<[string]>;
        hasKey(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[boolean]>;
        initialize(_governor: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        listKeys(overrides?: CallOverrides): Promise<[string[]]>;
        pendingGovernor(overrides?: CallOverrides): Promise<[string]>;
        setAddress(key: PromiseOrValue<BytesLike>, newValue: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setUint(key: PromiseOrValue<BytesLike>, newValue: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        unset(key: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
    };
    acceptGovernance(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    changeGovernor(newGovernor: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    freeze(key: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    "getAddress(bytes32,address)"(key: PromiseOrValue<BytesLike>, defaultValue: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;
    "getAddress(bytes32)"(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
    getConfigMeta(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[number, boolean]>;
    getUint(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber$1>;
    governor(overrides?: CallOverrides): Promise<string>;
    hasKey(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<boolean>;
    initialize(_governor: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    listKeys(overrides?: CallOverrides): Promise<string[]>;
    pendingGovernor(overrides?: CallOverrides): Promise<string>;
    setAddress(key: PromiseOrValue<BytesLike>, newValue: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setUint(key: PromiseOrValue<BytesLike>, newValue: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    unset(key: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        acceptGovernance(overrides?: CallOverrides): Promise<void>;
        changeGovernor(newGovernor: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
        freeze(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<void>;
        "getAddress(bytes32,address)"(key: PromiseOrValue<BytesLike>, defaultValue: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;
        "getAddress(bytes32)"(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
        getConfigMeta(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[number, boolean]>;
        getUint(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber$1>;
        governor(overrides?: CallOverrides): Promise<string>;
        hasKey(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<boolean>;
        initialize(_governor: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
        listKeys(overrides?: CallOverrides): Promise<string[]>;
        pendingGovernor(overrides?: CallOverrides): Promise<string>;
        setAddress(key: PromiseOrValue<BytesLike>, newValue: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
        setUint(key: PromiseOrValue<BytesLike>, newValue: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        unset(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<void>;
    };
    filters: {
        "ConfigChanged(bytes32,uint256,uint256)"(key?: null, previousValue?: null, newValue?: null): ConfigChangedEventFilter;
        ConfigChanged(key?: null, previousValue?: null, newValue?: null): ConfigChangedEventFilter;
        "ConfigFrozen(bytes32)"(key?: null): ConfigFrozenEventFilter;
        ConfigFrozen(key?: null): ConfigFrozenEventFilter;
        "ConfigUnset(bytes32)"(key?: null): ConfigUnsetEventFilter;
        ConfigUnset(key?: null): ConfigUnsetEventFilter;
        "GovernorChangeRequested(address)"(newGovernor?: null): GovernorChangeRequestedEventFilter;
        GovernorChangeRequested(newGovernor?: null): GovernorChangeRequestedEventFilter;
        "GovernorChanged(address,address)"(oldGovernor?: null, newGovernor?: null): GovernorChangedEventFilter;
        GovernorChanged(oldGovernor?: null, newGovernor?: null): GovernorChangedEventFilter;
    };
    estimateGas: {
        acceptGovernance(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        changeGovernor(newGovernor: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        freeze(key: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        "getAddress(bytes32,address)"(key: PromiseOrValue<BytesLike>, defaultValue: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        "getAddress(bytes32)"(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getConfigMeta(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getUint(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber$1>;
        governor(overrides?: CallOverrides): Promise<BigNumber$1>;
        hasKey(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber$1>;
        initialize(_governor: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        listKeys(overrides?: CallOverrides): Promise<BigNumber$1>;
        pendingGovernor(overrides?: CallOverrides): Promise<BigNumber$1>;
        setAddress(key: PromiseOrValue<BytesLike>, newValue: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        setUint(key: PromiseOrValue<BytesLike>, newValue: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        unset(key: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
    };
    populateTransaction: {
        acceptGovernance(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        changeGovernor(newGovernor: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        freeze(key: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        "getAddress(bytes32,address)"(key: PromiseOrValue<BytesLike>, defaultValue: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        "getAddress(bytes32)"(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getConfigMeta(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getUint(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        governor(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        hasKey(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        initialize(_governor: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        listKeys(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        pendingGovernor(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        setAddress(key: PromiseOrValue<BytesLike>, newValue: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setUint(key: PromiseOrValue<BytesLike>, newValue: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        unset(key: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
    };
}

declare namespace IVault$1 {
    type BatchSwapStepStruct = {
        poolId: PromiseOrValue<BytesLike>;
        assetInIndex: PromiseOrValue<BigNumberish$1>;
        assetOutIndex: PromiseOrValue<BigNumberish$1>;
        amount: PromiseOrValue<BigNumberish$1>;
        userData: PromiseOrValue<BytesLike>;
    };
    type BatchSwapStepStructOutput = [
        string,
        BigNumber$1,
        BigNumber$1,
        BigNumber$1,
        string
    ] & {
        poolId: string;
        assetInIndex: BigNumber$1;
        assetOutIndex: BigNumber$1;
        amount: BigNumber$1;
        userData: string;
    };
    type FundManagementStruct = {
        sender: PromiseOrValue<string>;
        fromInternalBalance: PromiseOrValue<boolean>;
        recipient: PromiseOrValue<string>;
        toInternalBalance: PromiseOrValue<boolean>;
    };
    type FundManagementStructOutput = [
        string,
        boolean,
        string,
        boolean
    ] & {
        sender: string;
        fromInternalBalance: boolean;
        recipient: string;
        toInternalBalance: boolean;
    };
    type ExitPoolRequestStruct = {
        assets: PromiseOrValue<string>[];
        minAmountsOut: PromiseOrValue<BigNumberish$1>[];
        userData: PromiseOrValue<BytesLike>;
        toInternalBalance: PromiseOrValue<boolean>;
    };
    type ExitPoolRequestStructOutput = [
        string[],
        BigNumber$1[],
        string,
        boolean
    ] & {
        assets: string[];
        minAmountsOut: BigNumber$1[];
        userData: string;
        toInternalBalance: boolean;
    };
    type JoinPoolRequestStruct = {
        assets: PromiseOrValue<string>[];
        maxAmountsIn: PromiseOrValue<BigNumberish$1>[];
        userData: PromiseOrValue<BytesLike>;
        fromInternalBalance: PromiseOrValue<boolean>;
    };
    type JoinPoolRequestStructOutput = [
        string[],
        BigNumber$1[],
        string,
        boolean
    ] & {
        assets: string[];
        maxAmountsIn: BigNumber$1[];
        userData: string;
        fromInternalBalance: boolean;
    };
    type SingleSwapStruct = {
        poolId: PromiseOrValue<BytesLike>;
        kind: PromiseOrValue<BigNumberish$1>;
        assetIn: PromiseOrValue<string>;
        assetOut: PromiseOrValue<string>;
        amount: PromiseOrValue<BigNumberish$1>;
        userData: PromiseOrValue<BytesLike>;
    };
    type SingleSwapStructOutput = [
        string,
        number,
        string,
        string,
        BigNumber$1,
        string
    ] & {
        poolId: string;
        kind: number;
        assetIn: string;
        assetOut: string;
        amount: BigNumber$1;
        userData: string;
    };
}
interface LidoRelayerInterface extends utils.Interface {
    functions: {
        "batchSwap(uint8,(bytes32,uint256,uint256,uint256,bytes)[],address[],(address,bool,address,bool),int256[],uint256)": FunctionFragment;
        "exitPool(bytes32,address,address,(address[],uint256[],bytes,bool))": FunctionFragment;
        "getStETH()": FunctionFragment;
        "getVault()": FunctionFragment;
        "getWstETH()": FunctionFragment;
        "joinPool(bytes32,address,address,(address[],uint256[],bytes,bool))": FunctionFragment;
        "swap((bytes32,uint8,address,address,uint256,bytes),(address,bool,address,bool),uint256,uint256)": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "batchSwap" | "exitPool" | "getStETH" | "getVault" | "getWstETH" | "joinPool" | "swap"): FunctionFragment;
    encodeFunctionData(functionFragment: "batchSwap", values: [
        PromiseOrValue<BigNumberish$1>,
        IVault$1.BatchSwapStepStruct[],
        PromiseOrValue<string>[],
        IVault$1.FundManagementStruct,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "exitPool", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        IVault$1.ExitPoolRequestStruct
    ]): string;
    encodeFunctionData(functionFragment: "getStETH", values?: undefined): string;
    encodeFunctionData(functionFragment: "getVault", values?: undefined): string;
    encodeFunctionData(functionFragment: "getWstETH", values?: undefined): string;
    encodeFunctionData(functionFragment: "joinPool", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        IVault$1.JoinPoolRequestStruct
    ]): string;
    encodeFunctionData(functionFragment: "swap", values: [
        IVault$1.SingleSwapStruct,
        IVault$1.FundManagementStruct,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    decodeFunctionResult(functionFragment: "batchSwap", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "exitPool", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getStETH", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getVault", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getWstETH", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "joinPool", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "swap", data: BytesLike): Result;
    events: {};
}
interface LidoRelayer extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: LidoRelayerInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        batchSwap(kind: PromiseOrValue<BigNumberish$1>, swaps: IVault$1.BatchSwapStepStruct[], assets: PromiseOrValue<string>[], funds: IVault$1.FundManagementStruct, limits: PromiseOrValue<BigNumberish$1>[], deadline: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        exitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, request: IVault$1.ExitPoolRequestStruct, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        getStETH(overrides?: CallOverrides): Promise<[string]>;
        getVault(overrides?: CallOverrides): Promise<[string]>;
        getWstETH(overrides?: CallOverrides): Promise<[string]>;
        joinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, request: IVault$1.JoinPoolRequestStruct, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        swap(singleSwap: IVault$1.SingleSwapStruct, funds: IVault$1.FundManagementStruct, limit: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
    };
    batchSwap(kind: PromiseOrValue<BigNumberish$1>, swaps: IVault$1.BatchSwapStepStruct[], assets: PromiseOrValue<string>[], funds: IVault$1.FundManagementStruct, limits: PromiseOrValue<BigNumberish$1>[], deadline: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    exitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, request: IVault$1.ExitPoolRequestStruct, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    getStETH(overrides?: CallOverrides): Promise<string>;
    getVault(overrides?: CallOverrides): Promise<string>;
    getWstETH(overrides?: CallOverrides): Promise<string>;
    joinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, request: IVault$1.JoinPoolRequestStruct, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    swap(singleSwap: IVault$1.SingleSwapStruct, funds: IVault$1.FundManagementStruct, limit: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        batchSwap(kind: PromiseOrValue<BigNumberish$1>, swaps: IVault$1.BatchSwapStepStruct[], assets: PromiseOrValue<string>[], funds: IVault$1.FundManagementStruct, limits: PromiseOrValue<BigNumberish$1>[], deadline: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1[]>;
        exitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, request: IVault$1.ExitPoolRequestStruct, overrides?: CallOverrides): Promise<void>;
        getStETH(overrides?: CallOverrides): Promise<string>;
        getVault(overrides?: CallOverrides): Promise<string>;
        getWstETH(overrides?: CallOverrides): Promise<string>;
        joinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, request: IVault$1.JoinPoolRequestStruct, overrides?: CallOverrides): Promise<void>;
        swap(singleSwap: IVault$1.SingleSwapStruct, funds: IVault$1.FundManagementStruct, limit: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
    };
    filters: {};
    estimateGas: {
        batchSwap(kind: PromiseOrValue<BigNumberish$1>, swaps: IVault$1.BatchSwapStepStruct[], assets: PromiseOrValue<string>[], funds: IVault$1.FundManagementStruct, limits: PromiseOrValue<BigNumberish$1>[], deadline: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        exitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, request: IVault$1.ExitPoolRequestStruct, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        getStETH(overrides?: CallOverrides): Promise<BigNumber$1>;
        getVault(overrides?: CallOverrides): Promise<BigNumber$1>;
        getWstETH(overrides?: CallOverrides): Promise<BigNumber$1>;
        joinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, request: IVault$1.JoinPoolRequestStruct, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        swap(singleSwap: IVault$1.SingleSwapStruct, funds: IVault$1.FundManagementStruct, limit: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
    };
    populateTransaction: {
        batchSwap(kind: PromiseOrValue<BigNumberish$1>, swaps: IVault$1.BatchSwapStepStruct[], assets: PromiseOrValue<string>[], funds: IVault$1.FundManagementStruct, limits: PromiseOrValue<BigNumberish$1>[], deadline: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        exitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, request: IVault$1.ExitPoolRequestStruct, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        getStETH(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getVault(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getWstETH(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        joinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, request: IVault$1.JoinPoolRequestStruct, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        swap(singleSwap: IVault$1.SingleSwapStruct, funds: IVault$1.FundManagementStruct, limit: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
    };
}

declare namespace IPoolSwapStructs$4 {
    type SwapRequestStruct = {
        kind: PromiseOrValue<BigNumberish$1>;
        tokenIn: PromiseOrValue<string>;
        tokenOut: PromiseOrValue<string>;
        amount: PromiseOrValue<BigNumberish$1>;
        poolId: PromiseOrValue<BytesLike>;
        lastChangeBlock: PromiseOrValue<BigNumberish$1>;
        from: PromiseOrValue<string>;
        to: PromiseOrValue<string>;
        userData: PromiseOrValue<BytesLike>;
    };
    type SwapRequestStructOutput = [
        number,
        string,
        string,
        BigNumber$1,
        string,
        BigNumber$1,
        string,
        string,
        string
    ] & {
        kind: number;
        tokenIn: string;
        tokenOut: string;
        amount: BigNumber$1;
        poolId: string;
        lastChangeBlock: BigNumber$1;
        from: string;
        to: string;
        userData: string;
    };
}
interface LinearPoolInterface$1 extends utils.Interface {
    functions: {
        "DOMAIN_SEPARATOR()": FunctionFragment;
        "allowance(address,address)": FunctionFragment;
        "approve(address,uint256)": FunctionFragment;
        "balanceOf(address)": FunctionFragment;
        "decimals()": FunctionFragment;
        "decreaseAllowance(address,uint256)": FunctionFragment;
        "getActionId(bytes4)": FunctionFragment;
        "getAuthorizer()": FunctionFragment;
        "getBptIndex()": FunctionFragment;
        "getMainIndex()": FunctionFragment;
        "getMainToken()": FunctionFragment;
        "getOwner()": FunctionFragment;
        "getPausedState()": FunctionFragment;
        "getPoolId()": FunctionFragment;
        "getRate()": FunctionFragment;
        "getScalingFactors()": FunctionFragment;
        "getSwapFeePercentage()": FunctionFragment;
        "getTargets()": FunctionFragment;
        "getVault()": FunctionFragment;
        "getVirtualSupply()": FunctionFragment;
        "getWrappedIndex()": FunctionFragment;
        "getWrappedToken()": FunctionFragment;
        "getWrappedTokenRate()": FunctionFragment;
        "increaseAllowance(address,uint256)": FunctionFragment;
        "initialize()": FunctionFragment;
        "name()": FunctionFragment;
        "nonces(address)": FunctionFragment;
        "onExitPool(bytes32,address,address,uint256[],uint256,uint256,bytes)": FunctionFragment;
        "onJoinPool(bytes32,address,address,uint256[],uint256,uint256,bytes)": FunctionFragment;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)": FunctionFragment;
        "permit(address,address,uint256,uint256,uint8,bytes32,bytes32)": FunctionFragment;
        "queryExit(bytes32,address,address,uint256[],uint256,uint256,bytes)": FunctionFragment;
        "queryJoin(bytes32,address,address,uint256[],uint256,uint256,bytes)": FunctionFragment;
        "setAssetManagerPoolConfig(address,bytes)": FunctionFragment;
        "setPaused(bool)": FunctionFragment;
        "setSwapFeePercentage(uint256)": FunctionFragment;
        "setTargets(uint256,uint256)": FunctionFragment;
        "symbol()": FunctionFragment;
        "totalSupply()": FunctionFragment;
        "transfer(address,uint256)": FunctionFragment;
        "transferFrom(address,address,uint256)": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "DOMAIN_SEPARATOR" | "allowance" | "approve" | "balanceOf" | "decimals" | "decreaseAllowance" | "getActionId" | "getAuthorizer" | "getBptIndex" | "getMainIndex" | "getMainToken" | "getOwner" | "getPausedState" | "getPoolId" | "getRate" | "getScalingFactors" | "getSwapFeePercentage" | "getTargets" | "getVault" | "getVirtualSupply" | "getWrappedIndex" | "getWrappedToken" | "getWrappedTokenRate" | "increaseAllowance" | "initialize" | "name" | "nonces" | "onExitPool" | "onJoinPool" | "onSwap" | "permit" | "queryExit" | "queryJoin" | "setAssetManagerPoolConfig" | "setPaused" | "setSwapFeePercentage" | "setTargets" | "symbol" | "totalSupply" | "transfer" | "transferFrom"): FunctionFragment;
    encodeFunctionData(functionFragment: "DOMAIN_SEPARATOR", values?: undefined): string;
    encodeFunctionData(functionFragment: "allowance", values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "approve", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "balanceOf", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "decimals", values?: undefined): string;
    encodeFunctionData(functionFragment: "decreaseAllowance", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "getActionId", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "getAuthorizer", values?: undefined): string;
    encodeFunctionData(functionFragment: "getBptIndex", values?: undefined): string;
    encodeFunctionData(functionFragment: "getMainIndex", values?: undefined): string;
    encodeFunctionData(functionFragment: "getMainToken", values?: undefined): string;
    encodeFunctionData(functionFragment: "getOwner", values?: undefined): string;
    encodeFunctionData(functionFragment: "getPausedState", values?: undefined): string;
    encodeFunctionData(functionFragment: "getPoolId", values?: undefined): string;
    encodeFunctionData(functionFragment: "getRate", values?: undefined): string;
    encodeFunctionData(functionFragment: "getScalingFactors", values?: undefined): string;
    encodeFunctionData(functionFragment: "getSwapFeePercentage", values?: undefined): string;
    encodeFunctionData(functionFragment: "getTargets", values?: undefined): string;
    encodeFunctionData(functionFragment: "getVault", values?: undefined): string;
    encodeFunctionData(functionFragment: "getVirtualSupply", values?: undefined): string;
    encodeFunctionData(functionFragment: "getWrappedIndex", values?: undefined): string;
    encodeFunctionData(functionFragment: "getWrappedToken", values?: undefined): string;
    encodeFunctionData(functionFragment: "getWrappedTokenRate", values?: undefined): string;
    encodeFunctionData(functionFragment: "increaseAllowance", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "initialize", values?: undefined): string;
    encodeFunctionData(functionFragment: "name", values?: undefined): string;
    encodeFunctionData(functionFragment: "nonces", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "onExitPool", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "onJoinPool", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "onSwap", values: [
        IPoolSwapStructs$4.SwapRequestStruct,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "permit", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "queryExit", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "queryJoin", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "setAssetManagerPoolConfig", values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "setPaused", values: [PromiseOrValue<boolean>]): string;
    encodeFunctionData(functionFragment: "setSwapFeePercentage", values: [PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "setTargets", values: [PromiseOrValue<BigNumberish$1>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "symbol", values?: undefined): string;
    encodeFunctionData(functionFragment: "totalSupply", values?: undefined): string;
    encodeFunctionData(functionFragment: "transfer", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "transferFrom", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    decodeFunctionResult(functionFragment: "DOMAIN_SEPARATOR", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "allowance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "approve", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "balanceOf", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "decimals", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "decreaseAllowance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getActionId", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getAuthorizer", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getBptIndex", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getMainIndex", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getMainToken", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getOwner", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getPausedState", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getPoolId", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getRate", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getScalingFactors", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getSwapFeePercentage", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getTargets", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getVault", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getVirtualSupply", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getWrappedIndex", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getWrappedToken", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getWrappedTokenRate", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "increaseAllowance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "name", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "nonces", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "onExitPool", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "onJoinPool", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "onSwap", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "permit", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "queryExit", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "queryJoin", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setAssetManagerPoolConfig", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setPaused", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setSwapFeePercentage", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setTargets", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "symbol", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "totalSupply", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "transfer", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "transferFrom", data: BytesLike): Result;
    events: {
        "Approval(address,address,uint256)": EventFragment;
        "PausedStateChanged(bool)": EventFragment;
        "SwapFeePercentageChanged(uint256)": EventFragment;
        "TargetsSet(address,uint256,uint256)": EventFragment;
        "Transfer(address,address,uint256)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "Approval"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "PausedStateChanged"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "SwapFeePercentageChanged"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "TargetsSet"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Transfer"): EventFragment;
}
interface ApprovalEventObject$5 {
    owner: string;
    spender: string;
    value: BigNumber$1;
}
type ApprovalEvent$5 = TypedEvent<[
    string,
    string,
    BigNumber$1
], ApprovalEventObject$5>;
type ApprovalEventFilter$5 = TypedEventFilter<ApprovalEvent$5>;
interface PausedStateChangedEventObject$5 {
    paused: boolean;
}
type PausedStateChangedEvent$5 = TypedEvent<[
    boolean
], PausedStateChangedEventObject$5>;
type PausedStateChangedEventFilter$5 = TypedEventFilter<PausedStateChangedEvent$5>;
interface SwapFeePercentageChangedEventObject$4 {
    swapFeePercentage: BigNumber$1;
}
type SwapFeePercentageChangedEvent$4 = TypedEvent<[
    BigNumber$1
], SwapFeePercentageChangedEventObject$4>;
type SwapFeePercentageChangedEventFilter$4 = TypedEventFilter<SwapFeePercentageChangedEvent$4>;
interface TargetsSetEventObject$1 {
    token: string;
    lowerTarget: BigNumber$1;
    upperTarget: BigNumber$1;
}
type TargetsSetEvent$1 = TypedEvent<[
    string,
    BigNumber$1,
    BigNumber$1
], TargetsSetEventObject$1>;
type TargetsSetEventFilter$1 = TypedEventFilter<TargetsSetEvent$1>;
interface TransferEventObject$5 {
    from: string;
    to: string;
    value: BigNumber$1;
}
type TransferEvent$5 = TypedEvent<[
    string,
    string,
    BigNumber$1
], TransferEventObject$5>;
type TransferEventFilter$5 = TypedEventFilter<TransferEvent$5>;
interface LinearPool extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: LinearPoolInterface$1;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<[string]>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        decimals(overrides?: CallOverrides): Promise<[number]>;
        decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[string]>;
        getAuthorizer(overrides?: CallOverrides): Promise<[string]>;
        getBptIndex(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getMainIndex(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getMainToken(overrides?: CallOverrides): Promise<[string]>;
        getOwner(overrides?: CallOverrides): Promise<[string]>;
        getPausedState(overrides?: CallOverrides): Promise<[
            boolean,
            BigNumber$1,
            BigNumber$1
        ] & {
            paused: boolean;
            pauseWindowEndTime: BigNumber$1;
            bufferPeriodEndTime: BigNumber$1;
        }>;
        getPoolId(overrides?: CallOverrides): Promise<[string]>;
        getRate(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getScalingFactors(overrides?: CallOverrides): Promise<[BigNumber$1[]]>;
        getSwapFeePercentage(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getTargets(overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1
        ] & {
            lowerTarget: BigNumber$1;
            upperTarget: BigNumber$1;
        }>;
        getVault(overrides?: CallOverrides): Promise<[string]>;
        getVirtualSupply(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getWrappedIndex(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getWrappedToken(overrides?: CallOverrides): Promise<[string]>;
        getWrappedTokenRate(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        initialize(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        name(overrides?: CallOverrides): Promise<[string]>;
        nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        onJoinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        onSwap(request: IPoolSwapStructs$4.SwapRequestStruct, balances: PromiseOrValue<BigNumberish$1>[], indexIn: PromiseOrValue<BigNumberish$1>, indexOut: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        queryExit(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        queryJoin(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setAssetManagerPoolConfig(token: PromiseOrValue<string>, poolConfig: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setPaused(paused: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setSwapFeePercentage(swapFeePercentage: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setTargets(newLowerTarget: PromiseOrValue<BigNumberish$1>, newUpperTarget: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        symbol(overrides?: CallOverrides): Promise<[string]>;
        totalSupply(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
    };
    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;
    allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    decimals(overrides?: CallOverrides): Promise<number>;
    decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
    getAuthorizer(overrides?: CallOverrides): Promise<string>;
    getBptIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
    getMainIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
    getMainToken(overrides?: CallOverrides): Promise<string>;
    getOwner(overrides?: CallOverrides): Promise<string>;
    getPausedState(overrides?: CallOverrides): Promise<[
        boolean,
        BigNumber$1,
        BigNumber$1
    ] & {
        paused: boolean;
        pauseWindowEndTime: BigNumber$1;
        bufferPeriodEndTime: BigNumber$1;
    }>;
    getPoolId(overrides?: CallOverrides): Promise<string>;
    getRate(overrides?: CallOverrides): Promise<BigNumber$1>;
    getScalingFactors(overrides?: CallOverrides): Promise<BigNumber$1[]>;
    getSwapFeePercentage(overrides?: CallOverrides): Promise<BigNumber$1>;
    getTargets(overrides?: CallOverrides): Promise<[
        BigNumber$1,
        BigNumber$1
    ] & {
        lowerTarget: BigNumber$1;
        upperTarget: BigNumber$1;
    }>;
    getVault(overrides?: CallOverrides): Promise<string>;
    getVirtualSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
    getWrappedIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
    getWrappedToken(overrides?: CallOverrides): Promise<string>;
    getWrappedTokenRate(overrides?: CallOverrides): Promise<BigNumber$1>;
    increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    initialize(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    name(overrides?: CallOverrides): Promise<string>;
    nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    onJoinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    onSwap(request: IPoolSwapStructs$4.SwapRequestStruct, balances: PromiseOrValue<BigNumberish$1>[], indexIn: PromiseOrValue<BigNumberish$1>, indexOut: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
    permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    queryExit(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    queryJoin(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setAssetManagerPoolConfig(token: PromiseOrValue<string>, poolConfig: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setPaused(paused: PromiseOrValue<boolean>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setSwapFeePercentage(swapFeePercentage: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setTargets(newLowerTarget: PromiseOrValue<BigNumberish$1>, newUpperTarget: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    symbol(overrides?: CallOverrides): Promise<string>;
    totalSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
    transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        decimals(overrides?: CallOverrides): Promise<number>;
        decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
        getAuthorizer(overrides?: CallOverrides): Promise<string>;
        getBptIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
        getMainIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
        getMainToken(overrides?: CallOverrides): Promise<string>;
        getOwner(overrides?: CallOverrides): Promise<string>;
        getPausedState(overrides?: CallOverrides): Promise<[
            boolean,
            BigNumber$1,
            BigNumber$1
        ] & {
            paused: boolean;
            pauseWindowEndTime: BigNumber$1;
            bufferPeriodEndTime: BigNumber$1;
        }>;
        getPoolId(overrides?: CallOverrides): Promise<string>;
        getRate(overrides?: CallOverrides): Promise<BigNumber$1>;
        getScalingFactors(overrides?: CallOverrides): Promise<BigNumber$1[]>;
        getSwapFeePercentage(overrides?: CallOverrides): Promise<BigNumber$1>;
        getTargets(overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1
        ] & {
            lowerTarget: BigNumber$1;
            upperTarget: BigNumber$1;
        }>;
        getVault(overrides?: CallOverrides): Promise<string>;
        getVirtualSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
        getWrappedIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
        getWrappedToken(overrides?: CallOverrides): Promise<string>;
        getWrappedTokenRate(overrides?: CallOverrides): Promise<BigNumber$1>;
        increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        initialize(overrides?: CallOverrides): Promise<void>;
        name(overrides?: CallOverrides): Promise<string>;
        nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[BigNumber$1[], BigNumber$1[]]>;
        onJoinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[BigNumber$1[], BigNumber$1[]]>;
        onSwap(request: IPoolSwapStructs$4.SwapRequestStruct, balances: PromiseOrValue<BigNumberish$1>[], indexIn: PromiseOrValue<BigNumberish$1>, indexOut: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<void>;
        queryExit(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1[]
        ] & {
            bptIn: BigNumber$1;
            amountsOut: BigNumber$1[];
        }>;
        queryJoin(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1[]
        ] & {
            bptOut: BigNumber$1;
            amountsIn: BigNumber$1[];
        }>;
        setAssetManagerPoolConfig(token: PromiseOrValue<string>, poolConfig: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<void>;
        setPaused(paused: PromiseOrValue<boolean>, overrides?: CallOverrides): Promise<void>;
        setSwapFeePercentage(swapFeePercentage: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        setTargets(newLowerTarget: PromiseOrValue<BigNumberish$1>, newUpperTarget: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        symbol(overrides?: CallOverrides): Promise<string>;
        totalSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
        transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
    };
    filters: {
        "Approval(address,address,uint256)"(owner?: PromiseOrValue<string> | null, spender?: PromiseOrValue<string> | null, value?: null): ApprovalEventFilter$5;
        Approval(owner?: PromiseOrValue<string> | null, spender?: PromiseOrValue<string> | null, value?: null): ApprovalEventFilter$5;
        "PausedStateChanged(bool)"(paused?: null): PausedStateChangedEventFilter$5;
        PausedStateChanged(paused?: null): PausedStateChangedEventFilter$5;
        "SwapFeePercentageChanged(uint256)"(swapFeePercentage?: null): SwapFeePercentageChangedEventFilter$4;
        SwapFeePercentageChanged(swapFeePercentage?: null): SwapFeePercentageChangedEventFilter$4;
        "TargetsSet(address,uint256,uint256)"(token?: PromiseOrValue<string> | null, lowerTarget?: null, upperTarget?: null): TargetsSetEventFilter$1;
        TargetsSet(token?: PromiseOrValue<string> | null, lowerTarget?: null, upperTarget?: null): TargetsSetEventFilter$1;
        "Transfer(address,address,uint256)"(from?: PromiseOrValue<string> | null, to?: PromiseOrValue<string> | null, value?: null): TransferEventFilter$5;
        Transfer(from?: PromiseOrValue<string> | null, to?: PromiseOrValue<string> | null, value?: null): TransferEventFilter$5;
    };
    estimateGas: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<BigNumber$1>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        decimals(overrides?: CallOverrides): Promise<BigNumber$1>;
        decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getAuthorizer(overrides?: CallOverrides): Promise<BigNumber$1>;
        getBptIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
        getMainIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
        getMainToken(overrides?: CallOverrides): Promise<BigNumber$1>;
        getOwner(overrides?: CallOverrides): Promise<BigNumber$1>;
        getPausedState(overrides?: CallOverrides): Promise<BigNumber$1>;
        getPoolId(overrides?: CallOverrides): Promise<BigNumber$1>;
        getRate(overrides?: CallOverrides): Promise<BigNumber$1>;
        getScalingFactors(overrides?: CallOverrides): Promise<BigNumber$1>;
        getSwapFeePercentage(overrides?: CallOverrides): Promise<BigNumber$1>;
        getTargets(overrides?: CallOverrides): Promise<BigNumber$1>;
        getVault(overrides?: CallOverrides): Promise<BigNumber$1>;
        getVirtualSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
        getWrappedIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
        getWrappedToken(overrides?: CallOverrides): Promise<BigNumber$1>;
        getWrappedTokenRate(overrides?: CallOverrides): Promise<BigNumber$1>;
        increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        initialize(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        name(overrides?: CallOverrides): Promise<BigNumber$1>;
        nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        onJoinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        onSwap(request: IPoolSwapStructs$4.SwapRequestStruct, balances: PromiseOrValue<BigNumberish$1>[], indexIn: PromiseOrValue<BigNumberish$1>, indexOut: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        queryExit(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        queryJoin(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        setAssetManagerPoolConfig(token: PromiseOrValue<string>, poolConfig: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        setPaused(paused: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        setSwapFeePercentage(swapFeePercentage: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        setTargets(newLowerTarget: PromiseOrValue<BigNumberish$1>, newUpperTarget: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        symbol(overrides?: CallOverrides): Promise<BigNumber$1>;
        totalSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
        transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
    };
    populateTransaction: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        decimals(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getAuthorizer(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getBptIndex(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getMainIndex(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getMainToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getOwner(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getPausedState(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getPoolId(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getRate(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getScalingFactors(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getSwapFeePercentage(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getTargets(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getVault(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getVirtualSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getWrappedIndex(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getWrappedToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getWrappedTokenRate(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        initialize(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        name(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        onJoinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        onSwap(request: IPoolSwapStructs$4.SwapRequestStruct, balances: PromiseOrValue<BigNumberish$1>[], indexIn: PromiseOrValue<BigNumberish$1>, indexOut: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        queryExit(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        queryJoin(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setAssetManagerPoolConfig(token: PromiseOrValue<string>, poolConfig: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setPaused(paused: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setSwapFeePercentage(swapFeePercentage: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setTargets(newLowerTarget: PromiseOrValue<BigNumberish$1>, newUpperTarget: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        symbol(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        totalSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
    };
}

interface LiquidityGaugeV5Interface extends utils.Interface {
    functions: {
        "deposit(uint256)": FunctionFragment;
        "deposit(uint256,address)": FunctionFragment;
        "deposit(uint256,address,bool)": FunctionFragment;
        "withdraw(uint256)": FunctionFragment;
        "withdraw(uint256,bool)": FunctionFragment;
        "claim_rewards()": FunctionFragment;
        "claim_rewards(address)": FunctionFragment;
        "claim_rewards(address,address)": FunctionFragment;
        "transferFrom(address,address,uint256)": FunctionFragment;
        "transfer(address,uint256)": FunctionFragment;
        "approve(address,uint256)": FunctionFragment;
        "permit(address,address,uint256,uint256,uint8,bytes32,bytes32)": FunctionFragment;
        "increaseAllowance(address,uint256)": FunctionFragment;
        "decreaseAllowance(address,uint256)": FunctionFragment;
        "user_checkpoint(address)": FunctionFragment;
        "set_rewards_receiver(address)": FunctionFragment;
        "kick(address)": FunctionFragment;
        "deposit_reward_token(address,uint256)": FunctionFragment;
        "add_reward(address,address)": FunctionFragment;
        "set_reward_distributor(address,address)": FunctionFragment;
        "set_killed(bool)": FunctionFragment;
        "claimed_reward(address,address)": FunctionFragment;
        "claimable_reward(address,address)": FunctionFragment;
        "claimable_reward_write(address,address)": FunctionFragment;
        "claimable_tokens(address)": FunctionFragment;
        "integrate_checkpoint()": FunctionFragment;
        "future_epoch_time()": FunctionFragment;
        "inflation_rate()": FunctionFragment;
        "decimals()": FunctionFragment;
        "version()": FunctionFragment;
        "allowance(address,address)": FunctionFragment;
        "initialize(address)": FunctionFragment;
        "balanceOf(address)": FunctionFragment;
        "totalSupply()": FunctionFragment;
        "name()": FunctionFragment;
        "symbol()": FunctionFragment;
        "DOMAIN_SEPARATOR()": FunctionFragment;
        "nonces(address)": FunctionFragment;
        "factory()": FunctionFragment;
        "lp_token()": FunctionFragment;
        "is_killed()": FunctionFragment;
        "reward_count()": FunctionFragment;
        "reward_data(address)": FunctionFragment;
        "rewards_receiver(address)": FunctionFragment;
        "reward_integral_for(address,address)": FunctionFragment;
        "working_balances(address)": FunctionFragment;
        "working_supply()": FunctionFragment;
        "integrate_inv_supply_of(address)": FunctionFragment;
        "integrate_checkpoint_of(address)": FunctionFragment;
        "integrate_fraction(address)": FunctionFragment;
        "period()": FunctionFragment;
        "reward_tokens(uint256)": FunctionFragment;
        "period_timestamp(uint256)": FunctionFragment;
        "integrate_inv_supply(uint256)": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "deposit(uint256)" | "deposit(uint256,address)" | "deposit(uint256,address,bool)" | "withdraw(uint256)" | "withdraw(uint256,bool)" | "claim_rewards()" | "claim_rewards(address)" | "claim_rewards(address,address)" | "transferFrom" | "transfer" | "approve" | "permit" | "increaseAllowance" | "decreaseAllowance" | "user_checkpoint" | "set_rewards_receiver" | "kick" | "deposit_reward_token" | "add_reward" | "set_reward_distributor" | "set_killed" | "claimed_reward" | "claimable_reward" | "claimable_reward_write" | "claimable_tokens" | "integrate_checkpoint" | "future_epoch_time" | "inflation_rate" | "decimals" | "version" | "allowance" | "initialize" | "balanceOf" | "totalSupply" | "name" | "symbol" | "DOMAIN_SEPARATOR" | "nonces" | "factory" | "lp_token" | "is_killed" | "reward_count" | "reward_data" | "rewards_receiver" | "reward_integral_for" | "working_balances" | "working_supply" | "integrate_inv_supply_of" | "integrate_checkpoint_of" | "integrate_fraction" | "period" | "reward_tokens" | "period_timestamp" | "integrate_inv_supply"): FunctionFragment;
    encodeFunctionData(functionFragment: "deposit(uint256)", values: [PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "deposit(uint256,address)", values: [PromiseOrValue<BigNumberish$1>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "deposit(uint256,address,bool)", values: [
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<string>,
        PromiseOrValue<boolean>
    ]): string;
    encodeFunctionData(functionFragment: "withdraw(uint256)", values: [PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "withdraw(uint256,bool)", values: [PromiseOrValue<BigNumberish$1>, PromiseOrValue<boolean>]): string;
    encodeFunctionData(functionFragment: "claim_rewards()", values?: undefined): string;
    encodeFunctionData(functionFragment: "claim_rewards(address)", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "claim_rewards(address,address)", values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "transferFrom", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "transfer", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "approve", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "permit", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "increaseAllowance", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "decreaseAllowance", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "user_checkpoint", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "set_rewards_receiver", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "kick", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "deposit_reward_token", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "add_reward", values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "set_reward_distributor", values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "set_killed", values: [PromiseOrValue<boolean>]): string;
    encodeFunctionData(functionFragment: "claimed_reward", values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "claimable_reward", values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "claimable_reward_write", values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "claimable_tokens", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "integrate_checkpoint", values?: undefined): string;
    encodeFunctionData(functionFragment: "future_epoch_time", values?: undefined): string;
    encodeFunctionData(functionFragment: "inflation_rate", values?: undefined): string;
    encodeFunctionData(functionFragment: "decimals", values?: undefined): string;
    encodeFunctionData(functionFragment: "version", values?: undefined): string;
    encodeFunctionData(functionFragment: "allowance", values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "initialize", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "balanceOf", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "totalSupply", values?: undefined): string;
    encodeFunctionData(functionFragment: "name", values?: undefined): string;
    encodeFunctionData(functionFragment: "symbol", values?: undefined): string;
    encodeFunctionData(functionFragment: "DOMAIN_SEPARATOR", values?: undefined): string;
    encodeFunctionData(functionFragment: "nonces", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "factory", values?: undefined): string;
    encodeFunctionData(functionFragment: "lp_token", values?: undefined): string;
    encodeFunctionData(functionFragment: "is_killed", values?: undefined): string;
    encodeFunctionData(functionFragment: "reward_count", values?: undefined): string;
    encodeFunctionData(functionFragment: "reward_data", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "rewards_receiver", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "reward_integral_for", values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "working_balances", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "working_supply", values?: undefined): string;
    encodeFunctionData(functionFragment: "integrate_inv_supply_of", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "integrate_checkpoint_of", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "integrate_fraction", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "period", values?: undefined): string;
    encodeFunctionData(functionFragment: "reward_tokens", values: [PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "period_timestamp", values: [PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "integrate_inv_supply", values: [PromiseOrValue<BigNumberish$1>]): string;
    decodeFunctionResult(functionFragment: "deposit(uint256)", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "deposit(uint256,address)", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "deposit(uint256,address,bool)", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "withdraw(uint256)", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "withdraw(uint256,bool)", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "claim_rewards()", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "claim_rewards(address)", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "claim_rewards(address,address)", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "transferFrom", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "transfer", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "approve", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "permit", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "increaseAllowance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "decreaseAllowance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "user_checkpoint", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "set_rewards_receiver", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "kick", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "deposit_reward_token", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "add_reward", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "set_reward_distributor", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "set_killed", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "claimed_reward", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "claimable_reward", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "claimable_reward_write", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "claimable_tokens", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "integrate_checkpoint", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "future_epoch_time", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "inflation_rate", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "decimals", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "version", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "allowance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "balanceOf", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "totalSupply", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "name", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "symbol", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "DOMAIN_SEPARATOR", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "nonces", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "factory", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "lp_token", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "is_killed", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "reward_count", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "reward_data", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "rewards_receiver", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "reward_integral_for", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "working_balances", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "working_supply", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "integrate_inv_supply_of", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "integrate_checkpoint_of", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "integrate_fraction", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "period", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "reward_tokens", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "period_timestamp", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "integrate_inv_supply", data: BytesLike): Result;
    events: {
        "Deposit(address,uint256)": EventFragment;
        "Withdraw(address,uint256)": EventFragment;
        "UpdateLiquidityLimit(address,uint256,uint256,uint256,uint256)": EventFragment;
        "Transfer(address,address,uint256)": EventFragment;
        "Approval(address,address,uint256)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "Deposit"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Withdraw"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "UpdateLiquidityLimit"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Transfer"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Approval"): EventFragment;
}
interface DepositEventObject$1 {
    provider: string;
    value: BigNumber$1;
}
type DepositEvent$1 = TypedEvent<[string, BigNumber$1], DepositEventObject$1>;
type DepositEventFilter$1 = TypedEventFilter<DepositEvent$1>;
interface WithdrawEventObject$1 {
    provider: string;
    value: BigNumber$1;
}
type WithdrawEvent$1 = TypedEvent<[
    string,
    BigNumber$1
], WithdrawEventObject$1>;
type WithdrawEventFilter$1 = TypedEventFilter<WithdrawEvent$1>;
interface UpdateLiquidityLimitEventObject {
    user: string;
    original_balance: BigNumber$1;
    original_supply: BigNumber$1;
    working_balance: BigNumber$1;
    working_supply: BigNumber$1;
}
type UpdateLiquidityLimitEvent = TypedEvent<[
    string,
    BigNumber$1,
    BigNumber$1,
    BigNumber$1,
    BigNumber$1
], UpdateLiquidityLimitEventObject>;
type UpdateLiquidityLimitEventFilter = TypedEventFilter<UpdateLiquidityLimitEvent>;
interface TransferEventObject$4 {
    _from: string;
    _to: string;
    _value: BigNumber$1;
}
type TransferEvent$4 = TypedEvent<[
    string,
    string,
    BigNumber$1
], TransferEventObject$4>;
type TransferEventFilter$4 = TypedEventFilter<TransferEvent$4>;
interface ApprovalEventObject$4 {
    _owner: string;
    _spender: string;
    _value: BigNumber$1;
}
type ApprovalEvent$4 = TypedEvent<[
    string,
    string,
    BigNumber$1
], ApprovalEventObject$4>;
type ApprovalEventFilter$4 = TypedEventFilter<ApprovalEvent$4>;
interface LiquidityGaugeV5 extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: LiquidityGaugeV5Interface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        "deposit(uint256)"(_value: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        "deposit(uint256,address)"(_value: PromiseOrValue<BigNumberish$1>, _addr: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        "deposit(uint256,address,bool)"(_value: PromiseOrValue<BigNumberish$1>, _addr: PromiseOrValue<string>, _claim_rewards: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        "withdraw(uint256)"(_value: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        "withdraw(uint256,bool)"(_value: PromiseOrValue<BigNumberish$1>, _claim_rewards: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        "claim_rewards()"(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        "claim_rewards(address)"(_addr: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        "claim_rewards(address,address)"(_addr: PromiseOrValue<string>, _receiver: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        transferFrom(_from: PromiseOrValue<string>, _to: PromiseOrValue<string>, _value: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        transfer(_to: PromiseOrValue<string>, _value: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        approve(_spender: PromiseOrValue<string>, _value: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        permit(_owner: PromiseOrValue<string>, _spender: PromiseOrValue<string>, _value: PromiseOrValue<BigNumberish$1>, _deadline: PromiseOrValue<BigNumberish$1>, _v: PromiseOrValue<BigNumberish$1>, _r: PromiseOrValue<BytesLike>, _s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        increaseAllowance(_spender: PromiseOrValue<string>, _added_value: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        decreaseAllowance(_spender: PromiseOrValue<string>, _subtracted_value: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        user_checkpoint(addr: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        set_rewards_receiver(_receiver: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        kick(addr: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        deposit_reward_token(_reward_token: PromiseOrValue<string>, _amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        add_reward(_reward_token: PromiseOrValue<string>, _distributor: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        set_reward_distributor(_reward_token: PromiseOrValue<string>, _distributor: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        set_killed(_is_killed: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        claimed_reward(_addr: PromiseOrValue<string>, _token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        claimable_reward(_user: PromiseOrValue<string>, _reward_token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        claimable_reward_write(_addr: PromiseOrValue<string>, _token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        claimable_tokens(addr: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        integrate_checkpoint(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        future_epoch_time(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        inflation_rate(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        decimals(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        version(overrides?: CallOverrides): Promise<[string]>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        initialize(_lp_token: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        balanceOf(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        totalSupply(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        name(overrides?: CallOverrides): Promise<[string]>;
        symbol(overrides?: CallOverrides): Promise<[string]>;
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<[string]>;
        nonces(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        factory(overrides?: CallOverrides): Promise<[string]>;
        lp_token(overrides?: CallOverrides): Promise<[string]>;
        is_killed(overrides?: CallOverrides): Promise<[boolean]>;
        reward_count(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        reward_data(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[
            [
                string,
                string,
                BigNumber$1,
                BigNumber$1,
                BigNumber$1,
                BigNumber$1
            ] & {
                token: string;
                distributor: string;
                period_finish: BigNumber$1;
                rate: BigNumber$1;
                last_update: BigNumber$1;
                integral: BigNumber$1;
            }
        ]>;
        rewards_receiver(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[string]>;
        reward_integral_for(arg0: PromiseOrValue<string>, arg1: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        working_balances(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        working_supply(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        integrate_inv_supply_of(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        integrate_checkpoint_of(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        integrate_fraction(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        period(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        reward_tokens(arg0: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<[string]>;
        period_timestamp(arg0: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        integrate_inv_supply(arg0: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
    };
    "deposit(uint256)"(_value: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    "deposit(uint256,address)"(_value: PromiseOrValue<BigNumberish$1>, _addr: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    "deposit(uint256,address,bool)"(_value: PromiseOrValue<BigNumberish$1>, _addr: PromiseOrValue<string>, _claim_rewards: PromiseOrValue<boolean>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    "withdraw(uint256)"(_value: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    "withdraw(uint256,bool)"(_value: PromiseOrValue<BigNumberish$1>, _claim_rewards: PromiseOrValue<boolean>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    "claim_rewards()"(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    "claim_rewards(address)"(_addr: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    "claim_rewards(address,address)"(_addr: PromiseOrValue<string>, _receiver: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    transferFrom(_from: PromiseOrValue<string>, _to: PromiseOrValue<string>, _value: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    transfer(_to: PromiseOrValue<string>, _value: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    approve(_spender: PromiseOrValue<string>, _value: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    permit(_owner: PromiseOrValue<string>, _spender: PromiseOrValue<string>, _value: PromiseOrValue<BigNumberish$1>, _deadline: PromiseOrValue<BigNumberish$1>, _v: PromiseOrValue<BigNumberish$1>, _r: PromiseOrValue<BytesLike>, _s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    increaseAllowance(_spender: PromiseOrValue<string>, _added_value: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    decreaseAllowance(_spender: PromiseOrValue<string>, _subtracted_value: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    user_checkpoint(addr: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    set_rewards_receiver(_receiver: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    kick(addr: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    deposit_reward_token(_reward_token: PromiseOrValue<string>, _amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    add_reward(_reward_token: PromiseOrValue<string>, _distributor: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    set_reward_distributor(_reward_token: PromiseOrValue<string>, _distributor: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    set_killed(_is_killed: PromiseOrValue<boolean>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    claimed_reward(_addr: PromiseOrValue<string>, _token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    claimable_reward(_user: PromiseOrValue<string>, _reward_token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    claimable_reward_write(_addr: PromiseOrValue<string>, _token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    claimable_tokens(addr: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    integrate_checkpoint(overrides?: CallOverrides): Promise<BigNumber$1>;
    future_epoch_time(overrides?: CallOverrides): Promise<BigNumber$1>;
    inflation_rate(overrides?: CallOverrides): Promise<BigNumber$1>;
    decimals(overrides?: CallOverrides): Promise<BigNumber$1>;
    version(overrides?: CallOverrides): Promise<string>;
    allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    initialize(_lp_token: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    balanceOf(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    totalSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
    name(overrides?: CallOverrides): Promise<string>;
    symbol(overrides?: CallOverrides): Promise<string>;
    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;
    nonces(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    factory(overrides?: CallOverrides): Promise<string>;
    lp_token(overrides?: CallOverrides): Promise<string>;
    is_killed(overrides?: CallOverrides): Promise<boolean>;
    reward_count(overrides?: CallOverrides): Promise<BigNumber$1>;
    reward_data(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[
        string,
        string,
        BigNumber$1,
        BigNumber$1,
        BigNumber$1,
        BigNumber$1
    ] & {
        token: string;
        distributor: string;
        period_finish: BigNumber$1;
        rate: BigNumber$1;
        last_update: BigNumber$1;
        integral: BigNumber$1;
    }>;
    rewards_receiver(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;
    reward_integral_for(arg0: PromiseOrValue<string>, arg1: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    working_balances(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    working_supply(overrides?: CallOverrides): Promise<BigNumber$1>;
    integrate_inv_supply_of(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    integrate_checkpoint_of(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    integrate_fraction(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    period(overrides?: CallOverrides): Promise<BigNumber$1>;
    reward_tokens(arg0: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<string>;
    period_timestamp(arg0: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
    integrate_inv_supply(arg0: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
    callStatic: {
        "deposit(uint256)"(_value: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        "deposit(uint256,address)"(_value: PromiseOrValue<BigNumberish$1>, _addr: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
        "deposit(uint256,address,bool)"(_value: PromiseOrValue<BigNumberish$1>, _addr: PromiseOrValue<string>, _claim_rewards: PromiseOrValue<boolean>, overrides?: CallOverrides): Promise<void>;
        "withdraw(uint256)"(_value: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        "withdraw(uint256,bool)"(_value: PromiseOrValue<BigNumberish$1>, _claim_rewards: PromiseOrValue<boolean>, overrides?: CallOverrides): Promise<void>;
        "claim_rewards()"(overrides?: CallOverrides): Promise<void>;
        "claim_rewards(address)"(_addr: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
        "claim_rewards(address,address)"(_addr: PromiseOrValue<string>, _receiver: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
        transferFrom(_from: PromiseOrValue<string>, _to: PromiseOrValue<string>, _value: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        transfer(_to: PromiseOrValue<string>, _value: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        approve(_spender: PromiseOrValue<string>, _value: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        permit(_owner: PromiseOrValue<string>, _spender: PromiseOrValue<string>, _value: PromiseOrValue<BigNumberish$1>, _deadline: PromiseOrValue<BigNumberish$1>, _v: PromiseOrValue<BigNumberish$1>, _r: PromiseOrValue<BytesLike>, _s: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<boolean>;
        increaseAllowance(_spender: PromiseOrValue<string>, _added_value: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        decreaseAllowance(_spender: PromiseOrValue<string>, _subtracted_value: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        user_checkpoint(addr: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
        set_rewards_receiver(_receiver: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
        kick(addr: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
        deposit_reward_token(_reward_token: PromiseOrValue<string>, _amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        add_reward(_reward_token: PromiseOrValue<string>, _distributor: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
        set_reward_distributor(_reward_token: PromiseOrValue<string>, _distributor: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
        set_killed(_is_killed: PromiseOrValue<boolean>, overrides?: CallOverrides): Promise<void>;
        claimed_reward(_addr: PromiseOrValue<string>, _token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        claimable_reward(_user: PromiseOrValue<string>, _reward_token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        claimable_reward_write(_addr: PromiseOrValue<string>, _token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        claimable_tokens(addr: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        integrate_checkpoint(overrides?: CallOverrides): Promise<BigNumber$1>;
        future_epoch_time(overrides?: CallOverrides): Promise<BigNumber$1>;
        inflation_rate(overrides?: CallOverrides): Promise<BigNumber$1>;
        decimals(overrides?: CallOverrides): Promise<BigNumber$1>;
        version(overrides?: CallOverrides): Promise<string>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        initialize(_lp_token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
        balanceOf(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        totalSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
        name(overrides?: CallOverrides): Promise<string>;
        symbol(overrides?: CallOverrides): Promise<string>;
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;
        nonces(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        factory(overrides?: CallOverrides): Promise<string>;
        lp_token(overrides?: CallOverrides): Promise<string>;
        is_killed(overrides?: CallOverrides): Promise<boolean>;
        reward_count(overrides?: CallOverrides): Promise<BigNumber$1>;
        reward_data(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[
            string,
            string,
            BigNumber$1,
            BigNumber$1,
            BigNumber$1,
            BigNumber$1
        ] & {
            token: string;
            distributor: string;
            period_finish: BigNumber$1;
            rate: BigNumber$1;
            last_update: BigNumber$1;
            integral: BigNumber$1;
        }>;
        rewards_receiver(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;
        reward_integral_for(arg0: PromiseOrValue<string>, arg1: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        working_balances(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        working_supply(overrides?: CallOverrides): Promise<BigNumber$1>;
        integrate_inv_supply_of(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        integrate_checkpoint_of(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        integrate_fraction(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        period(overrides?: CallOverrides): Promise<BigNumber$1>;
        reward_tokens(arg0: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<string>;
        period_timestamp(arg0: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        integrate_inv_supply(arg0: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
    };
    filters: {
        "Deposit(address,uint256)"(provider?: PromiseOrValue<string> | null, value?: null): DepositEventFilter$1;
        Deposit(provider?: PromiseOrValue<string> | null, value?: null): DepositEventFilter$1;
        "Withdraw(address,uint256)"(provider?: PromiseOrValue<string> | null, value?: null): WithdrawEventFilter$1;
        Withdraw(provider?: PromiseOrValue<string> | null, value?: null): WithdrawEventFilter$1;
        "UpdateLiquidityLimit(address,uint256,uint256,uint256,uint256)"(user?: PromiseOrValue<string> | null, original_balance?: null, original_supply?: null, working_balance?: null, working_supply?: null): UpdateLiquidityLimitEventFilter;
        UpdateLiquidityLimit(user?: PromiseOrValue<string> | null, original_balance?: null, original_supply?: null, working_balance?: null, working_supply?: null): UpdateLiquidityLimitEventFilter;
        "Transfer(address,address,uint256)"(_from?: PromiseOrValue<string> | null, _to?: PromiseOrValue<string> | null, _value?: null): TransferEventFilter$4;
        Transfer(_from?: PromiseOrValue<string> | null, _to?: PromiseOrValue<string> | null, _value?: null): TransferEventFilter$4;
        "Approval(address,address,uint256)"(_owner?: PromiseOrValue<string> | null, _spender?: PromiseOrValue<string> | null, _value?: null): ApprovalEventFilter$4;
        Approval(_owner?: PromiseOrValue<string> | null, _spender?: PromiseOrValue<string> | null, _value?: null): ApprovalEventFilter$4;
    };
    estimateGas: {
        "deposit(uint256)"(_value: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        "deposit(uint256,address)"(_value: PromiseOrValue<BigNumberish$1>, _addr: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        "deposit(uint256,address,bool)"(_value: PromiseOrValue<BigNumberish$1>, _addr: PromiseOrValue<string>, _claim_rewards: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        "withdraw(uint256)"(_value: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        "withdraw(uint256,bool)"(_value: PromiseOrValue<BigNumberish$1>, _claim_rewards: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        "claim_rewards()"(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        "claim_rewards(address)"(_addr: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        "claim_rewards(address,address)"(_addr: PromiseOrValue<string>, _receiver: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        transferFrom(_from: PromiseOrValue<string>, _to: PromiseOrValue<string>, _value: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        transfer(_to: PromiseOrValue<string>, _value: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        approve(_spender: PromiseOrValue<string>, _value: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        permit(_owner: PromiseOrValue<string>, _spender: PromiseOrValue<string>, _value: PromiseOrValue<BigNumberish$1>, _deadline: PromiseOrValue<BigNumberish$1>, _v: PromiseOrValue<BigNumberish$1>, _r: PromiseOrValue<BytesLike>, _s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        increaseAllowance(_spender: PromiseOrValue<string>, _added_value: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        decreaseAllowance(_spender: PromiseOrValue<string>, _subtracted_value: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        user_checkpoint(addr: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        set_rewards_receiver(_receiver: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        kick(addr: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        deposit_reward_token(_reward_token: PromiseOrValue<string>, _amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        add_reward(_reward_token: PromiseOrValue<string>, _distributor: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        set_reward_distributor(_reward_token: PromiseOrValue<string>, _distributor: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        set_killed(_is_killed: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        claimed_reward(_addr: PromiseOrValue<string>, _token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        claimable_reward(_user: PromiseOrValue<string>, _reward_token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        claimable_reward_write(_addr: PromiseOrValue<string>, _token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        claimable_tokens(addr: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        integrate_checkpoint(overrides?: CallOverrides): Promise<BigNumber$1>;
        future_epoch_time(overrides?: CallOverrides): Promise<BigNumber$1>;
        inflation_rate(overrides?: CallOverrides): Promise<BigNumber$1>;
        decimals(overrides?: CallOverrides): Promise<BigNumber$1>;
        version(overrides?: CallOverrides): Promise<BigNumber$1>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        initialize(_lp_token: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        balanceOf(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        totalSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
        name(overrides?: CallOverrides): Promise<BigNumber$1>;
        symbol(overrides?: CallOverrides): Promise<BigNumber$1>;
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<BigNumber$1>;
        nonces(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        factory(overrides?: CallOverrides): Promise<BigNumber$1>;
        lp_token(overrides?: CallOverrides): Promise<BigNumber$1>;
        is_killed(overrides?: CallOverrides): Promise<BigNumber$1>;
        reward_count(overrides?: CallOverrides): Promise<BigNumber$1>;
        reward_data(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        rewards_receiver(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        reward_integral_for(arg0: PromiseOrValue<string>, arg1: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        working_balances(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        working_supply(overrides?: CallOverrides): Promise<BigNumber$1>;
        integrate_inv_supply_of(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        integrate_checkpoint_of(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        integrate_fraction(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        period(overrides?: CallOverrides): Promise<BigNumber$1>;
        reward_tokens(arg0: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        period_timestamp(arg0: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        integrate_inv_supply(arg0: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
    };
    populateTransaction: {
        "deposit(uint256)"(_value: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        "deposit(uint256,address)"(_value: PromiseOrValue<BigNumberish$1>, _addr: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        "deposit(uint256,address,bool)"(_value: PromiseOrValue<BigNumberish$1>, _addr: PromiseOrValue<string>, _claim_rewards: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        "withdraw(uint256)"(_value: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        "withdraw(uint256,bool)"(_value: PromiseOrValue<BigNumberish$1>, _claim_rewards: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        "claim_rewards()"(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        "claim_rewards(address)"(_addr: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        "claim_rewards(address,address)"(_addr: PromiseOrValue<string>, _receiver: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        transferFrom(_from: PromiseOrValue<string>, _to: PromiseOrValue<string>, _value: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        transfer(_to: PromiseOrValue<string>, _value: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        approve(_spender: PromiseOrValue<string>, _value: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        permit(_owner: PromiseOrValue<string>, _spender: PromiseOrValue<string>, _value: PromiseOrValue<BigNumberish$1>, _deadline: PromiseOrValue<BigNumberish$1>, _v: PromiseOrValue<BigNumberish$1>, _r: PromiseOrValue<BytesLike>, _s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        increaseAllowance(_spender: PromiseOrValue<string>, _added_value: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        decreaseAllowance(_spender: PromiseOrValue<string>, _subtracted_value: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        user_checkpoint(addr: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        set_rewards_receiver(_receiver: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        kick(addr: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        deposit_reward_token(_reward_token: PromiseOrValue<string>, _amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        add_reward(_reward_token: PromiseOrValue<string>, _distributor: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        set_reward_distributor(_reward_token: PromiseOrValue<string>, _distributor: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        set_killed(_is_killed: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        claimed_reward(_addr: PromiseOrValue<string>, _token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        claimable_reward(_user: PromiseOrValue<string>, _reward_token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        claimable_reward_write(_addr: PromiseOrValue<string>, _token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        claimable_tokens(addr: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        integrate_checkpoint(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        future_epoch_time(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        inflation_rate(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        decimals(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        version(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        initialize(_lp_token: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        balanceOf(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        totalSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        name(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        symbol(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        nonces(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        factory(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        lp_token(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        is_killed(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        reward_count(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        reward_data(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        rewards_receiver(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        reward_integral_for(arg0: PromiseOrValue<string>, arg1: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        working_balances(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        working_supply(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        integrate_inv_supply_of(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        integrate_checkpoint_of(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        integrate_fraction(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        period(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        reward_tokens(arg0: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        period_timestamp(arg0: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        integrate_inv_supply(arg0: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
    };
}

interface MulticallInterface extends utils.Interface {
    functions: {
        "aggregate((address,bytes)[])": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "aggregate"): FunctionFragment;
    encodeFunctionData(functionFragment: "aggregate", values: [
        {
            target: PromiseOrValue<string>;
            callData: PromiseOrValue<BytesLike>;
        }[]
    ]): string;
    decodeFunctionResult(functionFragment: "aggregate", data: BytesLike): Result;
    events: {};
}
interface Multicall extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: MulticallInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        aggregate(calls: {
            target: PromiseOrValue<string>;
            callData: PromiseOrValue<BytesLike>;
        }[], overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
    };
    aggregate(calls: {
        target: PromiseOrValue<string>;
        callData: PromiseOrValue<BytesLike>;
    }[], overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        aggregate(calls: {
            target: PromiseOrValue<string>;
            callData: PromiseOrValue<BytesLike>;
        }[], overrides?: CallOverrides): Promise<[
            BigNumber$1,
            string[]
        ] & {
            blockNumber: BigNumber$1;
            returnData: string[];
        }>;
    };
    filters: {};
    estimateGas: {
        aggregate(calls: {
            target: PromiseOrValue<string>;
            callData: PromiseOrValue<BytesLike>;
        }[], overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
    };
    populateTransaction: {
        aggregate(calls: {
            target: PromiseOrValue<string>;
            callData: PromiseOrValue<BytesLike>;
        }[], overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
    };
}

interface Multicall3Interface extends utils.Interface {
    functions: {
        "aggregate((address,bytes)[])": FunctionFragment;
        "aggregate3((address,bool,bytes)[])": FunctionFragment;
        "aggregate3Value((address,bool,uint256,bytes)[])": FunctionFragment;
        "blockAndAggregate((address,bytes)[])": FunctionFragment;
        "getBasefee()": FunctionFragment;
        "getBlockHash(uint256)": FunctionFragment;
        "getBlockNumber()": FunctionFragment;
        "getChainId()": FunctionFragment;
        "getCurrentBlockCoinbase()": FunctionFragment;
        "getCurrentBlockDifficulty()": FunctionFragment;
        "getCurrentBlockGasLimit()": FunctionFragment;
        "getCurrentBlockTimestamp()": FunctionFragment;
        "getEthBalance(address)": FunctionFragment;
        "getLastBlockHash()": FunctionFragment;
        "tryAggregate(bool,(address,bytes)[])": FunctionFragment;
        "tryBlockAndAggregate(bool,(address,bytes)[])": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "aggregate" | "aggregate3" | "aggregate3Value" | "blockAndAggregate" | "getBasefee" | "getBlockHash" | "getBlockNumber" | "getChainId" | "getCurrentBlockCoinbase" | "getCurrentBlockDifficulty" | "getCurrentBlockGasLimit" | "getCurrentBlockTimestamp" | "getEthBalance" | "getLastBlockHash" | "tryAggregate" | "tryBlockAndAggregate"): FunctionFragment;
    encodeFunctionData(functionFragment: "aggregate", values: [Multicall3.CallStruct[]]): string;
    encodeFunctionData(functionFragment: "aggregate3", values: [Multicall3.Call3Struct[]]): string;
    encodeFunctionData(functionFragment: "aggregate3Value", values: [Multicall3.Call3ValueStruct[]]): string;
    encodeFunctionData(functionFragment: "blockAndAggregate", values: [Multicall3.CallStruct[]]): string;
    encodeFunctionData(functionFragment: "getBasefee", values?: undefined): string;
    encodeFunctionData(functionFragment: "getBlockHash", values: [PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "getBlockNumber", values?: undefined): string;
    encodeFunctionData(functionFragment: "getChainId", values?: undefined): string;
    encodeFunctionData(functionFragment: "getCurrentBlockCoinbase", values?: undefined): string;
    encodeFunctionData(functionFragment: "getCurrentBlockDifficulty", values?: undefined): string;
    encodeFunctionData(functionFragment: "getCurrentBlockGasLimit", values?: undefined): string;
    encodeFunctionData(functionFragment: "getCurrentBlockTimestamp", values?: undefined): string;
    encodeFunctionData(functionFragment: "getEthBalance", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "getLastBlockHash", values?: undefined): string;
    encodeFunctionData(functionFragment: "tryAggregate", values: [PromiseOrValue<boolean>, Multicall3.CallStruct[]]): string;
    encodeFunctionData(functionFragment: "tryBlockAndAggregate", values: [PromiseOrValue<boolean>, Multicall3.CallStruct[]]): string;
    decodeFunctionResult(functionFragment: "aggregate", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "aggregate3", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "aggregate3Value", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "blockAndAggregate", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getBasefee", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getBlockHash", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getBlockNumber", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getChainId", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getCurrentBlockCoinbase", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getCurrentBlockDifficulty", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getCurrentBlockGasLimit", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getCurrentBlockTimestamp", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getEthBalance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getLastBlockHash", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "tryAggregate", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "tryBlockAndAggregate", data: BytesLike): Result;
    events: {};
}
declare namespace Multicall3 {
    type CallStruct = {
        target: PromiseOrValue<string>;
        callData: PromiseOrValue<BytesLike>;
    };
    type CallStructOutput = [string, string] & {
        target: string;
        callData: string;
    };
    type Call3Struct = {
        target: PromiseOrValue<string>;
        allowFailure: PromiseOrValue<boolean>;
        callData: PromiseOrValue<BytesLike>;
    };
    type Call3StructOutput = [string, boolean, string] & {
        target: string;
        allowFailure: boolean;
        callData: string;
    };
    type ResultStruct = {
        success: PromiseOrValue<boolean>;
        returnData: PromiseOrValue<BytesLike>;
    };
    type ResultStructOutput = [boolean, string] & {
        success: boolean;
        returnData: string;
    };
    type Call3ValueStruct = {
        target: PromiseOrValue<string>;
        allowFailure: PromiseOrValue<boolean>;
        value: PromiseOrValue<BigNumberish$1>;
        callData: PromiseOrValue<BytesLike>;
    };
    type Call3ValueStructOutput = [string, boolean, BigNumber$1, string] & {
        target: string;
        allowFailure: boolean;
        value: BigNumber$1;
        callData: string;
    };
}
interface Multicall3 extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: Multicall3Interface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        aggregate(calls: Multicall3.CallStruct[], overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        aggregate3(calls: Multicall3.Call3Struct[], overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        aggregate3Value(calls: Multicall3.Call3ValueStruct[], overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        blockAndAggregate(calls: Multicall3.CallStruct[], overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        getBasefee(overrides?: CallOverrides): Promise<[BigNumber$1] & {
            basefee: BigNumber$1;
        }>;
        getBlockHash(blockNumber: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<[string] & {
            blockHash: string;
        }>;
        getBlockNumber(overrides?: CallOverrides): Promise<[BigNumber$1] & {
            blockNumber: BigNumber$1;
        }>;
        getChainId(overrides?: CallOverrides): Promise<[BigNumber$1] & {
            chainid: BigNumber$1;
        }>;
        getCurrentBlockCoinbase(overrides?: CallOverrides): Promise<[string] & {
            coinbase: string;
        }>;
        getCurrentBlockDifficulty(overrides?: CallOverrides): Promise<[BigNumber$1] & {
            difficulty: BigNumber$1;
        }>;
        getCurrentBlockGasLimit(overrides?: CallOverrides): Promise<[BigNumber$1] & {
            gaslimit: BigNumber$1;
        }>;
        getCurrentBlockTimestamp(overrides?: CallOverrides): Promise<[BigNumber$1] & {
            timestamp: BigNumber$1;
        }>;
        getEthBalance(addr: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1] & {
            balance: BigNumber$1;
        }>;
        getLastBlockHash(overrides?: CallOverrides): Promise<[string] & {
            blockHash: string;
        }>;
        tryAggregate(requireSuccess: PromiseOrValue<boolean>, calls: Multicall3.CallStruct[], overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        tryBlockAndAggregate(requireSuccess: PromiseOrValue<boolean>, calls: Multicall3.CallStruct[], overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
    };
    aggregate(calls: Multicall3.CallStruct[], overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    aggregate3(calls: Multicall3.Call3Struct[], overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    aggregate3Value(calls: Multicall3.Call3ValueStruct[], overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    blockAndAggregate(calls: Multicall3.CallStruct[], overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    getBasefee(overrides?: CallOverrides): Promise<BigNumber$1>;
    getBlockHash(blockNumber: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<string>;
    getBlockNumber(overrides?: CallOverrides): Promise<BigNumber$1>;
    getChainId(overrides?: CallOverrides): Promise<BigNumber$1>;
    getCurrentBlockCoinbase(overrides?: CallOverrides): Promise<string>;
    getCurrentBlockDifficulty(overrides?: CallOverrides): Promise<BigNumber$1>;
    getCurrentBlockGasLimit(overrides?: CallOverrides): Promise<BigNumber$1>;
    getCurrentBlockTimestamp(overrides?: CallOverrides): Promise<BigNumber$1>;
    getEthBalance(addr: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    getLastBlockHash(overrides?: CallOverrides): Promise<string>;
    tryAggregate(requireSuccess: PromiseOrValue<boolean>, calls: Multicall3.CallStruct[], overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    tryBlockAndAggregate(requireSuccess: PromiseOrValue<boolean>, calls: Multicall3.CallStruct[], overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        aggregate(calls: Multicall3.CallStruct[], overrides?: CallOverrides): Promise<[
            BigNumber$1,
            string[]
        ] & {
            blockNumber: BigNumber$1;
            returnData: string[];
        }>;
        aggregate3(calls: Multicall3.Call3Struct[], overrides?: CallOverrides): Promise<Multicall3.ResultStructOutput[]>;
        aggregate3Value(calls: Multicall3.Call3ValueStruct[], overrides?: CallOverrides): Promise<Multicall3.ResultStructOutput[]>;
        blockAndAggregate(calls: Multicall3.CallStruct[], overrides?: CallOverrides): Promise<[
            BigNumber$1,
            string,
            Multicall3.ResultStructOutput[]
        ] & {
            blockNumber: BigNumber$1;
            blockHash: string;
            returnData: Multicall3.ResultStructOutput[];
        }>;
        getBasefee(overrides?: CallOverrides): Promise<BigNumber$1>;
        getBlockHash(blockNumber: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<string>;
        getBlockNumber(overrides?: CallOverrides): Promise<BigNumber$1>;
        getChainId(overrides?: CallOverrides): Promise<BigNumber$1>;
        getCurrentBlockCoinbase(overrides?: CallOverrides): Promise<string>;
        getCurrentBlockDifficulty(overrides?: CallOverrides): Promise<BigNumber$1>;
        getCurrentBlockGasLimit(overrides?: CallOverrides): Promise<BigNumber$1>;
        getCurrentBlockTimestamp(overrides?: CallOverrides): Promise<BigNumber$1>;
        getEthBalance(addr: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getLastBlockHash(overrides?: CallOverrides): Promise<string>;
        tryAggregate(requireSuccess: PromiseOrValue<boolean>, calls: Multicall3.CallStruct[], overrides?: CallOverrides): Promise<Multicall3.ResultStructOutput[]>;
        tryBlockAndAggregate(requireSuccess: PromiseOrValue<boolean>, calls: Multicall3.CallStruct[], overrides?: CallOverrides): Promise<[
            BigNumber$1,
            string,
            Multicall3.ResultStructOutput[]
        ] & {
            blockNumber: BigNumber$1;
            blockHash: string;
            returnData: Multicall3.ResultStructOutput[];
        }>;
    };
    filters: {};
    estimateGas: {
        aggregate(calls: Multicall3.CallStruct[], overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        aggregate3(calls: Multicall3.Call3Struct[], overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        aggregate3Value(calls: Multicall3.Call3ValueStruct[], overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        blockAndAggregate(calls: Multicall3.CallStruct[], overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        getBasefee(overrides?: CallOverrides): Promise<BigNumber$1>;
        getBlockHash(blockNumber: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getBlockNumber(overrides?: CallOverrides): Promise<BigNumber$1>;
        getChainId(overrides?: CallOverrides): Promise<BigNumber$1>;
        getCurrentBlockCoinbase(overrides?: CallOverrides): Promise<BigNumber$1>;
        getCurrentBlockDifficulty(overrides?: CallOverrides): Promise<BigNumber$1>;
        getCurrentBlockGasLimit(overrides?: CallOverrides): Promise<BigNumber$1>;
        getCurrentBlockTimestamp(overrides?: CallOverrides): Promise<BigNumber$1>;
        getEthBalance(addr: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getLastBlockHash(overrides?: CallOverrides): Promise<BigNumber$1>;
        tryAggregate(requireSuccess: PromiseOrValue<boolean>, calls: Multicall3.CallStruct[], overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        tryBlockAndAggregate(requireSuccess: PromiseOrValue<boolean>, calls: Multicall3.CallStruct[], overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
    };
    populateTransaction: {
        aggregate(calls: Multicall3.CallStruct[], overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        aggregate3(calls: Multicall3.Call3Struct[], overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        aggregate3Value(calls: Multicall3.Call3ValueStruct[], overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        blockAndAggregate(calls: Multicall3.CallStruct[], overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        getBasefee(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getBlockHash(blockNumber: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getBlockNumber(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getChainId(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getCurrentBlockCoinbase(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getCurrentBlockDifficulty(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getCurrentBlockGasLimit(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getCurrentBlockTimestamp(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getEthBalance(addr: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getLastBlockHash(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        tryAggregate(requireSuccess: PromiseOrValue<boolean>, calls: Multicall3.CallStruct[], overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        tryBlockAndAggregate(requireSuccess: PromiseOrValue<boolean>, calls: Multicall3.CallStruct[], overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
    };
}

declare namespace IPoolSwapStructs$3 {
    type SwapRequestStruct = {
        kind: PromiseOrValue<BigNumberish$1>;
        tokenIn: PromiseOrValue<string>;
        tokenOut: PromiseOrValue<string>;
        amount: PromiseOrValue<BigNumberish$1>;
        poolId: PromiseOrValue<BytesLike>;
        lastChangeBlock: PromiseOrValue<BigNumberish$1>;
        from: PromiseOrValue<string>;
        to: PromiseOrValue<string>;
        userData: PromiseOrValue<BytesLike>;
    };
    type SwapRequestStructOutput = [
        number,
        string,
        string,
        BigNumber$1,
        string,
        BigNumber$1,
        string,
        string,
        string
    ] & {
        kind: number;
        tokenIn: string;
        tokenOut: string;
        amount: BigNumber$1;
        poolId: string;
        lastChangeBlock: BigNumber$1;
        from: string;
        to: string;
        userData: string;
    };
}
interface StablePoolInterface extends utils.Interface {
    functions: {
        "DOMAIN_SEPARATOR()": FunctionFragment;
        "allowance(address,address)": FunctionFragment;
        "approve(address,uint256)": FunctionFragment;
        "balanceOf(address)": FunctionFragment;
        "decimals()": FunctionFragment;
        "decreaseAllowance(address,uint256)": FunctionFragment;
        "getActionId(bytes4)": FunctionFragment;
        "getAmplificationParameter()": FunctionFragment;
        "getAuthorizer()": FunctionFragment;
        "getOwner()": FunctionFragment;
        "getPausedState()": FunctionFragment;
        "getPoolId()": FunctionFragment;
        "getRate()": FunctionFragment;
        "getSwapFeePercentage()": FunctionFragment;
        "getVault()": FunctionFragment;
        "increaseAllowance(address,uint256)": FunctionFragment;
        "name()": FunctionFragment;
        "nonces(address)": FunctionFragment;
        "onExitPool(bytes32,address,address,uint256[],uint256,uint256,bytes)": FunctionFragment;
        "onJoinPool(bytes32,address,address,uint256[],uint256,uint256,bytes)": FunctionFragment;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)": FunctionFragment;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)": FunctionFragment;
        "permit(address,address,uint256,uint256,uint8,bytes32,bytes32)": FunctionFragment;
        "queryExit(bytes32,address,address,uint256[],uint256,uint256,bytes)": FunctionFragment;
        "queryJoin(bytes32,address,address,uint256[],uint256,uint256,bytes)": FunctionFragment;
        "setAssetManagerPoolConfig(address,bytes)": FunctionFragment;
        "setPaused(bool)": FunctionFragment;
        "setSwapFeePercentage(uint256)": FunctionFragment;
        "startAmplificationParameterUpdate(uint256,uint256)": FunctionFragment;
        "stopAmplificationParameterUpdate()": FunctionFragment;
        "symbol()": FunctionFragment;
        "totalSupply()": FunctionFragment;
        "transfer(address,uint256)": FunctionFragment;
        "transferFrom(address,address,uint256)": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "DOMAIN_SEPARATOR" | "allowance" | "approve" | "balanceOf" | "decimals" | "decreaseAllowance" | "getActionId" | "getAmplificationParameter" | "getAuthorizer" | "getOwner" | "getPausedState" | "getPoolId" | "getRate" | "getSwapFeePercentage" | "getVault" | "increaseAllowance" | "name" | "nonces" | "onExitPool" | "onJoinPool" | "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)" | "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)" | "permit" | "queryExit" | "queryJoin" | "setAssetManagerPoolConfig" | "setPaused" | "setSwapFeePercentage" | "startAmplificationParameterUpdate" | "stopAmplificationParameterUpdate" | "symbol" | "totalSupply" | "transfer" | "transferFrom"): FunctionFragment;
    encodeFunctionData(functionFragment: "DOMAIN_SEPARATOR", values?: undefined): string;
    encodeFunctionData(functionFragment: "allowance", values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "approve", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "balanceOf", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "decimals", values?: undefined): string;
    encodeFunctionData(functionFragment: "decreaseAllowance", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "getActionId", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "getAmplificationParameter", values?: undefined): string;
    encodeFunctionData(functionFragment: "getAuthorizer", values?: undefined): string;
    encodeFunctionData(functionFragment: "getOwner", values?: undefined): string;
    encodeFunctionData(functionFragment: "getPausedState", values?: undefined): string;
    encodeFunctionData(functionFragment: "getPoolId", values?: undefined): string;
    encodeFunctionData(functionFragment: "getRate", values?: undefined): string;
    encodeFunctionData(functionFragment: "getSwapFeePercentage", values?: undefined): string;
    encodeFunctionData(functionFragment: "getVault", values?: undefined): string;
    encodeFunctionData(functionFragment: "increaseAllowance", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "name", values?: undefined): string;
    encodeFunctionData(functionFragment: "nonces", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "onExitPool", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "onJoinPool", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)", values: [
        IPoolSwapStructs$3.SwapRequestStruct,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)", values: [
        IPoolSwapStructs$3.SwapRequestStruct,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "permit", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "queryExit", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "queryJoin", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "setAssetManagerPoolConfig", values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "setPaused", values: [PromiseOrValue<boolean>]): string;
    encodeFunctionData(functionFragment: "setSwapFeePercentage", values: [PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "startAmplificationParameterUpdate", values: [PromiseOrValue<BigNumberish$1>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "stopAmplificationParameterUpdate", values?: undefined): string;
    encodeFunctionData(functionFragment: "symbol", values?: undefined): string;
    encodeFunctionData(functionFragment: "totalSupply", values?: undefined): string;
    encodeFunctionData(functionFragment: "transfer", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "transferFrom", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    decodeFunctionResult(functionFragment: "DOMAIN_SEPARATOR", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "allowance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "approve", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "balanceOf", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "decimals", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "decreaseAllowance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getActionId", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getAmplificationParameter", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getAuthorizer", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getOwner", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getPausedState", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getPoolId", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getRate", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getSwapFeePercentage", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getVault", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "increaseAllowance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "name", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "nonces", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "onExitPool", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "onJoinPool", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "permit", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "queryExit", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "queryJoin", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setAssetManagerPoolConfig", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setPaused", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setSwapFeePercentage", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "startAmplificationParameterUpdate", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "stopAmplificationParameterUpdate", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "symbol", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "totalSupply", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "transfer", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "transferFrom", data: BytesLike): Result;
    events: {
        "AmpUpdateStarted(uint256,uint256,uint256,uint256)": EventFragment;
        "AmpUpdateStopped(uint256)": EventFragment;
        "Approval(address,address,uint256)": EventFragment;
        "PausedStateChanged(bool)": EventFragment;
        "SwapFeePercentageChanged(uint256)": EventFragment;
        "Transfer(address,address,uint256)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "AmpUpdateStarted"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "AmpUpdateStopped"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Approval"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "PausedStateChanged"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "SwapFeePercentageChanged"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Transfer"): EventFragment;
}
interface AmpUpdateStartedEventObject {
    startValue: BigNumber$1;
    endValue: BigNumber$1;
    startTime: BigNumber$1;
    endTime: BigNumber$1;
}
type AmpUpdateStartedEvent = TypedEvent<[
    BigNumber$1,
    BigNumber$1,
    BigNumber$1,
    BigNumber$1
], AmpUpdateStartedEventObject>;
type AmpUpdateStartedEventFilter = TypedEventFilter<AmpUpdateStartedEvent>;
interface AmpUpdateStoppedEventObject {
    currentValue: BigNumber$1;
}
type AmpUpdateStoppedEvent = TypedEvent<[
    BigNumber$1
], AmpUpdateStoppedEventObject>;
type AmpUpdateStoppedEventFilter = TypedEventFilter<AmpUpdateStoppedEvent>;
interface ApprovalEventObject$3 {
    owner: string;
    spender: string;
    value: BigNumber$1;
}
type ApprovalEvent$3 = TypedEvent<[
    string,
    string,
    BigNumber$1
], ApprovalEventObject$3>;
type ApprovalEventFilter$3 = TypedEventFilter<ApprovalEvent$3>;
interface PausedStateChangedEventObject$4 {
    paused: boolean;
}
type PausedStateChangedEvent$4 = TypedEvent<[
    boolean
], PausedStateChangedEventObject$4>;
type PausedStateChangedEventFilter$4 = TypedEventFilter<PausedStateChangedEvent$4>;
interface SwapFeePercentageChangedEventObject$3 {
    swapFeePercentage: BigNumber$1;
}
type SwapFeePercentageChangedEvent$3 = TypedEvent<[
    BigNumber$1
], SwapFeePercentageChangedEventObject$3>;
type SwapFeePercentageChangedEventFilter$3 = TypedEventFilter<SwapFeePercentageChangedEvent$3>;
interface TransferEventObject$3 {
    from: string;
    to: string;
    value: BigNumber$1;
}
type TransferEvent$3 = TypedEvent<[
    string,
    string,
    BigNumber$1
], TransferEventObject$3>;
type TransferEventFilter$3 = TypedEventFilter<TransferEvent$3>;
interface StablePool extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: StablePoolInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<[string]>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        decimals(overrides?: CallOverrides): Promise<[number]>;
        decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[string]>;
        getAmplificationParameter(overrides?: CallOverrides): Promise<[
            BigNumber$1,
            boolean,
            BigNumber$1
        ] & {
            value: BigNumber$1;
            isUpdating: boolean;
            precision: BigNumber$1;
        }>;
        getAuthorizer(overrides?: CallOverrides): Promise<[string]>;
        getOwner(overrides?: CallOverrides): Promise<[string]>;
        getPausedState(overrides?: CallOverrides): Promise<[
            boolean,
            BigNumber$1,
            BigNumber$1
        ] & {
            paused: boolean;
            pauseWindowEndTime: BigNumber$1;
            bufferPeriodEndTime: BigNumber$1;
        }>;
        getPoolId(overrides?: CallOverrides): Promise<[string]>;
        getRate(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getSwapFeePercentage(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getVault(overrides?: CallOverrides): Promise<[string]>;
        increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        name(overrides?: CallOverrides): Promise<[string]>;
        nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        onJoinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)"(swapRequest: IPoolSwapStructs$3.SwapRequestStruct, balances: PromiseOrValue<BigNumberish$1>[], indexIn: PromiseOrValue<BigNumberish$1>, indexOut: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)"(request: IPoolSwapStructs$3.SwapRequestStruct, balanceTokenIn: PromiseOrValue<BigNumberish$1>, balanceTokenOut: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        queryExit(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        queryJoin(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setAssetManagerPoolConfig(token: PromiseOrValue<string>, poolConfig: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setPaused(paused: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setSwapFeePercentage(swapFeePercentage: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        startAmplificationParameterUpdate(rawEndValue: PromiseOrValue<BigNumberish$1>, endTime: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        stopAmplificationParameterUpdate(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        symbol(overrides?: CallOverrides): Promise<[string]>;
        totalSupply(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
    };
    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;
    allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    decimals(overrides?: CallOverrides): Promise<number>;
    decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
    getAmplificationParameter(overrides?: CallOverrides): Promise<[
        BigNumber$1,
        boolean,
        BigNumber$1
    ] & {
        value: BigNumber$1;
        isUpdating: boolean;
        precision: BigNumber$1;
    }>;
    getAuthorizer(overrides?: CallOverrides): Promise<string>;
    getOwner(overrides?: CallOverrides): Promise<string>;
    getPausedState(overrides?: CallOverrides): Promise<[
        boolean,
        BigNumber$1,
        BigNumber$1
    ] & {
        paused: boolean;
        pauseWindowEndTime: BigNumber$1;
        bufferPeriodEndTime: BigNumber$1;
    }>;
    getPoolId(overrides?: CallOverrides): Promise<string>;
    getRate(overrides?: CallOverrides): Promise<BigNumber$1>;
    getSwapFeePercentage(overrides?: CallOverrides): Promise<BigNumber$1>;
    getVault(overrides?: CallOverrides): Promise<string>;
    increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    name(overrides?: CallOverrides): Promise<string>;
    nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    onJoinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)"(swapRequest: IPoolSwapStructs$3.SwapRequestStruct, balances: PromiseOrValue<BigNumberish$1>[], indexIn: PromiseOrValue<BigNumberish$1>, indexOut: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
    "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)"(request: IPoolSwapStructs$3.SwapRequestStruct, balanceTokenIn: PromiseOrValue<BigNumberish$1>, balanceTokenOut: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
    permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    queryExit(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    queryJoin(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setAssetManagerPoolConfig(token: PromiseOrValue<string>, poolConfig: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setPaused(paused: PromiseOrValue<boolean>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setSwapFeePercentage(swapFeePercentage: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    startAmplificationParameterUpdate(rawEndValue: PromiseOrValue<BigNumberish$1>, endTime: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    stopAmplificationParameterUpdate(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    symbol(overrides?: CallOverrides): Promise<string>;
    totalSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
    transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        decimals(overrides?: CallOverrides): Promise<number>;
        decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
        getAmplificationParameter(overrides?: CallOverrides): Promise<[
            BigNumber$1,
            boolean,
            BigNumber$1
        ] & {
            value: BigNumber$1;
            isUpdating: boolean;
            precision: BigNumber$1;
        }>;
        getAuthorizer(overrides?: CallOverrides): Promise<string>;
        getOwner(overrides?: CallOverrides): Promise<string>;
        getPausedState(overrides?: CallOverrides): Promise<[
            boolean,
            BigNumber$1,
            BigNumber$1
        ] & {
            paused: boolean;
            pauseWindowEndTime: BigNumber$1;
            bufferPeriodEndTime: BigNumber$1;
        }>;
        getPoolId(overrides?: CallOverrides): Promise<string>;
        getRate(overrides?: CallOverrides): Promise<BigNumber$1>;
        getSwapFeePercentage(overrides?: CallOverrides): Promise<BigNumber$1>;
        getVault(overrides?: CallOverrides): Promise<string>;
        increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        name(overrides?: CallOverrides): Promise<string>;
        nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[BigNumber$1[], BigNumber$1[]]>;
        onJoinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[BigNumber$1[], BigNumber$1[]]>;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)"(swapRequest: IPoolSwapStructs$3.SwapRequestStruct, balances: PromiseOrValue<BigNumberish$1>[], indexIn: PromiseOrValue<BigNumberish$1>, indexOut: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)"(request: IPoolSwapStructs$3.SwapRequestStruct, balanceTokenIn: PromiseOrValue<BigNumberish$1>, balanceTokenOut: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<void>;
        queryExit(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1[]
        ] & {
            bptIn: BigNumber$1;
            amountsOut: BigNumber$1[];
        }>;
        queryJoin(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1[]
        ] & {
            bptOut: BigNumber$1;
            amountsIn: BigNumber$1[];
        }>;
        setAssetManagerPoolConfig(token: PromiseOrValue<string>, poolConfig: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<void>;
        setPaused(paused: PromiseOrValue<boolean>, overrides?: CallOverrides): Promise<void>;
        setSwapFeePercentage(swapFeePercentage: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        startAmplificationParameterUpdate(rawEndValue: PromiseOrValue<BigNumberish$1>, endTime: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        stopAmplificationParameterUpdate(overrides?: CallOverrides): Promise<void>;
        symbol(overrides?: CallOverrides): Promise<string>;
        totalSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
        transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
    };
    filters: {
        "AmpUpdateStarted(uint256,uint256,uint256,uint256)"(startValue?: null, endValue?: null, startTime?: null, endTime?: null): AmpUpdateStartedEventFilter;
        AmpUpdateStarted(startValue?: null, endValue?: null, startTime?: null, endTime?: null): AmpUpdateStartedEventFilter;
        "AmpUpdateStopped(uint256)"(currentValue?: null): AmpUpdateStoppedEventFilter;
        AmpUpdateStopped(currentValue?: null): AmpUpdateStoppedEventFilter;
        "Approval(address,address,uint256)"(owner?: PromiseOrValue<string> | null, spender?: PromiseOrValue<string> | null, value?: null): ApprovalEventFilter$3;
        Approval(owner?: PromiseOrValue<string> | null, spender?: PromiseOrValue<string> | null, value?: null): ApprovalEventFilter$3;
        "PausedStateChanged(bool)"(paused?: null): PausedStateChangedEventFilter$4;
        PausedStateChanged(paused?: null): PausedStateChangedEventFilter$4;
        "SwapFeePercentageChanged(uint256)"(swapFeePercentage?: null): SwapFeePercentageChangedEventFilter$3;
        SwapFeePercentageChanged(swapFeePercentage?: null): SwapFeePercentageChangedEventFilter$3;
        "Transfer(address,address,uint256)"(from?: PromiseOrValue<string> | null, to?: PromiseOrValue<string> | null, value?: null): TransferEventFilter$3;
        Transfer(from?: PromiseOrValue<string> | null, to?: PromiseOrValue<string> | null, value?: null): TransferEventFilter$3;
    };
    estimateGas: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<BigNumber$1>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        decimals(overrides?: CallOverrides): Promise<BigNumber$1>;
        decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getAmplificationParameter(overrides?: CallOverrides): Promise<BigNumber$1>;
        getAuthorizer(overrides?: CallOverrides): Promise<BigNumber$1>;
        getOwner(overrides?: CallOverrides): Promise<BigNumber$1>;
        getPausedState(overrides?: CallOverrides): Promise<BigNumber$1>;
        getPoolId(overrides?: CallOverrides): Promise<BigNumber$1>;
        getRate(overrides?: CallOverrides): Promise<BigNumber$1>;
        getSwapFeePercentage(overrides?: CallOverrides): Promise<BigNumber$1>;
        getVault(overrides?: CallOverrides): Promise<BigNumber$1>;
        increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        name(overrides?: CallOverrides): Promise<BigNumber$1>;
        nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        onJoinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)"(swapRequest: IPoolSwapStructs$3.SwapRequestStruct, balances: PromiseOrValue<BigNumberish$1>[], indexIn: PromiseOrValue<BigNumberish$1>, indexOut: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)"(request: IPoolSwapStructs$3.SwapRequestStruct, balanceTokenIn: PromiseOrValue<BigNumberish$1>, balanceTokenOut: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        queryExit(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        queryJoin(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        setAssetManagerPoolConfig(token: PromiseOrValue<string>, poolConfig: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        setPaused(paused: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        setSwapFeePercentage(swapFeePercentage: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        startAmplificationParameterUpdate(rawEndValue: PromiseOrValue<BigNumberish$1>, endTime: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        stopAmplificationParameterUpdate(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        symbol(overrides?: CallOverrides): Promise<BigNumber$1>;
        totalSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
        transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
    };
    populateTransaction: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        decimals(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getAmplificationParameter(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getAuthorizer(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getOwner(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getPausedState(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getPoolId(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getRate(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getSwapFeePercentage(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getVault(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        name(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        onJoinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)"(swapRequest: IPoolSwapStructs$3.SwapRequestStruct, balances: PromiseOrValue<BigNumberish$1>[], indexIn: PromiseOrValue<BigNumberish$1>, indexOut: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)"(request: IPoolSwapStructs$3.SwapRequestStruct, balanceTokenIn: PromiseOrValue<BigNumberish$1>, balanceTokenOut: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        queryExit(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        queryJoin(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setAssetManagerPoolConfig(token: PromiseOrValue<string>, poolConfig: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setPaused(paused: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setSwapFeePercentage(swapFeePercentage: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        startAmplificationParameterUpdate(rawEndValue: PromiseOrValue<BigNumberish$1>, endTime: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        stopAmplificationParameterUpdate(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        symbol(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        totalSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
    };
}

interface StaticATokenRateProviderInterface extends utils.Interface {
    functions: {
        "getRate()": FunctionFragment;
        "waToken()": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "getRate" | "waToken"): FunctionFragment;
    encodeFunctionData(functionFragment: "getRate", values?: undefined): string;
    encodeFunctionData(functionFragment: "waToken", values?: undefined): string;
    decodeFunctionResult(functionFragment: "getRate", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "waToken", data: BytesLike): Result;
    events: {};
}
interface StaticATokenRateProvider extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: StaticATokenRateProviderInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        getRate(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        waToken(overrides?: CallOverrides): Promise<[string]>;
    };
    getRate(overrides?: CallOverrides): Promise<BigNumber$1>;
    waToken(overrides?: CallOverrides): Promise<string>;
    callStatic: {
        getRate(overrides?: CallOverrides): Promise<BigNumber$1>;
        waToken(overrides?: CallOverrides): Promise<string>;
    };
    filters: {};
    estimateGas: {
        getRate(overrides?: CallOverrides): Promise<BigNumber$1>;
        waToken(overrides?: CallOverrides): Promise<BigNumber$1>;
    };
    populateTransaction: {
        getRate(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        waToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;
    };
}

declare namespace IVault {
    type BatchSwapStepStruct = {
        poolId: PromiseOrValue<BytesLike>;
        assetInIndex: PromiseOrValue<BigNumberish$1>;
        assetOutIndex: PromiseOrValue<BigNumberish$1>;
        amount: PromiseOrValue<BigNumberish$1>;
        userData: PromiseOrValue<BytesLike>;
    };
    type BatchSwapStepStructOutput = [
        string,
        BigNumber$1,
        BigNumber$1,
        BigNumber$1,
        string
    ] & {
        poolId: string;
        assetInIndex: BigNumber$1;
        assetOutIndex: BigNumber$1;
        amount: BigNumber$1;
        userData: string;
    };
    type FundManagementStruct = {
        sender: PromiseOrValue<string>;
        fromInternalBalance: PromiseOrValue<boolean>;
        recipient: PromiseOrValue<string>;
        toInternalBalance: PromiseOrValue<boolean>;
    };
    type FundManagementStructOutput = [
        string,
        boolean,
        string,
        boolean
    ] & {
        sender: string;
        fromInternalBalance: boolean;
        recipient: string;
        toInternalBalance: boolean;
    };
    type ExitPoolRequestStruct = {
        assets: PromiseOrValue<string>[];
        minAmountsOut: PromiseOrValue<BigNumberish$1>[];
        userData: PromiseOrValue<BytesLike>;
        toInternalBalance: PromiseOrValue<boolean>;
    };
    type ExitPoolRequestStructOutput = [
        string[],
        BigNumber$1[],
        string,
        boolean
    ] & {
        assets: string[];
        minAmountsOut: BigNumber$1[];
        userData: string;
        toInternalBalance: boolean;
    };
    type JoinPoolRequestStruct = {
        assets: PromiseOrValue<string>[];
        maxAmountsIn: PromiseOrValue<BigNumberish$1>[];
        userData: PromiseOrValue<BytesLike>;
        fromInternalBalance: PromiseOrValue<boolean>;
    };
    type JoinPoolRequestStructOutput = [
        string[],
        BigNumber$1[],
        string,
        boolean
    ] & {
        assets: string[];
        maxAmountsIn: BigNumber$1[];
        userData: string;
        fromInternalBalance: boolean;
    };
    type PoolBalanceOpStruct = {
        kind: PromiseOrValue<BigNumberish$1>;
        poolId: PromiseOrValue<BytesLike>;
        token: PromiseOrValue<string>;
        amount: PromiseOrValue<BigNumberish$1>;
    };
    type PoolBalanceOpStructOutput = [
        number,
        string,
        string,
        BigNumber$1
    ] & {
        kind: number;
        poolId: string;
        token: string;
        amount: BigNumber$1;
    };
    type UserBalanceOpStruct = {
        kind: PromiseOrValue<BigNumberish$1>;
        asset: PromiseOrValue<string>;
        amount: PromiseOrValue<BigNumberish$1>;
        sender: PromiseOrValue<string>;
        recipient: PromiseOrValue<string>;
    };
    type UserBalanceOpStructOutput = [
        number,
        string,
        BigNumber$1,
        string,
        string
    ] & {
        kind: number;
        asset: string;
        amount: BigNumber$1;
        sender: string;
        recipient: string;
    };
    type SingleSwapStruct = {
        poolId: PromiseOrValue<BytesLike>;
        kind: PromiseOrValue<BigNumberish$1>;
        assetIn: PromiseOrValue<string>;
        assetOut: PromiseOrValue<string>;
        amount: PromiseOrValue<BigNumberish$1>;
        userData: PromiseOrValue<BytesLike>;
    };
    type SingleSwapStructOutput = [
        string,
        number,
        string,
        string,
        BigNumber$1,
        string
    ] & {
        poolId: string;
        kind: number;
        assetIn: string;
        assetOut: string;
        amount: BigNumber$1;
        userData: string;
    };
}
interface VaultInterface extends utils.Interface {
    functions: {
        "WETH()": FunctionFragment;
        "batchSwap(uint8,(bytes32,uint256,uint256,uint256,bytes)[],address[],(address,bool,address,bool),int256[],uint256)": FunctionFragment;
        "deregisterTokens(bytes32,address[])": FunctionFragment;
        "exitPool(bytes32,address,address,(address[],uint256[],bytes,bool))": FunctionFragment;
        "flashLoan(address,address[],uint256[],bytes)": FunctionFragment;
        "getActionId(bytes4)": FunctionFragment;
        "getAuthorizer()": FunctionFragment;
        "getDomainSeparator()": FunctionFragment;
        "getInternalBalance(address,address[])": FunctionFragment;
        "getNextNonce(address)": FunctionFragment;
        "getPausedState()": FunctionFragment;
        "getPool(bytes32)": FunctionFragment;
        "getPoolTokenInfo(bytes32,address)": FunctionFragment;
        "getPoolTokens(bytes32)": FunctionFragment;
        "getProtocolFeesCollector()": FunctionFragment;
        "hasApprovedRelayer(address,address)": FunctionFragment;
        "joinPool(bytes32,address,address,(address[],uint256[],bytes,bool))": FunctionFragment;
        "managePoolBalance((uint8,bytes32,address,uint256)[])": FunctionFragment;
        "manageUserBalance((uint8,address,uint256,address,address)[])": FunctionFragment;
        "queryBatchSwap(uint8,(bytes32,uint256,uint256,uint256,bytes)[],address[],(address,bool,address,bool))": FunctionFragment;
        "registerPool(uint8)": FunctionFragment;
        "registerTokens(bytes32,address[],address[])": FunctionFragment;
        "setAuthorizer(address)": FunctionFragment;
        "setPaused(bool)": FunctionFragment;
        "setRelayerApproval(address,address,bool)": FunctionFragment;
        "swap((bytes32,uint8,address,address,uint256,bytes),(address,bool,address,bool),uint256,uint256)": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "WETH" | "batchSwap" | "deregisterTokens" | "exitPool" | "flashLoan" | "getActionId" | "getAuthorizer" | "getDomainSeparator" | "getInternalBalance" | "getNextNonce" | "getPausedState" | "getPool" | "getPoolTokenInfo" | "getPoolTokens" | "getProtocolFeesCollector" | "hasApprovedRelayer" | "joinPool" | "managePoolBalance" | "manageUserBalance" | "queryBatchSwap" | "registerPool" | "registerTokens" | "setAuthorizer" | "setPaused" | "setRelayerApproval" | "swap"): FunctionFragment;
    encodeFunctionData(functionFragment: "WETH", values?: undefined): string;
    encodeFunctionData(functionFragment: "batchSwap", values: [
        PromiseOrValue<BigNumberish$1>,
        IVault.BatchSwapStepStruct[],
        PromiseOrValue<string>[],
        IVault.FundManagementStruct,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "deregisterTokens", values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>[]]): string;
    encodeFunctionData(functionFragment: "exitPool", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        IVault.ExitPoolRequestStruct
    ]): string;
    encodeFunctionData(functionFragment: "flashLoan", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>[],
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "getActionId", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "getAuthorizer", values?: undefined): string;
    encodeFunctionData(functionFragment: "getDomainSeparator", values?: undefined): string;
    encodeFunctionData(functionFragment: "getInternalBalance", values: [PromiseOrValue<string>, PromiseOrValue<string>[]]): string;
    encodeFunctionData(functionFragment: "getNextNonce", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "getPausedState", values?: undefined): string;
    encodeFunctionData(functionFragment: "getPool", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "getPoolTokenInfo", values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "getPoolTokens", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "getProtocolFeesCollector", values?: undefined): string;
    encodeFunctionData(functionFragment: "hasApprovedRelayer", values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "joinPool", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        IVault.JoinPoolRequestStruct
    ]): string;
    encodeFunctionData(functionFragment: "managePoolBalance", values: [IVault.PoolBalanceOpStruct[]]): string;
    encodeFunctionData(functionFragment: "manageUserBalance", values: [IVault.UserBalanceOpStruct[]]): string;
    encodeFunctionData(functionFragment: "queryBatchSwap", values: [
        PromiseOrValue<BigNumberish$1>,
        IVault.BatchSwapStepStruct[],
        PromiseOrValue<string>[],
        IVault.FundManagementStruct
    ]): string;
    encodeFunctionData(functionFragment: "registerPool", values: [PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "registerTokens", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>[],
        PromiseOrValue<string>[]
    ]): string;
    encodeFunctionData(functionFragment: "setAuthorizer", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "setPaused", values: [PromiseOrValue<boolean>]): string;
    encodeFunctionData(functionFragment: "setRelayerApproval", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<boolean>
    ]): string;
    encodeFunctionData(functionFragment: "swap", values: [
        IVault.SingleSwapStruct,
        IVault.FundManagementStruct,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    decodeFunctionResult(functionFragment: "WETH", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "batchSwap", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "deregisterTokens", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "exitPool", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "flashLoan", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getActionId", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getAuthorizer", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getDomainSeparator", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getInternalBalance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getNextNonce", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getPausedState", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getPool", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getPoolTokenInfo", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getPoolTokens", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getProtocolFeesCollector", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "hasApprovedRelayer", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "joinPool", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "managePoolBalance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "manageUserBalance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "queryBatchSwap", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "registerPool", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "registerTokens", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setAuthorizer", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setPaused", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setRelayerApproval", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "swap", data: BytesLike): Result;
    events: {
        "AuthorizerChanged(address)": EventFragment;
        "ExternalBalanceTransfer(address,address,address,uint256)": EventFragment;
        "FlashLoan(address,address,uint256,uint256)": EventFragment;
        "InternalBalanceChanged(address,address,int256)": EventFragment;
        "PausedStateChanged(bool)": EventFragment;
        "PoolBalanceChanged(bytes32,address,address[],int256[],uint256[])": EventFragment;
        "PoolBalanceManaged(bytes32,address,address,int256,int256)": EventFragment;
        "PoolRegistered(bytes32,address,uint8)": EventFragment;
        "RelayerApprovalChanged(address,address,bool)": EventFragment;
        "Swap(bytes32,address,address,uint256,uint256)": EventFragment;
        "TokensDeregistered(bytes32,address[])": EventFragment;
        "TokensRegistered(bytes32,address[],address[])": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "AuthorizerChanged"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "ExternalBalanceTransfer"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "FlashLoan"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "InternalBalanceChanged"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "PausedStateChanged"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "PoolBalanceChanged"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "PoolBalanceManaged"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "PoolRegistered"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "RelayerApprovalChanged"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Swap"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "TokensDeregistered"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "TokensRegistered"): EventFragment;
}
interface AuthorizerChangedEventObject {
    newAuthorizer: string;
}
type AuthorizerChangedEvent = TypedEvent<[
    string
], AuthorizerChangedEventObject>;
type AuthorizerChangedEventFilter = TypedEventFilter<AuthorizerChangedEvent>;
interface ExternalBalanceTransferEventObject {
    token: string;
    sender: string;
    recipient: string;
    amount: BigNumber$1;
}
type ExternalBalanceTransferEvent = TypedEvent<[
    string,
    string,
    string,
    BigNumber$1
], ExternalBalanceTransferEventObject>;
type ExternalBalanceTransferEventFilter = TypedEventFilter<ExternalBalanceTransferEvent>;
interface FlashLoanEventObject {
    recipient: string;
    token: string;
    amount: BigNumber$1;
    feeAmount: BigNumber$1;
}
type FlashLoanEvent = TypedEvent<[
    string,
    string,
    BigNumber$1,
    BigNumber$1
], FlashLoanEventObject>;
type FlashLoanEventFilter = TypedEventFilter<FlashLoanEvent>;
interface InternalBalanceChangedEventObject {
    user: string;
    token: string;
    delta: BigNumber$1;
}
type InternalBalanceChangedEvent = TypedEvent<[
    string,
    string,
    BigNumber$1
], InternalBalanceChangedEventObject>;
type InternalBalanceChangedEventFilter = TypedEventFilter<InternalBalanceChangedEvent>;
interface PausedStateChangedEventObject$3 {
    paused: boolean;
}
type PausedStateChangedEvent$3 = TypedEvent<[
    boolean
], PausedStateChangedEventObject$3>;
type PausedStateChangedEventFilter$3 = TypedEventFilter<PausedStateChangedEvent$3>;
interface PoolBalanceChangedEventObject {
    poolId: string;
    liquidityProvider: string;
    tokens: string[];
    deltas: BigNumber$1[];
    protocolFeeAmounts: BigNumber$1[];
}
type PoolBalanceChangedEvent = TypedEvent<[
    string,
    string,
    string[],
    BigNumber$1[],
    BigNumber$1[]
], PoolBalanceChangedEventObject>;
type PoolBalanceChangedEventFilter = TypedEventFilter<PoolBalanceChangedEvent>;
interface PoolBalanceManagedEventObject {
    poolId: string;
    assetManager: string;
    token: string;
    cashDelta: BigNumber$1;
    managedDelta: BigNumber$1;
}
type PoolBalanceManagedEvent = TypedEvent<[
    string,
    string,
    string,
    BigNumber$1,
    BigNumber$1
], PoolBalanceManagedEventObject>;
type PoolBalanceManagedEventFilter = TypedEventFilter<PoolBalanceManagedEvent>;
interface PoolRegisteredEventObject {
    poolId: string;
    poolAddress: string;
    specialization: number;
}
type PoolRegisteredEvent = TypedEvent<[
    string,
    string,
    number
], PoolRegisteredEventObject>;
type PoolRegisteredEventFilter = TypedEventFilter<PoolRegisteredEvent>;
interface RelayerApprovalChangedEventObject {
    relayer: string;
    sender: string;
    approved: boolean;
}
type RelayerApprovalChangedEvent = TypedEvent<[
    string,
    string,
    boolean
], RelayerApprovalChangedEventObject>;
type RelayerApprovalChangedEventFilter = TypedEventFilter<RelayerApprovalChangedEvent>;
interface SwapEventObject {
    poolId: string;
    tokenIn: string;
    tokenOut: string;
    amountIn: BigNumber$1;
    amountOut: BigNumber$1;
}
type SwapEvent = TypedEvent<[
    string,
    string,
    string,
    BigNumber$1,
    BigNumber$1
], SwapEventObject>;
type SwapEventFilter = TypedEventFilter<SwapEvent>;
interface TokensDeregisteredEventObject {
    poolId: string;
    tokens: string[];
}
type TokensDeregisteredEvent = TypedEvent<[
    string,
    string[]
], TokensDeregisteredEventObject>;
type TokensDeregisteredEventFilter = TypedEventFilter<TokensDeregisteredEvent>;
interface TokensRegisteredEventObject {
    poolId: string;
    tokens: string[];
    assetManagers: string[];
}
type TokensRegisteredEvent = TypedEvent<[
    string,
    string[],
    string[]
], TokensRegisteredEventObject>;
type TokensRegisteredEventFilter = TypedEventFilter<TokensRegisteredEvent>;
interface Vault extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: VaultInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        WETH(overrides?: CallOverrides): Promise<[string]>;
        batchSwap(kind: PromiseOrValue<BigNumberish$1>, swaps: IVault.BatchSwapStepStruct[], assets: PromiseOrValue<string>[], funds: IVault.FundManagementStruct, limits: PromiseOrValue<BigNumberish$1>[], deadline: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        deregisterTokens(poolId: PromiseOrValue<BytesLike>, tokens: PromiseOrValue<string>[], overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        exitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, request: IVault.ExitPoolRequestStruct, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        flashLoan(recipient: PromiseOrValue<string>, tokens: PromiseOrValue<string>[], amounts: PromiseOrValue<BigNumberish$1>[], userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[string]>;
        getAuthorizer(overrides?: CallOverrides): Promise<[string]>;
        getDomainSeparator(overrides?: CallOverrides): Promise<[string]>;
        getInternalBalance(user: PromiseOrValue<string>, tokens: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<[BigNumber$1[]] & {
            balances: BigNumber$1[];
        }>;
        getNextNonce(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getPausedState(overrides?: CallOverrides): Promise<[
            boolean,
            BigNumber$1,
            BigNumber$1
        ] & {
            paused: boolean;
            pauseWindowEndTime: BigNumber$1;
            bufferPeriodEndTime: BigNumber$1;
        }>;
        getPool(poolId: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[string, number]>;
        getPoolTokenInfo(poolId: PromiseOrValue<BytesLike>, token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1,
            BigNumber$1,
            string
        ] & {
            cash: BigNumber$1;
            managed: BigNumber$1;
            lastChangeBlock: BigNumber$1;
            assetManager: string;
        }>;
        getPoolTokens(poolId: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[
            string[],
            BigNumber$1[],
            BigNumber$1
        ] & {
            tokens: string[];
            balances: BigNumber$1[];
            lastChangeBlock: BigNumber$1;
        }>;
        getProtocolFeesCollector(overrides?: CallOverrides): Promise<[string]>;
        hasApprovedRelayer(user: PromiseOrValue<string>, relayer: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;
        joinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, request: IVault.JoinPoolRequestStruct, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        managePoolBalance(ops: IVault.PoolBalanceOpStruct[], overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        manageUserBalance(ops: IVault.UserBalanceOpStruct[], overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        queryBatchSwap(kind: PromiseOrValue<BigNumberish$1>, swaps: IVault.BatchSwapStepStruct[], assets: PromiseOrValue<string>[], funds: IVault.FundManagementStruct, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        registerPool(specialization: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        registerTokens(poolId: PromiseOrValue<BytesLike>, tokens: PromiseOrValue<string>[], assetManagers: PromiseOrValue<string>[], overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setAuthorizer(newAuthorizer: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setPaused(paused: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setRelayerApproval(sender: PromiseOrValue<string>, relayer: PromiseOrValue<string>, approved: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        swap(singleSwap: IVault.SingleSwapStruct, funds: IVault.FundManagementStruct, limit: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
    };
    WETH(overrides?: CallOverrides): Promise<string>;
    batchSwap(kind: PromiseOrValue<BigNumberish$1>, swaps: IVault.BatchSwapStepStruct[], assets: PromiseOrValue<string>[], funds: IVault.FundManagementStruct, limits: PromiseOrValue<BigNumberish$1>[], deadline: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    deregisterTokens(poolId: PromiseOrValue<BytesLike>, tokens: PromiseOrValue<string>[], overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    exitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, request: IVault.ExitPoolRequestStruct, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    flashLoan(recipient: PromiseOrValue<string>, tokens: PromiseOrValue<string>[], amounts: PromiseOrValue<BigNumberish$1>[], userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
    getAuthorizer(overrides?: CallOverrides): Promise<string>;
    getDomainSeparator(overrides?: CallOverrides): Promise<string>;
    getInternalBalance(user: PromiseOrValue<string>, tokens: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<BigNumber$1[]>;
    getNextNonce(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    getPausedState(overrides?: CallOverrides): Promise<[
        boolean,
        BigNumber$1,
        BigNumber$1
    ] & {
        paused: boolean;
        pauseWindowEndTime: BigNumber$1;
        bufferPeriodEndTime: BigNumber$1;
    }>;
    getPool(poolId: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[string, number]>;
    getPoolTokenInfo(poolId: PromiseOrValue<BytesLike>, token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[
        BigNumber$1,
        BigNumber$1,
        BigNumber$1,
        string
    ] & {
        cash: BigNumber$1;
        managed: BigNumber$1;
        lastChangeBlock: BigNumber$1;
        assetManager: string;
    }>;
    getPoolTokens(poolId: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[
        string[],
        BigNumber$1[],
        BigNumber$1
    ] & {
        tokens: string[];
        balances: BigNumber$1[];
        lastChangeBlock: BigNumber$1;
    }>;
    getProtocolFeesCollector(overrides?: CallOverrides): Promise<string>;
    hasApprovedRelayer(user: PromiseOrValue<string>, relayer: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
    joinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, request: IVault.JoinPoolRequestStruct, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    managePoolBalance(ops: IVault.PoolBalanceOpStruct[], overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    manageUserBalance(ops: IVault.UserBalanceOpStruct[], overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    queryBatchSwap(kind: PromiseOrValue<BigNumberish$1>, swaps: IVault.BatchSwapStepStruct[], assets: PromiseOrValue<string>[], funds: IVault.FundManagementStruct, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    registerPool(specialization: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    registerTokens(poolId: PromiseOrValue<BytesLike>, tokens: PromiseOrValue<string>[], assetManagers: PromiseOrValue<string>[], overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setAuthorizer(newAuthorizer: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setPaused(paused: PromiseOrValue<boolean>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setRelayerApproval(sender: PromiseOrValue<string>, relayer: PromiseOrValue<string>, approved: PromiseOrValue<boolean>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    swap(singleSwap: IVault.SingleSwapStruct, funds: IVault.FundManagementStruct, limit: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        WETH(overrides?: CallOverrides): Promise<string>;
        batchSwap(kind: PromiseOrValue<BigNumberish$1>, swaps: IVault.BatchSwapStepStruct[], assets: PromiseOrValue<string>[], funds: IVault.FundManagementStruct, limits: PromiseOrValue<BigNumberish$1>[], deadline: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1[]>;
        deregisterTokens(poolId: PromiseOrValue<BytesLike>, tokens: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<void>;
        exitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, request: IVault.ExitPoolRequestStruct, overrides?: CallOverrides): Promise<void>;
        flashLoan(recipient: PromiseOrValue<string>, tokens: PromiseOrValue<string>[], amounts: PromiseOrValue<BigNumberish$1>[], userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<void>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
        getAuthorizer(overrides?: CallOverrides): Promise<string>;
        getDomainSeparator(overrides?: CallOverrides): Promise<string>;
        getInternalBalance(user: PromiseOrValue<string>, tokens: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<BigNumber$1[]>;
        getNextNonce(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getPausedState(overrides?: CallOverrides): Promise<[
            boolean,
            BigNumber$1,
            BigNumber$1
        ] & {
            paused: boolean;
            pauseWindowEndTime: BigNumber$1;
            bufferPeriodEndTime: BigNumber$1;
        }>;
        getPool(poolId: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[string, number]>;
        getPoolTokenInfo(poolId: PromiseOrValue<BytesLike>, token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1,
            BigNumber$1,
            string
        ] & {
            cash: BigNumber$1;
            managed: BigNumber$1;
            lastChangeBlock: BigNumber$1;
            assetManager: string;
        }>;
        getPoolTokens(poolId: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[
            string[],
            BigNumber$1[],
            BigNumber$1
        ] & {
            tokens: string[];
            balances: BigNumber$1[];
            lastChangeBlock: BigNumber$1;
        }>;
        getProtocolFeesCollector(overrides?: CallOverrides): Promise<string>;
        hasApprovedRelayer(user: PromiseOrValue<string>, relayer: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
        joinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, request: IVault.JoinPoolRequestStruct, overrides?: CallOverrides): Promise<void>;
        managePoolBalance(ops: IVault.PoolBalanceOpStruct[], overrides?: CallOverrides): Promise<void>;
        manageUserBalance(ops: IVault.UserBalanceOpStruct[], overrides?: CallOverrides): Promise<void>;
        queryBatchSwap(kind: PromiseOrValue<BigNumberish$1>, swaps: IVault.BatchSwapStepStruct[], assets: PromiseOrValue<string>[], funds: IVault.FundManagementStruct, overrides?: CallOverrides): Promise<BigNumber$1[]>;
        registerPool(specialization: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<string>;
        registerTokens(poolId: PromiseOrValue<BytesLike>, tokens: PromiseOrValue<string>[], assetManagers: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<void>;
        setAuthorizer(newAuthorizer: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
        setPaused(paused: PromiseOrValue<boolean>, overrides?: CallOverrides): Promise<void>;
        setRelayerApproval(sender: PromiseOrValue<string>, relayer: PromiseOrValue<string>, approved: PromiseOrValue<boolean>, overrides?: CallOverrides): Promise<void>;
        swap(singleSwap: IVault.SingleSwapStruct, funds: IVault.FundManagementStruct, limit: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
    };
    filters: {
        "AuthorizerChanged(address)"(newAuthorizer?: PromiseOrValue<string> | null): AuthorizerChangedEventFilter;
        AuthorizerChanged(newAuthorizer?: PromiseOrValue<string> | null): AuthorizerChangedEventFilter;
        "ExternalBalanceTransfer(address,address,address,uint256)"(token?: PromiseOrValue<string> | null, sender?: PromiseOrValue<string> | null, recipient?: null, amount?: null): ExternalBalanceTransferEventFilter;
        ExternalBalanceTransfer(token?: PromiseOrValue<string> | null, sender?: PromiseOrValue<string> | null, recipient?: null, amount?: null): ExternalBalanceTransferEventFilter;
        "FlashLoan(address,address,uint256,uint256)"(recipient?: PromiseOrValue<string> | null, token?: PromiseOrValue<string> | null, amount?: null, feeAmount?: null): FlashLoanEventFilter;
        FlashLoan(recipient?: PromiseOrValue<string> | null, token?: PromiseOrValue<string> | null, amount?: null, feeAmount?: null): FlashLoanEventFilter;
        "InternalBalanceChanged(address,address,int256)"(user?: PromiseOrValue<string> | null, token?: PromiseOrValue<string> | null, delta?: null): InternalBalanceChangedEventFilter;
        InternalBalanceChanged(user?: PromiseOrValue<string> | null, token?: PromiseOrValue<string> | null, delta?: null): InternalBalanceChangedEventFilter;
        "PausedStateChanged(bool)"(paused?: null): PausedStateChangedEventFilter$3;
        PausedStateChanged(paused?: null): PausedStateChangedEventFilter$3;
        "PoolBalanceChanged(bytes32,address,address[],int256[],uint256[])"(poolId?: PromiseOrValue<BytesLike> | null, liquidityProvider?: PromiseOrValue<string> | null, tokens?: null, deltas?: null, protocolFeeAmounts?: null): PoolBalanceChangedEventFilter;
        PoolBalanceChanged(poolId?: PromiseOrValue<BytesLike> | null, liquidityProvider?: PromiseOrValue<string> | null, tokens?: null, deltas?: null, protocolFeeAmounts?: null): PoolBalanceChangedEventFilter;
        "PoolBalanceManaged(bytes32,address,address,int256,int256)"(poolId?: PromiseOrValue<BytesLike> | null, assetManager?: PromiseOrValue<string> | null, token?: PromiseOrValue<string> | null, cashDelta?: null, managedDelta?: null): PoolBalanceManagedEventFilter;
        PoolBalanceManaged(poolId?: PromiseOrValue<BytesLike> | null, assetManager?: PromiseOrValue<string> | null, token?: PromiseOrValue<string> | null, cashDelta?: null, managedDelta?: null): PoolBalanceManagedEventFilter;
        "PoolRegistered(bytes32,address,uint8)"(poolId?: PromiseOrValue<BytesLike> | null, poolAddress?: PromiseOrValue<string> | null, specialization?: null): PoolRegisteredEventFilter;
        PoolRegistered(poolId?: PromiseOrValue<BytesLike> | null, poolAddress?: PromiseOrValue<string> | null, specialization?: null): PoolRegisteredEventFilter;
        "RelayerApprovalChanged(address,address,bool)"(relayer?: PromiseOrValue<string> | null, sender?: PromiseOrValue<string> | null, approved?: null): RelayerApprovalChangedEventFilter;
        RelayerApprovalChanged(relayer?: PromiseOrValue<string> | null, sender?: PromiseOrValue<string> | null, approved?: null): RelayerApprovalChangedEventFilter;
        "Swap(bytes32,address,address,uint256,uint256)"(poolId?: PromiseOrValue<BytesLike> | null, tokenIn?: PromiseOrValue<string> | null, tokenOut?: PromiseOrValue<string> | null, amountIn?: null, amountOut?: null): SwapEventFilter;
        Swap(poolId?: PromiseOrValue<BytesLike> | null, tokenIn?: PromiseOrValue<string> | null, tokenOut?: PromiseOrValue<string> | null, amountIn?: null, amountOut?: null): SwapEventFilter;
        "TokensDeregistered(bytes32,address[])"(poolId?: PromiseOrValue<BytesLike> | null, tokens?: null): TokensDeregisteredEventFilter;
        TokensDeregistered(poolId?: PromiseOrValue<BytesLike> | null, tokens?: null): TokensDeregisteredEventFilter;
        "TokensRegistered(bytes32,address[],address[])"(poolId?: PromiseOrValue<BytesLike> | null, tokens?: null, assetManagers?: null): TokensRegisteredEventFilter;
        TokensRegistered(poolId?: PromiseOrValue<BytesLike> | null, tokens?: null, assetManagers?: null): TokensRegisteredEventFilter;
    };
    estimateGas: {
        WETH(overrides?: CallOverrides): Promise<BigNumber$1>;
        batchSwap(kind: PromiseOrValue<BigNumberish$1>, swaps: IVault.BatchSwapStepStruct[], assets: PromiseOrValue<string>[], funds: IVault.FundManagementStruct, limits: PromiseOrValue<BigNumberish$1>[], deadline: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        deregisterTokens(poolId: PromiseOrValue<BytesLike>, tokens: PromiseOrValue<string>[], overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        exitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, request: IVault.ExitPoolRequestStruct, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        flashLoan(recipient: PromiseOrValue<string>, tokens: PromiseOrValue<string>[], amounts: PromiseOrValue<BigNumberish$1>[], userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getAuthorizer(overrides?: CallOverrides): Promise<BigNumber$1>;
        getDomainSeparator(overrides?: CallOverrides): Promise<BigNumber$1>;
        getInternalBalance(user: PromiseOrValue<string>, tokens: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<BigNumber$1>;
        getNextNonce(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getPausedState(overrides?: CallOverrides): Promise<BigNumber$1>;
        getPool(poolId: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getPoolTokenInfo(poolId: PromiseOrValue<BytesLike>, token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getPoolTokens(poolId: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getProtocolFeesCollector(overrides?: CallOverrides): Promise<BigNumber$1>;
        hasApprovedRelayer(user: PromiseOrValue<string>, relayer: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        joinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, request: IVault.JoinPoolRequestStruct, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        managePoolBalance(ops: IVault.PoolBalanceOpStruct[], overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        manageUserBalance(ops: IVault.UserBalanceOpStruct[], overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        queryBatchSwap(kind: PromiseOrValue<BigNumberish$1>, swaps: IVault.BatchSwapStepStruct[], assets: PromiseOrValue<string>[], funds: IVault.FundManagementStruct, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        registerPool(specialization: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        registerTokens(poolId: PromiseOrValue<BytesLike>, tokens: PromiseOrValue<string>[], assetManagers: PromiseOrValue<string>[], overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        setAuthorizer(newAuthorizer: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        setPaused(paused: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        setRelayerApproval(sender: PromiseOrValue<string>, relayer: PromiseOrValue<string>, approved: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        swap(singleSwap: IVault.SingleSwapStruct, funds: IVault.FundManagementStruct, limit: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
    };
    populateTransaction: {
        WETH(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        batchSwap(kind: PromiseOrValue<BigNumberish$1>, swaps: IVault.BatchSwapStepStruct[], assets: PromiseOrValue<string>[], funds: IVault.FundManagementStruct, limits: PromiseOrValue<BigNumberish$1>[], deadline: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        deregisterTokens(poolId: PromiseOrValue<BytesLike>, tokens: PromiseOrValue<string>[], overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        exitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, request: IVault.ExitPoolRequestStruct, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        flashLoan(recipient: PromiseOrValue<string>, tokens: PromiseOrValue<string>[], amounts: PromiseOrValue<BigNumberish$1>[], userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getAuthorizer(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getDomainSeparator(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getInternalBalance(user: PromiseOrValue<string>, tokens: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getNextNonce(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getPausedState(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getPool(poolId: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getPoolTokenInfo(poolId: PromiseOrValue<BytesLike>, token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getPoolTokens(poolId: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getProtocolFeesCollector(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        hasApprovedRelayer(user: PromiseOrValue<string>, relayer: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        joinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, request: IVault.JoinPoolRequestStruct, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        managePoolBalance(ops: IVault.PoolBalanceOpStruct[], overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        manageUserBalance(ops: IVault.UserBalanceOpStruct[], overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        queryBatchSwap(kind: PromiseOrValue<BigNumberish$1>, swaps: IVault.BatchSwapStepStruct[], assets: PromiseOrValue<string>[], funds: IVault.FundManagementStruct, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        registerPool(specialization: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        registerTokens(poolId: PromiseOrValue<BytesLike>, tokens: PromiseOrValue<string>[], assetManagers: PromiseOrValue<string>[], overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setAuthorizer(newAuthorizer: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setPaused(paused: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setRelayerApproval(sender: PromiseOrValue<string>, relayer: PromiseOrValue<string>, approved: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        swap(singleSwap: IVault.SingleSwapStruct, funds: IVault.FundManagementStruct, limit: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
    };
}

declare namespace IPoolSwapStructs$2 {
    type SwapRequestStruct = {
        kind: PromiseOrValue<BigNumberish$1>;
        tokenIn: PromiseOrValue<string>;
        tokenOut: PromiseOrValue<string>;
        amount: PromiseOrValue<BigNumberish$1>;
        poolId: PromiseOrValue<BytesLike>;
        lastChangeBlock: PromiseOrValue<BigNumberish$1>;
        from: PromiseOrValue<string>;
        to: PromiseOrValue<string>;
        userData: PromiseOrValue<BytesLike>;
    };
    type SwapRequestStructOutput = [
        number,
        string,
        string,
        BigNumber$1,
        string,
        BigNumber$1,
        string,
        string,
        string
    ] & {
        kind: number;
        tokenIn: string;
        tokenOut: string;
        amount: BigNumber$1;
        poolId: string;
        lastChangeBlock: BigNumber$1;
        from: string;
        to: string;
        userData: string;
    };
}
interface WeightedPoolInterface extends utils.Interface {
    functions: {
        "DELEGATE_PROTOCOL_SWAP_FEES_SENTINEL()": FunctionFragment;
        "DOMAIN_SEPARATOR()": FunctionFragment;
        "allowance(address,address)": FunctionFragment;
        "approve(address,uint256)": FunctionFragment;
        "balanceOf(address)": FunctionFragment;
        "decimals()": FunctionFragment;
        "decreaseAllowance(address,uint256)": FunctionFragment;
        "disableRecoveryMode()": FunctionFragment;
        "enableRecoveryMode()": FunctionFragment;
        "getATHRateProduct()": FunctionFragment;
        "getActionId(bytes4)": FunctionFragment;
        "getActualSupply()": FunctionFragment;
        "getAuthorizer()": FunctionFragment;
        "getDomainSeparator()": FunctionFragment;
        "getInvariant()": FunctionFragment;
        "getLastPostJoinExitInvariant()": FunctionFragment;
        "getNextNonce(address)": FunctionFragment;
        "getNormalizedWeights()": FunctionFragment;
        "getOwner()": FunctionFragment;
        "getPausedState()": FunctionFragment;
        "getPoolId()": FunctionFragment;
        "getProtocolFeePercentageCache(uint256)": FunctionFragment;
        "getProtocolFeesCollector()": FunctionFragment;
        "getProtocolSwapFeeDelegation()": FunctionFragment;
        "getRateProviders()": FunctionFragment;
        "getScalingFactors()": FunctionFragment;
        "getSwapFeePercentage()": FunctionFragment;
        "getVault()": FunctionFragment;
        "inRecoveryMode()": FunctionFragment;
        "increaseAllowance(address,uint256)": FunctionFragment;
        "name()": FunctionFragment;
        "nonces(address)": FunctionFragment;
        "onExitPool(bytes32,address,address,uint256[],uint256,uint256,bytes)": FunctionFragment;
        "onJoinPool(bytes32,address,address,uint256[],uint256,uint256,bytes)": FunctionFragment;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)": FunctionFragment;
        "pause()": FunctionFragment;
        "permit(address,address,uint256,uint256,uint8,bytes32,bytes32)": FunctionFragment;
        "queryExit(bytes32,address,address,uint256[],uint256,uint256,bytes)": FunctionFragment;
        "queryJoin(bytes32,address,address,uint256[],uint256,uint256,bytes)": FunctionFragment;
        "setAssetManagerPoolConfig(address,bytes)": FunctionFragment;
        "setSwapFeePercentage(uint256)": FunctionFragment;
        "symbol()": FunctionFragment;
        "totalSupply()": FunctionFragment;
        "transfer(address,uint256)": FunctionFragment;
        "transferFrom(address,address,uint256)": FunctionFragment;
        "unpause()": FunctionFragment;
        "updateProtocolFeePercentageCache()": FunctionFragment;
        "version()": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "DELEGATE_PROTOCOL_SWAP_FEES_SENTINEL" | "DOMAIN_SEPARATOR" | "allowance" | "approve" | "balanceOf" | "decimals" | "decreaseAllowance" | "disableRecoveryMode" | "enableRecoveryMode" | "getATHRateProduct" | "getActionId" | "getActualSupply" | "getAuthorizer" | "getDomainSeparator" | "getInvariant" | "getLastPostJoinExitInvariant" | "getNextNonce" | "getNormalizedWeights" | "getOwner" | "getPausedState" | "getPoolId" | "getProtocolFeePercentageCache" | "getProtocolFeesCollector" | "getProtocolSwapFeeDelegation" | "getRateProviders" | "getScalingFactors" | "getSwapFeePercentage" | "getVault" | "inRecoveryMode" | "increaseAllowance" | "name" | "nonces" | "onExitPool" | "onJoinPool" | "onSwap" | "pause" | "permit" | "queryExit" | "queryJoin" | "setAssetManagerPoolConfig" | "setSwapFeePercentage" | "symbol" | "totalSupply" | "transfer" | "transferFrom" | "unpause" | "updateProtocolFeePercentageCache" | "version"): FunctionFragment;
    encodeFunctionData(functionFragment: "DELEGATE_PROTOCOL_SWAP_FEES_SENTINEL", values?: undefined): string;
    encodeFunctionData(functionFragment: "DOMAIN_SEPARATOR", values?: undefined): string;
    encodeFunctionData(functionFragment: "allowance", values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "approve", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "balanceOf", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "decimals", values?: undefined): string;
    encodeFunctionData(functionFragment: "decreaseAllowance", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "disableRecoveryMode", values?: undefined): string;
    encodeFunctionData(functionFragment: "enableRecoveryMode", values?: undefined): string;
    encodeFunctionData(functionFragment: "getATHRateProduct", values?: undefined): string;
    encodeFunctionData(functionFragment: "getActionId", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "getActualSupply", values?: undefined): string;
    encodeFunctionData(functionFragment: "getAuthorizer", values?: undefined): string;
    encodeFunctionData(functionFragment: "getDomainSeparator", values?: undefined): string;
    encodeFunctionData(functionFragment: "getInvariant", values?: undefined): string;
    encodeFunctionData(functionFragment: "getLastPostJoinExitInvariant", values?: undefined): string;
    encodeFunctionData(functionFragment: "getNextNonce", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "getNormalizedWeights", values?: undefined): string;
    encodeFunctionData(functionFragment: "getOwner", values?: undefined): string;
    encodeFunctionData(functionFragment: "getPausedState", values?: undefined): string;
    encodeFunctionData(functionFragment: "getPoolId", values?: undefined): string;
    encodeFunctionData(functionFragment: "getProtocolFeePercentageCache", values: [PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "getProtocolFeesCollector", values?: undefined): string;
    encodeFunctionData(functionFragment: "getProtocolSwapFeeDelegation", values?: undefined): string;
    encodeFunctionData(functionFragment: "getRateProviders", values?: undefined): string;
    encodeFunctionData(functionFragment: "getScalingFactors", values?: undefined): string;
    encodeFunctionData(functionFragment: "getSwapFeePercentage", values?: undefined): string;
    encodeFunctionData(functionFragment: "getVault", values?: undefined): string;
    encodeFunctionData(functionFragment: "inRecoveryMode", values?: undefined): string;
    encodeFunctionData(functionFragment: "increaseAllowance", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "name", values?: undefined): string;
    encodeFunctionData(functionFragment: "nonces", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "onExitPool", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "onJoinPool", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "onSwap", values: [
        IPoolSwapStructs$2.SwapRequestStruct,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "pause", values?: undefined): string;
    encodeFunctionData(functionFragment: "permit", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "queryExit", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "queryJoin", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "setAssetManagerPoolConfig", values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "setSwapFeePercentage", values: [PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "symbol", values?: undefined): string;
    encodeFunctionData(functionFragment: "totalSupply", values?: undefined): string;
    encodeFunctionData(functionFragment: "transfer", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "transferFrom", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "unpause", values?: undefined): string;
    encodeFunctionData(functionFragment: "updateProtocolFeePercentageCache", values?: undefined): string;
    encodeFunctionData(functionFragment: "version", values?: undefined): string;
    decodeFunctionResult(functionFragment: "DELEGATE_PROTOCOL_SWAP_FEES_SENTINEL", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "DOMAIN_SEPARATOR", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "allowance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "approve", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "balanceOf", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "decimals", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "decreaseAllowance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "disableRecoveryMode", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "enableRecoveryMode", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getATHRateProduct", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getActionId", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getActualSupply", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getAuthorizer", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getDomainSeparator", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getInvariant", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getLastPostJoinExitInvariant", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getNextNonce", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getNormalizedWeights", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getOwner", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getPausedState", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getPoolId", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getProtocolFeePercentageCache", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getProtocolFeesCollector", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getProtocolSwapFeeDelegation", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getRateProviders", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getScalingFactors", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getSwapFeePercentage", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getVault", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "inRecoveryMode", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "increaseAllowance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "name", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "nonces", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "onExitPool", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "onJoinPool", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "onSwap", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "pause", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "permit", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "queryExit", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "queryJoin", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setAssetManagerPoolConfig", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setSwapFeePercentage", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "symbol", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "totalSupply", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "transfer", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "transferFrom", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "unpause", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "updateProtocolFeePercentageCache", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "version", data: BytesLike): Result;
    events: {
        "Approval(address,address,uint256)": EventFragment;
        "PausedStateChanged(bool)": EventFragment;
        "ProtocolFeePercentageCacheUpdated(uint256,uint256)": EventFragment;
        "RecoveryModeStateChanged(bool)": EventFragment;
        "SwapFeePercentageChanged(uint256)": EventFragment;
        "Transfer(address,address,uint256)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "Approval"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "PausedStateChanged"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "ProtocolFeePercentageCacheUpdated"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "RecoveryModeStateChanged"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "SwapFeePercentageChanged"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Transfer"): EventFragment;
}
interface ApprovalEventObject$2 {
    owner: string;
    spender: string;
    value: BigNumber$1;
}
type ApprovalEvent$2 = TypedEvent<[
    string,
    string,
    BigNumber$1
], ApprovalEventObject$2>;
type ApprovalEventFilter$2 = TypedEventFilter<ApprovalEvent$2>;
interface PausedStateChangedEventObject$2 {
    paused: boolean;
}
type PausedStateChangedEvent$2 = TypedEvent<[
    boolean
], PausedStateChangedEventObject$2>;
type PausedStateChangedEventFilter$2 = TypedEventFilter<PausedStateChangedEvent$2>;
interface ProtocolFeePercentageCacheUpdatedEventObject {
    feeType: BigNumber$1;
    protocolFeePercentage: BigNumber$1;
}
type ProtocolFeePercentageCacheUpdatedEvent = TypedEvent<[
    BigNumber$1,
    BigNumber$1
], ProtocolFeePercentageCacheUpdatedEventObject>;
type ProtocolFeePercentageCacheUpdatedEventFilter = TypedEventFilter<ProtocolFeePercentageCacheUpdatedEvent>;
interface RecoveryModeStateChangedEventObject$1 {
    enabled: boolean;
}
type RecoveryModeStateChangedEvent$1 = TypedEvent<[
    boolean
], RecoveryModeStateChangedEventObject$1>;
type RecoveryModeStateChangedEventFilter$1 = TypedEventFilter<RecoveryModeStateChangedEvent$1>;
interface SwapFeePercentageChangedEventObject$2 {
    swapFeePercentage: BigNumber$1;
}
type SwapFeePercentageChangedEvent$2 = TypedEvent<[
    BigNumber$1
], SwapFeePercentageChangedEventObject$2>;
type SwapFeePercentageChangedEventFilter$2 = TypedEventFilter<SwapFeePercentageChangedEvent$2>;
interface TransferEventObject$2 {
    from: string;
    to: string;
    value: BigNumber$1;
}
type TransferEvent$2 = TypedEvent<[
    string,
    string,
    BigNumber$1
], TransferEventObject$2>;
type TransferEventFilter$2 = TypedEventFilter<TransferEvent$2>;
declare namespace WeightedPool {
    type NewPoolParamsStruct = {
        name: PromiseOrValue<string>;
        symbol: PromiseOrValue<string>;
        tokens: PromiseOrValue<string>[];
        normalizedWeights: PromiseOrValue<BigNumberish$1>[];
        rateProviders: PromiseOrValue<string>[];
        assetManagers: PromiseOrValue<string>[];
        swapFeePercentage: PromiseOrValue<BigNumberish$1>;
    };
    type NewPoolParamsStructOutput = [
        string,
        string,
        string[],
        BigNumber$1[],
        string[],
        string[],
        BigNumber$1
    ] & {
        name: string;
        symbol: string;
        tokens: string[];
        normalizedWeights: BigNumber$1[];
        rateProviders: string[];
        assetManagers: string[];
        swapFeePercentage: BigNumber$1;
    };
}
interface WeightedPool extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: WeightedPoolInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        DELEGATE_PROTOCOL_SWAP_FEES_SENTINEL(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<[string]>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        decimals(overrides?: CallOverrides): Promise<[number]>;
        decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        disableRecoveryMode(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        enableRecoveryMode(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        getATHRateProduct(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[string]>;
        getActualSupply(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getAuthorizer(overrides?: CallOverrides): Promise<[string]>;
        getDomainSeparator(overrides?: CallOverrides): Promise<[string]>;
        getInvariant(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getLastPostJoinExitInvariant(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getNextNonce(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getNormalizedWeights(overrides?: CallOverrides): Promise<[BigNumber$1[]]>;
        getOwner(overrides?: CallOverrides): Promise<[string]>;
        getPausedState(overrides?: CallOverrides): Promise<[
            boolean,
            BigNumber$1,
            BigNumber$1
        ] & {
            paused: boolean;
            pauseWindowEndTime: BigNumber$1;
            bufferPeriodEndTime: BigNumber$1;
        }>;
        getPoolId(overrides?: CallOverrides): Promise<[string]>;
        getProtocolFeePercentageCache(feeType: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getProtocolFeesCollector(overrides?: CallOverrides): Promise<[string]>;
        getProtocolSwapFeeDelegation(overrides?: CallOverrides): Promise<[boolean]>;
        getRateProviders(overrides?: CallOverrides): Promise<[string[]]>;
        getScalingFactors(overrides?: CallOverrides): Promise<[BigNumber$1[]]>;
        getSwapFeePercentage(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getVault(overrides?: CallOverrides): Promise<[string]>;
        inRecoveryMode(overrides?: CallOverrides): Promise<[boolean]>;
        increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        name(overrides?: CallOverrides): Promise<[string]>;
        nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        onJoinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        onSwap(request: IPoolSwapStructs$2.SwapRequestStruct, balanceTokenIn: PromiseOrValue<BigNumberish$1>, balanceTokenOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        pause(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        queryExit(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        queryJoin(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setAssetManagerPoolConfig(token: PromiseOrValue<string>, poolConfig: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setSwapFeePercentage(swapFeePercentage: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        symbol(overrides?: CallOverrides): Promise<[string]>;
        totalSupply(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        unpause(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        updateProtocolFeePercentageCache(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        version(overrides?: CallOverrides): Promise<[string]>;
    };
    DELEGATE_PROTOCOL_SWAP_FEES_SENTINEL(overrides?: CallOverrides): Promise<BigNumber$1>;
    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;
    allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    decimals(overrides?: CallOverrides): Promise<number>;
    decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    disableRecoveryMode(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    enableRecoveryMode(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    getATHRateProduct(overrides?: CallOverrides): Promise<BigNumber$1>;
    getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
    getActualSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
    getAuthorizer(overrides?: CallOverrides): Promise<string>;
    getDomainSeparator(overrides?: CallOverrides): Promise<string>;
    getInvariant(overrides?: CallOverrides): Promise<BigNumber$1>;
    getLastPostJoinExitInvariant(overrides?: CallOverrides): Promise<BigNumber$1>;
    getNextNonce(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    getNormalizedWeights(overrides?: CallOverrides): Promise<BigNumber$1[]>;
    getOwner(overrides?: CallOverrides): Promise<string>;
    getPausedState(overrides?: CallOverrides): Promise<[
        boolean,
        BigNumber$1,
        BigNumber$1
    ] & {
        paused: boolean;
        pauseWindowEndTime: BigNumber$1;
        bufferPeriodEndTime: BigNumber$1;
    }>;
    getPoolId(overrides?: CallOverrides): Promise<string>;
    getProtocolFeePercentageCache(feeType: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
    getProtocolFeesCollector(overrides?: CallOverrides): Promise<string>;
    getProtocolSwapFeeDelegation(overrides?: CallOverrides): Promise<boolean>;
    getRateProviders(overrides?: CallOverrides): Promise<string[]>;
    getScalingFactors(overrides?: CallOverrides): Promise<BigNumber$1[]>;
    getSwapFeePercentage(overrides?: CallOverrides): Promise<BigNumber$1>;
    getVault(overrides?: CallOverrides): Promise<string>;
    inRecoveryMode(overrides?: CallOverrides): Promise<boolean>;
    increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    name(overrides?: CallOverrides): Promise<string>;
    nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    onJoinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    onSwap(request: IPoolSwapStructs$2.SwapRequestStruct, balanceTokenIn: PromiseOrValue<BigNumberish$1>, balanceTokenOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    pause(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    queryExit(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    queryJoin(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setAssetManagerPoolConfig(token: PromiseOrValue<string>, poolConfig: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setSwapFeePercentage(swapFeePercentage: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    symbol(overrides?: CallOverrides): Promise<string>;
    totalSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
    transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    unpause(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    updateProtocolFeePercentageCache(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    version(overrides?: CallOverrides): Promise<string>;
    callStatic: {
        DELEGATE_PROTOCOL_SWAP_FEES_SENTINEL(overrides?: CallOverrides): Promise<BigNumber$1>;
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        decimals(overrides?: CallOverrides): Promise<number>;
        decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        disableRecoveryMode(overrides?: CallOverrides): Promise<void>;
        enableRecoveryMode(overrides?: CallOverrides): Promise<void>;
        getATHRateProduct(overrides?: CallOverrides): Promise<BigNumber$1>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
        getActualSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
        getAuthorizer(overrides?: CallOverrides): Promise<string>;
        getDomainSeparator(overrides?: CallOverrides): Promise<string>;
        getInvariant(overrides?: CallOverrides): Promise<BigNumber$1>;
        getLastPostJoinExitInvariant(overrides?: CallOverrides): Promise<BigNumber$1>;
        getNextNonce(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getNormalizedWeights(overrides?: CallOverrides): Promise<BigNumber$1[]>;
        getOwner(overrides?: CallOverrides): Promise<string>;
        getPausedState(overrides?: CallOverrides): Promise<[
            boolean,
            BigNumber$1,
            BigNumber$1
        ] & {
            paused: boolean;
            pauseWindowEndTime: BigNumber$1;
            bufferPeriodEndTime: BigNumber$1;
        }>;
        getPoolId(overrides?: CallOverrides): Promise<string>;
        getProtocolFeePercentageCache(feeType: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getProtocolFeesCollector(overrides?: CallOverrides): Promise<string>;
        getProtocolSwapFeeDelegation(overrides?: CallOverrides): Promise<boolean>;
        getRateProviders(overrides?: CallOverrides): Promise<string[]>;
        getScalingFactors(overrides?: CallOverrides): Promise<BigNumber$1[]>;
        getSwapFeePercentage(overrides?: CallOverrides): Promise<BigNumber$1>;
        getVault(overrides?: CallOverrides): Promise<string>;
        inRecoveryMode(overrides?: CallOverrides): Promise<boolean>;
        increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        name(overrides?: CallOverrides): Promise<string>;
        nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[BigNumber$1[], BigNumber$1[]]>;
        onJoinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[BigNumber$1[], BigNumber$1[]]>;
        onSwap(request: IPoolSwapStructs$2.SwapRequestStruct, balanceTokenIn: PromiseOrValue<BigNumberish$1>, balanceTokenOut: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        pause(overrides?: CallOverrides): Promise<void>;
        permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<void>;
        queryExit(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1[]
        ] & {
            bptIn: BigNumber$1;
            amountsOut: BigNumber$1[];
        }>;
        queryJoin(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1[]
        ] & {
            bptOut: BigNumber$1;
            amountsIn: BigNumber$1[];
        }>;
        setAssetManagerPoolConfig(token: PromiseOrValue<string>, poolConfig: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<void>;
        setSwapFeePercentage(swapFeePercentage: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        symbol(overrides?: CallOverrides): Promise<string>;
        totalSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
        transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        unpause(overrides?: CallOverrides): Promise<void>;
        updateProtocolFeePercentageCache(overrides?: CallOverrides): Promise<void>;
        version(overrides?: CallOverrides): Promise<string>;
    };
    filters: {
        "Approval(address,address,uint256)"(owner?: PromiseOrValue<string> | null, spender?: PromiseOrValue<string> | null, value?: null): ApprovalEventFilter$2;
        Approval(owner?: PromiseOrValue<string> | null, spender?: PromiseOrValue<string> | null, value?: null): ApprovalEventFilter$2;
        "PausedStateChanged(bool)"(paused?: null): PausedStateChangedEventFilter$2;
        PausedStateChanged(paused?: null): PausedStateChangedEventFilter$2;
        "ProtocolFeePercentageCacheUpdated(uint256,uint256)"(feeType?: PromiseOrValue<BigNumberish$1> | null, protocolFeePercentage?: null): ProtocolFeePercentageCacheUpdatedEventFilter;
        ProtocolFeePercentageCacheUpdated(feeType?: PromiseOrValue<BigNumberish$1> | null, protocolFeePercentage?: null): ProtocolFeePercentageCacheUpdatedEventFilter;
        "RecoveryModeStateChanged(bool)"(enabled?: null): RecoveryModeStateChangedEventFilter$1;
        RecoveryModeStateChanged(enabled?: null): RecoveryModeStateChangedEventFilter$1;
        "SwapFeePercentageChanged(uint256)"(swapFeePercentage?: null): SwapFeePercentageChangedEventFilter$2;
        SwapFeePercentageChanged(swapFeePercentage?: null): SwapFeePercentageChangedEventFilter$2;
        "Transfer(address,address,uint256)"(from?: PromiseOrValue<string> | null, to?: PromiseOrValue<string> | null, value?: null): TransferEventFilter$2;
        Transfer(from?: PromiseOrValue<string> | null, to?: PromiseOrValue<string> | null, value?: null): TransferEventFilter$2;
    };
    estimateGas: {
        DELEGATE_PROTOCOL_SWAP_FEES_SENTINEL(overrides?: CallOverrides): Promise<BigNumber$1>;
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<BigNumber$1>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        decimals(overrides?: CallOverrides): Promise<BigNumber$1>;
        decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        disableRecoveryMode(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        enableRecoveryMode(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        getATHRateProduct(overrides?: CallOverrides): Promise<BigNumber$1>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getActualSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
        getAuthorizer(overrides?: CallOverrides): Promise<BigNumber$1>;
        getDomainSeparator(overrides?: CallOverrides): Promise<BigNumber$1>;
        getInvariant(overrides?: CallOverrides): Promise<BigNumber$1>;
        getLastPostJoinExitInvariant(overrides?: CallOverrides): Promise<BigNumber$1>;
        getNextNonce(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getNormalizedWeights(overrides?: CallOverrides): Promise<BigNumber$1>;
        getOwner(overrides?: CallOverrides): Promise<BigNumber$1>;
        getPausedState(overrides?: CallOverrides): Promise<BigNumber$1>;
        getPoolId(overrides?: CallOverrides): Promise<BigNumber$1>;
        getProtocolFeePercentageCache(feeType: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getProtocolFeesCollector(overrides?: CallOverrides): Promise<BigNumber$1>;
        getProtocolSwapFeeDelegation(overrides?: CallOverrides): Promise<BigNumber$1>;
        getRateProviders(overrides?: CallOverrides): Promise<BigNumber$1>;
        getScalingFactors(overrides?: CallOverrides): Promise<BigNumber$1>;
        getSwapFeePercentage(overrides?: CallOverrides): Promise<BigNumber$1>;
        getVault(overrides?: CallOverrides): Promise<BigNumber$1>;
        inRecoveryMode(overrides?: CallOverrides): Promise<BigNumber$1>;
        increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        name(overrides?: CallOverrides): Promise<BigNumber$1>;
        nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        onJoinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        onSwap(request: IPoolSwapStructs$2.SwapRequestStruct, balanceTokenIn: PromiseOrValue<BigNumberish$1>, balanceTokenOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        pause(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        queryExit(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        queryJoin(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        setAssetManagerPoolConfig(token: PromiseOrValue<string>, poolConfig: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        setSwapFeePercentage(swapFeePercentage: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        symbol(overrides?: CallOverrides): Promise<BigNumber$1>;
        totalSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
        transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        unpause(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        updateProtocolFeePercentageCache(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        version(overrides?: CallOverrides): Promise<BigNumber$1>;
    };
    populateTransaction: {
        DELEGATE_PROTOCOL_SWAP_FEES_SENTINEL(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        decimals(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        disableRecoveryMode(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        enableRecoveryMode(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        getATHRateProduct(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getActualSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getAuthorizer(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getDomainSeparator(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getInvariant(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getLastPostJoinExitInvariant(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getNextNonce(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getNormalizedWeights(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getOwner(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getPausedState(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getPoolId(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getProtocolFeePercentageCache(feeType: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getProtocolFeesCollector(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getProtocolSwapFeeDelegation(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getRateProviders(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getScalingFactors(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getSwapFeePercentage(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getVault(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        inRecoveryMode(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        name(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        onJoinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        onSwap(request: IPoolSwapStructs$2.SwapRequestStruct, balanceTokenIn: PromiseOrValue<BigNumberish$1>, balanceTokenOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        pause(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        queryExit(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        queryJoin(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setAssetManagerPoolConfig(token: PromiseOrValue<string>, poolConfig: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setSwapFeePercentage(swapFeePercentage: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        symbol(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        totalSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        unpause(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        updateProtocolFeePercentageCache(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        version(overrides?: CallOverrides): Promise<PopulatedTransaction>;
    };
}

interface WeightedPoolFactoryInterface extends utils.Interface {
    functions: {
        "create(string,string,address[],uint256[],address[],uint256,address,bytes32)": FunctionFragment;
        "disable()": FunctionFragment;
        "getActionId(bytes4)": FunctionFragment;
        "getAuthorizer()": FunctionFragment;
        "getCreationCode()": FunctionFragment;
        "getCreationCodeContracts()": FunctionFragment;
        "getPauseConfiguration()": FunctionFragment;
        "getPoolVersion()": FunctionFragment;
        "getProtocolFeePercentagesProvider()": FunctionFragment;
        "getVault()": FunctionFragment;
        "isDisabled()": FunctionFragment;
        "isPoolFromFactory(address)": FunctionFragment;
        "version()": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "create" | "disable" | "getActionId" | "getAuthorizer" | "getCreationCode" | "getCreationCodeContracts" | "getPauseConfiguration" | "getPoolVersion" | "getProtocolFeePercentagesProvider" | "getVault" | "isDisabled" | "isPoolFromFactory" | "version"): FunctionFragment;
    encodeFunctionData(functionFragment: "create", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<string>[],
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<string>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<string>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "disable", values?: undefined): string;
    encodeFunctionData(functionFragment: "getActionId", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "getAuthorizer", values?: undefined): string;
    encodeFunctionData(functionFragment: "getCreationCode", values?: undefined): string;
    encodeFunctionData(functionFragment: "getCreationCodeContracts", values?: undefined): string;
    encodeFunctionData(functionFragment: "getPauseConfiguration", values?: undefined): string;
    encodeFunctionData(functionFragment: "getPoolVersion", values?: undefined): string;
    encodeFunctionData(functionFragment: "getProtocolFeePercentagesProvider", values?: undefined): string;
    encodeFunctionData(functionFragment: "getVault", values?: undefined): string;
    encodeFunctionData(functionFragment: "isDisabled", values?: undefined): string;
    encodeFunctionData(functionFragment: "isPoolFromFactory", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "version", values?: undefined): string;
    decodeFunctionResult(functionFragment: "create", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "disable", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getActionId", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getAuthorizer", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getCreationCode", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getCreationCodeContracts", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getPauseConfiguration", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getPoolVersion", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getProtocolFeePercentagesProvider", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getVault", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isDisabled", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isPoolFromFactory", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "version", data: BytesLike): Result;
    events: {
        "FactoryDisabled()": EventFragment;
        "PoolCreated(address)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "FactoryDisabled"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "PoolCreated"): EventFragment;
}
interface FactoryDisabledEventObject$1 {
}
type FactoryDisabledEvent$1 = TypedEvent<[], FactoryDisabledEventObject$1>;
type FactoryDisabledEventFilter$1 = TypedEventFilter<FactoryDisabledEvent$1>;
interface PoolCreatedEventObject$1 {
    pool: string;
}
type PoolCreatedEvent$1 = TypedEvent<[string], PoolCreatedEventObject$1>;
type PoolCreatedEventFilter$1 = TypedEventFilter<PoolCreatedEvent$1>;
interface WeightedPoolFactory extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: WeightedPoolFactoryInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        create(name: PromiseOrValue<string>, symbol: PromiseOrValue<string>, tokens: PromiseOrValue<string>[], normalizedWeights: PromiseOrValue<BigNumberish$1>[], rateProviders: PromiseOrValue<string>[], swapFeePercentage: PromiseOrValue<BigNumberish$1>, owner: PromiseOrValue<string>, salt: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        disable(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[string]>;
        getAuthorizer(overrides?: CallOverrides): Promise<[string]>;
        getCreationCode(overrides?: CallOverrides): Promise<[string]>;
        getCreationCodeContracts(overrides?: CallOverrides): Promise<[string, string] & {
            contractA: string;
            contractB: string;
        }>;
        getPauseConfiguration(overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1
        ] & {
            pauseWindowDuration: BigNumber$1;
            bufferPeriodDuration: BigNumber$1;
        }>;
        getPoolVersion(overrides?: CallOverrides): Promise<[string]>;
        getProtocolFeePercentagesProvider(overrides?: CallOverrides): Promise<[string]>;
        getVault(overrides?: CallOverrides): Promise<[string]>;
        isDisabled(overrides?: CallOverrides): Promise<[boolean]>;
        isPoolFromFactory(pool: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;
        version(overrides?: CallOverrides): Promise<[string]>;
    };
    create(name: PromiseOrValue<string>, symbol: PromiseOrValue<string>, tokens: PromiseOrValue<string>[], normalizedWeights: PromiseOrValue<BigNumberish$1>[], rateProviders: PromiseOrValue<string>[], swapFeePercentage: PromiseOrValue<BigNumberish$1>, owner: PromiseOrValue<string>, salt: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    disable(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
    getAuthorizer(overrides?: CallOverrides): Promise<string>;
    getCreationCode(overrides?: CallOverrides): Promise<string>;
    getCreationCodeContracts(overrides?: CallOverrides): Promise<[string, string] & {
        contractA: string;
        contractB: string;
    }>;
    getPauseConfiguration(overrides?: CallOverrides): Promise<[
        BigNumber$1,
        BigNumber$1
    ] & {
        pauseWindowDuration: BigNumber$1;
        bufferPeriodDuration: BigNumber$1;
    }>;
    getPoolVersion(overrides?: CallOverrides): Promise<string>;
    getProtocolFeePercentagesProvider(overrides?: CallOverrides): Promise<string>;
    getVault(overrides?: CallOverrides): Promise<string>;
    isDisabled(overrides?: CallOverrides): Promise<boolean>;
    isPoolFromFactory(pool: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
    version(overrides?: CallOverrides): Promise<string>;
    callStatic: {
        create(name: PromiseOrValue<string>, symbol: PromiseOrValue<string>, tokens: PromiseOrValue<string>[], normalizedWeights: PromiseOrValue<BigNumberish$1>[], rateProviders: PromiseOrValue<string>[], swapFeePercentage: PromiseOrValue<BigNumberish$1>, owner: PromiseOrValue<string>, salt: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
        disable(overrides?: CallOverrides): Promise<void>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
        getAuthorizer(overrides?: CallOverrides): Promise<string>;
        getCreationCode(overrides?: CallOverrides): Promise<string>;
        getCreationCodeContracts(overrides?: CallOverrides): Promise<[string, string] & {
            contractA: string;
            contractB: string;
        }>;
        getPauseConfiguration(overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1
        ] & {
            pauseWindowDuration: BigNumber$1;
            bufferPeriodDuration: BigNumber$1;
        }>;
        getPoolVersion(overrides?: CallOverrides): Promise<string>;
        getProtocolFeePercentagesProvider(overrides?: CallOverrides): Promise<string>;
        getVault(overrides?: CallOverrides): Promise<string>;
        isDisabled(overrides?: CallOverrides): Promise<boolean>;
        isPoolFromFactory(pool: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
        version(overrides?: CallOverrides): Promise<string>;
    };
    filters: {
        "FactoryDisabled()"(): FactoryDisabledEventFilter$1;
        FactoryDisabled(): FactoryDisabledEventFilter$1;
        "PoolCreated(address)"(pool?: PromiseOrValue<string> | null): PoolCreatedEventFilter$1;
        PoolCreated(pool?: PromiseOrValue<string> | null): PoolCreatedEventFilter$1;
    };
    estimateGas: {
        create(name: PromiseOrValue<string>, symbol: PromiseOrValue<string>, tokens: PromiseOrValue<string>[], normalizedWeights: PromiseOrValue<BigNumberish$1>[], rateProviders: PromiseOrValue<string>[], swapFeePercentage: PromiseOrValue<BigNumberish$1>, owner: PromiseOrValue<string>, salt: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        disable(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getAuthorizer(overrides?: CallOverrides): Promise<BigNumber$1>;
        getCreationCode(overrides?: CallOverrides): Promise<BigNumber$1>;
        getCreationCodeContracts(overrides?: CallOverrides): Promise<BigNumber$1>;
        getPauseConfiguration(overrides?: CallOverrides): Promise<BigNumber$1>;
        getPoolVersion(overrides?: CallOverrides): Promise<BigNumber$1>;
        getProtocolFeePercentagesProvider(overrides?: CallOverrides): Promise<BigNumber$1>;
        getVault(overrides?: CallOverrides): Promise<BigNumber$1>;
        isDisabled(overrides?: CallOverrides): Promise<BigNumber$1>;
        isPoolFromFactory(pool: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        version(overrides?: CallOverrides): Promise<BigNumber$1>;
    };
    populateTransaction: {
        create(name: PromiseOrValue<string>, symbol: PromiseOrValue<string>, tokens: PromiseOrValue<string>[], normalizedWeights: PromiseOrValue<BigNumberish$1>[], rateProviders: PromiseOrValue<string>[], swapFeePercentage: PromiseOrValue<BigNumberish$1>, owner: PromiseOrValue<string>, salt: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        disable(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getAuthorizer(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getCreationCode(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getCreationCodeContracts(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getPauseConfiguration(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getPoolVersion(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getProtocolFeePercentagesProvider(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getVault(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        isDisabled(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        isPoolFromFactory(pool: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        version(overrides?: CallOverrides): Promise<PopulatedTransaction>;
    };
}

declare namespace IPoolSwapStructs$1 {
    type SwapRequestStruct = {
        kind: PromiseOrValue<BigNumberish$1>;
        tokenIn: PromiseOrValue<string>;
        tokenOut: PromiseOrValue<string>;
        amount: PromiseOrValue<BigNumberish$1>;
        poolId: PromiseOrValue<BytesLike>;
        lastChangeBlock: PromiseOrValue<BigNumberish$1>;
        from: PromiseOrValue<string>;
        to: PromiseOrValue<string>;
        userData: PromiseOrValue<BytesLike>;
    };
    type SwapRequestStructOutput = [
        number,
        string,
        string,
        BigNumber$1,
        string,
        BigNumber$1,
        string,
        string,
        string
    ] & {
        kind: number;
        tokenIn: string;
        tokenOut: string;
        amount: BigNumber$1;
        poolId: string;
        lastChangeBlock: BigNumber$1;
        from: string;
        to: string;
        userData: string;
    };
}
interface YearnLinearPoolInterface extends utils.Interface {
    functions: {
        "DOMAIN_SEPARATOR()": FunctionFragment;
        "allowance(address,address)": FunctionFragment;
        "approve(address,uint256)": FunctionFragment;
        "balanceOf(address)": FunctionFragment;
        "decimals()": FunctionFragment;
        "decreaseAllowance(address,uint256)": FunctionFragment;
        "disableRecoveryMode()": FunctionFragment;
        "enableRecoveryMode()": FunctionFragment;
        "getActionId(bytes4)": FunctionFragment;
        "getAuthorizer()": FunctionFragment;
        "getBptIndex()": FunctionFragment;
        "getDomainSeparator()": FunctionFragment;
        "getMainIndex()": FunctionFragment;
        "getMainToken()": FunctionFragment;
        "getNextNonce(address)": FunctionFragment;
        "getOwner()": FunctionFragment;
        "getPausedState()": FunctionFragment;
        "getPoolId()": FunctionFragment;
        "getProtocolFeesCollector()": FunctionFragment;
        "getRate()": FunctionFragment;
        "getScalingFactors()": FunctionFragment;
        "getSwapFeePercentage()": FunctionFragment;
        "getTargets()": FunctionFragment;
        "getVault()": FunctionFragment;
        "getVirtualSupply()": FunctionFragment;
        "getWrappedIndex()": FunctionFragment;
        "getWrappedToken()": FunctionFragment;
        "getWrappedTokenRate()": FunctionFragment;
        "inRecoveryMode()": FunctionFragment;
        "increaseAllowance(address,uint256)": FunctionFragment;
        "initialize()": FunctionFragment;
        "name()": FunctionFragment;
        "nonces(address)": FunctionFragment;
        "onExitPool(bytes32,address,address,uint256[],uint256,uint256,bytes)": FunctionFragment;
        "onJoinPool(bytes32,address,address,uint256[],uint256,uint256,bytes)": FunctionFragment;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)": FunctionFragment;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)": FunctionFragment;
        "pause()": FunctionFragment;
        "permit(address,address,uint256,uint256,uint8,bytes32,bytes32)": FunctionFragment;
        "queryExit(bytes32,address,address,uint256[],uint256,uint256,bytes)": FunctionFragment;
        "queryJoin(bytes32,address,address,uint256[],uint256,uint256,bytes)": FunctionFragment;
        "setSwapFeePercentage(uint256)": FunctionFragment;
        "setTargets(uint256,uint256)": FunctionFragment;
        "symbol()": FunctionFragment;
        "totalSupply()": FunctionFragment;
        "transfer(address,uint256)": FunctionFragment;
        "transferFrom(address,address,uint256)": FunctionFragment;
        "unpause()": FunctionFragment;
        "version()": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "DOMAIN_SEPARATOR" | "allowance" | "approve" | "balanceOf" | "decimals" | "decreaseAllowance" | "disableRecoveryMode" | "enableRecoveryMode" | "getActionId" | "getAuthorizer" | "getBptIndex" | "getDomainSeparator" | "getMainIndex" | "getMainToken" | "getNextNonce" | "getOwner" | "getPausedState" | "getPoolId" | "getProtocolFeesCollector" | "getRate" | "getScalingFactors" | "getSwapFeePercentage" | "getTargets" | "getVault" | "getVirtualSupply" | "getWrappedIndex" | "getWrappedToken" | "getWrappedTokenRate" | "inRecoveryMode" | "increaseAllowance" | "initialize" | "name" | "nonces" | "onExitPool" | "onJoinPool" | "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)" | "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)" | "pause" | "permit" | "queryExit" | "queryJoin" | "setSwapFeePercentage" | "setTargets" | "symbol" | "totalSupply" | "transfer" | "transferFrom" | "unpause" | "version"): FunctionFragment;
    encodeFunctionData(functionFragment: "DOMAIN_SEPARATOR", values?: undefined): string;
    encodeFunctionData(functionFragment: "allowance", values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "approve", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "balanceOf", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "decimals", values?: undefined): string;
    encodeFunctionData(functionFragment: "decreaseAllowance", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "disableRecoveryMode", values?: undefined): string;
    encodeFunctionData(functionFragment: "enableRecoveryMode", values?: undefined): string;
    encodeFunctionData(functionFragment: "getActionId", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "getAuthorizer", values?: undefined): string;
    encodeFunctionData(functionFragment: "getBptIndex", values?: undefined): string;
    encodeFunctionData(functionFragment: "getDomainSeparator", values?: undefined): string;
    encodeFunctionData(functionFragment: "getMainIndex", values?: undefined): string;
    encodeFunctionData(functionFragment: "getMainToken", values?: undefined): string;
    encodeFunctionData(functionFragment: "getNextNonce", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "getOwner", values?: undefined): string;
    encodeFunctionData(functionFragment: "getPausedState", values?: undefined): string;
    encodeFunctionData(functionFragment: "getPoolId", values?: undefined): string;
    encodeFunctionData(functionFragment: "getProtocolFeesCollector", values?: undefined): string;
    encodeFunctionData(functionFragment: "getRate", values?: undefined): string;
    encodeFunctionData(functionFragment: "getScalingFactors", values?: undefined): string;
    encodeFunctionData(functionFragment: "getSwapFeePercentage", values?: undefined): string;
    encodeFunctionData(functionFragment: "getTargets", values?: undefined): string;
    encodeFunctionData(functionFragment: "getVault", values?: undefined): string;
    encodeFunctionData(functionFragment: "getVirtualSupply", values?: undefined): string;
    encodeFunctionData(functionFragment: "getWrappedIndex", values?: undefined): string;
    encodeFunctionData(functionFragment: "getWrappedToken", values?: undefined): string;
    encodeFunctionData(functionFragment: "getWrappedTokenRate", values?: undefined): string;
    encodeFunctionData(functionFragment: "inRecoveryMode", values?: undefined): string;
    encodeFunctionData(functionFragment: "increaseAllowance", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "initialize", values?: undefined): string;
    encodeFunctionData(functionFragment: "name", values?: undefined): string;
    encodeFunctionData(functionFragment: "nonces", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "onExitPool", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "onJoinPool", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)", values: [
        IPoolSwapStructs$1.SwapRequestStruct,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)", values: [
        IPoolSwapStructs$1.SwapRequestStruct,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "pause", values?: undefined): string;
    encodeFunctionData(functionFragment: "permit", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "queryExit", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "queryJoin", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "setSwapFeePercentage", values: [PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "setTargets", values: [PromiseOrValue<BigNumberish$1>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "symbol", values?: undefined): string;
    encodeFunctionData(functionFragment: "totalSupply", values?: undefined): string;
    encodeFunctionData(functionFragment: "transfer", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "transferFrom", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "unpause", values?: undefined): string;
    encodeFunctionData(functionFragment: "version", values?: undefined): string;
    decodeFunctionResult(functionFragment: "DOMAIN_SEPARATOR", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "allowance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "approve", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "balanceOf", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "decimals", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "decreaseAllowance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "disableRecoveryMode", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "enableRecoveryMode", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getActionId", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getAuthorizer", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getBptIndex", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getDomainSeparator", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getMainIndex", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getMainToken", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getNextNonce", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getOwner", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getPausedState", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getPoolId", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getProtocolFeesCollector", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getRate", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getScalingFactors", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getSwapFeePercentage", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getTargets", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getVault", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getVirtualSupply", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getWrappedIndex", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getWrappedToken", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getWrappedTokenRate", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "inRecoveryMode", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "increaseAllowance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "name", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "nonces", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "onExitPool", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "onJoinPool", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "pause", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "permit", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "queryExit", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "queryJoin", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setSwapFeePercentage", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setTargets", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "symbol", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "totalSupply", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "transfer", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "transferFrom", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "unpause", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "version", data: BytesLike): Result;
    events: {
        "Approval(address,address,uint256)": EventFragment;
        "PausedStateChanged(bool)": EventFragment;
        "RecoveryModeStateChanged(bool)": EventFragment;
        "SwapFeePercentageChanged(uint256)": EventFragment;
        "TargetsSet(address,uint256,uint256)": EventFragment;
        "Transfer(address,address,uint256)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "Approval"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "PausedStateChanged"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "RecoveryModeStateChanged"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "SwapFeePercentageChanged"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "TargetsSet"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Transfer"): EventFragment;
}
interface ApprovalEventObject$1 {
    owner: string;
    spender: string;
    value: BigNumber$1;
}
type ApprovalEvent$1 = TypedEvent<[
    string,
    string,
    BigNumber$1
], ApprovalEventObject$1>;
type ApprovalEventFilter$1 = TypedEventFilter<ApprovalEvent$1>;
interface PausedStateChangedEventObject$1 {
    paused: boolean;
}
type PausedStateChangedEvent$1 = TypedEvent<[
    boolean
], PausedStateChangedEventObject$1>;
type PausedStateChangedEventFilter$1 = TypedEventFilter<PausedStateChangedEvent$1>;
interface RecoveryModeStateChangedEventObject {
    enabled: boolean;
}
type RecoveryModeStateChangedEvent = TypedEvent<[
    boolean
], RecoveryModeStateChangedEventObject>;
type RecoveryModeStateChangedEventFilter = TypedEventFilter<RecoveryModeStateChangedEvent>;
interface SwapFeePercentageChangedEventObject$1 {
    swapFeePercentage: BigNumber$1;
}
type SwapFeePercentageChangedEvent$1 = TypedEvent<[
    BigNumber$1
], SwapFeePercentageChangedEventObject$1>;
type SwapFeePercentageChangedEventFilter$1 = TypedEventFilter<SwapFeePercentageChangedEvent$1>;
interface TargetsSetEventObject {
    token: string;
    lowerTarget: BigNumber$1;
    upperTarget: BigNumber$1;
}
type TargetsSetEvent = TypedEvent<[
    string,
    BigNumber$1,
    BigNumber$1
], TargetsSetEventObject>;
type TargetsSetEventFilter = TypedEventFilter<TargetsSetEvent>;
interface TransferEventObject$1 {
    from: string;
    to: string;
    value: BigNumber$1;
}
type TransferEvent$1 = TypedEvent<[
    string,
    string,
    BigNumber$1
], TransferEventObject$1>;
type TransferEventFilter$1 = TypedEventFilter<TransferEvent$1>;
declare namespace YearnLinearPool {
    type ConstructorArgsStruct = {
        vault: PromiseOrValue<string>;
        name: PromiseOrValue<string>;
        symbol: PromiseOrValue<string>;
        mainToken: PromiseOrValue<string>;
        wrappedToken: PromiseOrValue<string>;
        assetManager: PromiseOrValue<string>;
        upperTarget: PromiseOrValue<BigNumberish$1>;
        swapFeePercentage: PromiseOrValue<BigNumberish$1>;
        pauseWindowDuration: PromiseOrValue<BigNumberish$1>;
        bufferPeriodDuration: PromiseOrValue<BigNumberish$1>;
        owner: PromiseOrValue<string>;
        version: PromiseOrValue<string>;
    };
    type ConstructorArgsStructOutput = [
        string,
        string,
        string,
        string,
        string,
        string,
        BigNumber$1,
        BigNumber$1,
        BigNumber$1,
        BigNumber$1,
        string,
        string
    ] & {
        vault: string;
        name: string;
        symbol: string;
        mainToken: string;
        wrappedToken: string;
        assetManager: string;
        upperTarget: BigNumber$1;
        swapFeePercentage: BigNumber$1;
        pauseWindowDuration: BigNumber$1;
        bufferPeriodDuration: BigNumber$1;
        owner: string;
        version: string;
    };
}
interface YearnLinearPool extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: YearnLinearPoolInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<[string]>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        decimals(overrides?: CallOverrides): Promise<[number]>;
        decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        disableRecoveryMode(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        enableRecoveryMode(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[string]>;
        getAuthorizer(overrides?: CallOverrides): Promise<[string]>;
        getBptIndex(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getDomainSeparator(overrides?: CallOverrides): Promise<[string]>;
        getMainIndex(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getMainToken(overrides?: CallOverrides): Promise<[string]>;
        getNextNonce(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getOwner(overrides?: CallOverrides): Promise<[string]>;
        getPausedState(overrides?: CallOverrides): Promise<[
            boolean,
            BigNumber$1,
            BigNumber$1
        ] & {
            paused: boolean;
            pauseWindowEndTime: BigNumber$1;
            bufferPeriodEndTime: BigNumber$1;
        }>;
        getPoolId(overrides?: CallOverrides): Promise<[string]>;
        getProtocolFeesCollector(overrides?: CallOverrides): Promise<[string]>;
        getRate(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getScalingFactors(overrides?: CallOverrides): Promise<[BigNumber$1[]]>;
        getSwapFeePercentage(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getTargets(overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1
        ] & {
            lowerTarget: BigNumber$1;
            upperTarget: BigNumber$1;
        }>;
        getVault(overrides?: CallOverrides): Promise<[string]>;
        getVirtualSupply(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getWrappedIndex(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getWrappedToken(overrides?: CallOverrides): Promise<[string]>;
        getWrappedTokenRate(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        inRecoveryMode(overrides?: CallOverrides): Promise<[boolean]>;
        increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        initialize(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        name(overrides?: CallOverrides): Promise<[string]>;
        nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        onJoinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)"(request: IPoolSwapStructs$1.SwapRequestStruct, balances: PromiseOrValue<BigNumberish$1>[], indexIn: PromiseOrValue<BigNumberish$1>, indexOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)"(request: IPoolSwapStructs$1.SwapRequestStruct, balanceTokenIn: PromiseOrValue<BigNumberish$1>, balanceTokenOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        pause(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        queryExit(arg0: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        queryJoin(arg0: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setSwapFeePercentage(swapFeePercentage: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setTargets(newLowerTarget: PromiseOrValue<BigNumberish$1>, newUpperTarget: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        symbol(overrides?: CallOverrides): Promise<[string]>;
        totalSupply(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        unpause(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        version(overrides?: CallOverrides): Promise<[string]>;
    };
    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;
    allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    decimals(overrides?: CallOverrides): Promise<number>;
    decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    disableRecoveryMode(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    enableRecoveryMode(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
    getAuthorizer(overrides?: CallOverrides): Promise<string>;
    getBptIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
    getDomainSeparator(overrides?: CallOverrides): Promise<string>;
    getMainIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
    getMainToken(overrides?: CallOverrides): Promise<string>;
    getNextNonce(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    getOwner(overrides?: CallOverrides): Promise<string>;
    getPausedState(overrides?: CallOverrides): Promise<[
        boolean,
        BigNumber$1,
        BigNumber$1
    ] & {
        paused: boolean;
        pauseWindowEndTime: BigNumber$1;
        bufferPeriodEndTime: BigNumber$1;
    }>;
    getPoolId(overrides?: CallOverrides): Promise<string>;
    getProtocolFeesCollector(overrides?: CallOverrides): Promise<string>;
    getRate(overrides?: CallOverrides): Promise<BigNumber$1>;
    getScalingFactors(overrides?: CallOverrides): Promise<BigNumber$1[]>;
    getSwapFeePercentage(overrides?: CallOverrides): Promise<BigNumber$1>;
    getTargets(overrides?: CallOverrides): Promise<[
        BigNumber$1,
        BigNumber$1
    ] & {
        lowerTarget: BigNumber$1;
        upperTarget: BigNumber$1;
    }>;
    getVault(overrides?: CallOverrides): Promise<string>;
    getVirtualSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
    getWrappedIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
    getWrappedToken(overrides?: CallOverrides): Promise<string>;
    getWrappedTokenRate(overrides?: CallOverrides): Promise<BigNumber$1>;
    inRecoveryMode(overrides?: CallOverrides): Promise<boolean>;
    increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    initialize(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    name(overrides?: CallOverrides): Promise<string>;
    nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    onJoinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)"(request: IPoolSwapStructs$1.SwapRequestStruct, balances: PromiseOrValue<BigNumberish$1>[], indexIn: PromiseOrValue<BigNumberish$1>, indexOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)"(request: IPoolSwapStructs$1.SwapRequestStruct, balanceTokenIn: PromiseOrValue<BigNumberish$1>, balanceTokenOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    pause(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    queryExit(arg0: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    queryJoin(arg0: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setSwapFeePercentage(swapFeePercentage: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setTargets(newLowerTarget: PromiseOrValue<BigNumberish$1>, newUpperTarget: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    symbol(overrides?: CallOverrides): Promise<string>;
    totalSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
    transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    unpause(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    version(overrides?: CallOverrides): Promise<string>;
    callStatic: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        decimals(overrides?: CallOverrides): Promise<number>;
        decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        disableRecoveryMode(overrides?: CallOverrides): Promise<void>;
        enableRecoveryMode(overrides?: CallOverrides): Promise<void>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
        getAuthorizer(overrides?: CallOverrides): Promise<string>;
        getBptIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
        getDomainSeparator(overrides?: CallOverrides): Promise<string>;
        getMainIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
        getMainToken(overrides?: CallOverrides): Promise<string>;
        getNextNonce(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getOwner(overrides?: CallOverrides): Promise<string>;
        getPausedState(overrides?: CallOverrides): Promise<[
            boolean,
            BigNumber$1,
            BigNumber$1
        ] & {
            paused: boolean;
            pauseWindowEndTime: BigNumber$1;
            bufferPeriodEndTime: BigNumber$1;
        }>;
        getPoolId(overrides?: CallOverrides): Promise<string>;
        getProtocolFeesCollector(overrides?: CallOverrides): Promise<string>;
        getRate(overrides?: CallOverrides): Promise<BigNumber$1>;
        getScalingFactors(overrides?: CallOverrides): Promise<BigNumber$1[]>;
        getSwapFeePercentage(overrides?: CallOverrides): Promise<BigNumber$1>;
        getTargets(overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1
        ] & {
            lowerTarget: BigNumber$1;
            upperTarget: BigNumber$1;
        }>;
        getVault(overrides?: CallOverrides): Promise<string>;
        getVirtualSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
        getWrappedIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
        getWrappedToken(overrides?: CallOverrides): Promise<string>;
        getWrappedTokenRate(overrides?: CallOverrides): Promise<BigNumber$1>;
        inRecoveryMode(overrides?: CallOverrides): Promise<boolean>;
        increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        initialize(overrides?: CallOverrides): Promise<void>;
        name(overrides?: CallOverrides): Promise<string>;
        nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[
            BigNumber$1[],
            BigNumber$1[]
        ] & {
            amountsOut: BigNumber$1[];
            dueProtocolFees: BigNumber$1[];
        }>;
        onJoinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[
            BigNumber$1[],
            BigNumber$1[]
        ] & {
            amountsIn: BigNumber$1[];
            dueProtocolFees: BigNumber$1[];
        }>;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)"(request: IPoolSwapStructs$1.SwapRequestStruct, balances: PromiseOrValue<BigNumberish$1>[], indexIn: PromiseOrValue<BigNumberish$1>, indexOut: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)"(request: IPoolSwapStructs$1.SwapRequestStruct, balanceTokenIn: PromiseOrValue<BigNumberish$1>, balanceTokenOut: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        pause(overrides?: CallOverrides): Promise<void>;
        permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<void>;
        queryExit(arg0: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1[]
        ] & {
            bptIn: BigNumber$1;
            amountsOut: BigNumber$1[];
        }>;
        queryJoin(arg0: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1[]
        ] & {
            bptOut: BigNumber$1;
            amountsIn: BigNumber$1[];
        }>;
        setSwapFeePercentage(swapFeePercentage: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        setTargets(newLowerTarget: PromiseOrValue<BigNumberish$1>, newUpperTarget: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        symbol(overrides?: CallOverrides): Promise<string>;
        totalSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
        transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        unpause(overrides?: CallOverrides): Promise<void>;
        version(overrides?: CallOverrides): Promise<string>;
    };
    filters: {
        "Approval(address,address,uint256)"(owner?: PromiseOrValue<string> | null, spender?: PromiseOrValue<string> | null, value?: null): ApprovalEventFilter$1;
        Approval(owner?: PromiseOrValue<string> | null, spender?: PromiseOrValue<string> | null, value?: null): ApprovalEventFilter$1;
        "PausedStateChanged(bool)"(paused?: null): PausedStateChangedEventFilter$1;
        PausedStateChanged(paused?: null): PausedStateChangedEventFilter$1;
        "RecoveryModeStateChanged(bool)"(enabled?: null): RecoveryModeStateChangedEventFilter;
        RecoveryModeStateChanged(enabled?: null): RecoveryModeStateChangedEventFilter;
        "SwapFeePercentageChanged(uint256)"(swapFeePercentage?: null): SwapFeePercentageChangedEventFilter$1;
        SwapFeePercentageChanged(swapFeePercentage?: null): SwapFeePercentageChangedEventFilter$1;
        "TargetsSet(address,uint256,uint256)"(token?: PromiseOrValue<string> | null, lowerTarget?: null, upperTarget?: null): TargetsSetEventFilter;
        TargetsSet(token?: PromiseOrValue<string> | null, lowerTarget?: null, upperTarget?: null): TargetsSetEventFilter;
        "Transfer(address,address,uint256)"(from?: PromiseOrValue<string> | null, to?: PromiseOrValue<string> | null, value?: null): TransferEventFilter$1;
        Transfer(from?: PromiseOrValue<string> | null, to?: PromiseOrValue<string> | null, value?: null): TransferEventFilter$1;
    };
    estimateGas: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<BigNumber$1>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        decimals(overrides?: CallOverrides): Promise<BigNumber$1>;
        decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        disableRecoveryMode(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        enableRecoveryMode(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getAuthorizer(overrides?: CallOverrides): Promise<BigNumber$1>;
        getBptIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
        getDomainSeparator(overrides?: CallOverrides): Promise<BigNumber$1>;
        getMainIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
        getMainToken(overrides?: CallOverrides): Promise<BigNumber$1>;
        getNextNonce(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getOwner(overrides?: CallOverrides): Promise<BigNumber$1>;
        getPausedState(overrides?: CallOverrides): Promise<BigNumber$1>;
        getPoolId(overrides?: CallOverrides): Promise<BigNumber$1>;
        getProtocolFeesCollector(overrides?: CallOverrides): Promise<BigNumber$1>;
        getRate(overrides?: CallOverrides): Promise<BigNumber$1>;
        getScalingFactors(overrides?: CallOverrides): Promise<BigNumber$1>;
        getSwapFeePercentage(overrides?: CallOverrides): Promise<BigNumber$1>;
        getTargets(overrides?: CallOverrides): Promise<BigNumber$1>;
        getVault(overrides?: CallOverrides): Promise<BigNumber$1>;
        getVirtualSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
        getWrappedIndex(overrides?: CallOverrides): Promise<BigNumber$1>;
        getWrappedToken(overrides?: CallOverrides): Promise<BigNumber$1>;
        getWrappedTokenRate(overrides?: CallOverrides): Promise<BigNumber$1>;
        inRecoveryMode(overrides?: CallOverrides): Promise<BigNumber$1>;
        increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        initialize(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        name(overrides?: CallOverrides): Promise<BigNumber$1>;
        nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        onJoinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)"(request: IPoolSwapStructs$1.SwapRequestStruct, balances: PromiseOrValue<BigNumberish$1>[], indexIn: PromiseOrValue<BigNumberish$1>, indexOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)"(request: IPoolSwapStructs$1.SwapRequestStruct, balanceTokenIn: PromiseOrValue<BigNumberish$1>, balanceTokenOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        pause(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        queryExit(arg0: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        queryJoin(arg0: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        setSwapFeePercentage(swapFeePercentage: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        setTargets(newLowerTarget: PromiseOrValue<BigNumberish$1>, newUpperTarget: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        symbol(overrides?: CallOverrides): Promise<BigNumber$1>;
        totalSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
        transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        unpause(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        version(overrides?: CallOverrides): Promise<BigNumber$1>;
    };
    populateTransaction: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        decimals(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        disableRecoveryMode(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        enableRecoveryMode(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getAuthorizer(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getBptIndex(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getDomainSeparator(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getMainIndex(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getMainToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getNextNonce(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getOwner(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getPausedState(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getPoolId(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getProtocolFeesCollector(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getRate(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getScalingFactors(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getSwapFeePercentage(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getTargets(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getVault(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getVirtualSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getWrappedIndex(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getWrappedToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getWrappedTokenRate(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        inRecoveryMode(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        initialize(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        name(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        onJoinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256[],uint256,uint256)"(request: IPoolSwapStructs$1.SwapRequestStruct, balances: PromiseOrValue<BigNumberish$1>[], indexIn: PromiseOrValue<BigNumberish$1>, indexOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)"(request: IPoolSwapStructs$1.SwapRequestStruct, balanceTokenIn: PromiseOrValue<BigNumberish$1>, balanceTokenOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        pause(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        queryExit(arg0: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        queryJoin(arg0: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, arg2: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], arg4: PromiseOrValue<BigNumberish$1>, arg5: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setSwapFeePercentage(swapFeePercentage: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setTargets(newLowerTarget: PromiseOrValue<BigNumberish$1>, newUpperTarget: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        symbol(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        totalSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        unpause(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        version(overrides?: CallOverrides): Promise<PopulatedTransaction>;
    };
}

interface YearnLinearPoolFactoryInterface extends utils.Interface {
    functions: {
        "create(string,string,address,address,uint256,uint256,address,uint256,bytes32)": FunctionFragment;
        "disable()": FunctionFragment;
        "getActionId(bytes4)": FunctionFragment;
        "getAuthorizer()": FunctionFragment;
        "getCreationCode()": FunctionFragment;
        "getCreationCodeContracts()": FunctionFragment;
        "getLastCreatedPool()": FunctionFragment;
        "getPauseConfiguration()": FunctionFragment;
        "getPoolVersion()": FunctionFragment;
        "getProtocolFeePercentagesProvider()": FunctionFragment;
        "getVault()": FunctionFragment;
        "isDisabled()": FunctionFragment;
        "isPoolFromFactory(address)": FunctionFragment;
        "version()": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "create" | "disable" | "getActionId" | "getAuthorizer" | "getCreationCode" | "getCreationCodeContracts" | "getLastCreatedPool" | "getPauseConfiguration" | "getPoolVersion" | "getProtocolFeePercentagesProvider" | "getVault" | "isDisabled" | "isPoolFromFactory" | "version"): FunctionFragment;
    encodeFunctionData(functionFragment: "create", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "disable", values?: undefined): string;
    encodeFunctionData(functionFragment: "getActionId", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "getAuthorizer", values?: undefined): string;
    encodeFunctionData(functionFragment: "getCreationCode", values?: undefined): string;
    encodeFunctionData(functionFragment: "getCreationCodeContracts", values?: undefined): string;
    encodeFunctionData(functionFragment: "getLastCreatedPool", values?: undefined): string;
    encodeFunctionData(functionFragment: "getPauseConfiguration", values?: undefined): string;
    encodeFunctionData(functionFragment: "getPoolVersion", values?: undefined): string;
    encodeFunctionData(functionFragment: "getProtocolFeePercentagesProvider", values?: undefined): string;
    encodeFunctionData(functionFragment: "getVault", values?: undefined): string;
    encodeFunctionData(functionFragment: "isDisabled", values?: undefined): string;
    encodeFunctionData(functionFragment: "isPoolFromFactory", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "version", values?: undefined): string;
    decodeFunctionResult(functionFragment: "create", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "disable", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getActionId", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getAuthorizer", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getCreationCode", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getCreationCodeContracts", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getLastCreatedPool", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getPauseConfiguration", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getPoolVersion", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getProtocolFeePercentagesProvider", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getVault", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isDisabled", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isPoolFromFactory", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "version", data: BytesLike): Result;
    events: {
        "FactoryDisabled()": EventFragment;
        "PoolCreated(address)": EventFragment;
        "YearnLinearPoolCreated(address,uint256)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "FactoryDisabled"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "PoolCreated"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "YearnLinearPoolCreated"): EventFragment;
}
interface FactoryDisabledEventObject {
}
type FactoryDisabledEvent = TypedEvent<[], FactoryDisabledEventObject>;
type FactoryDisabledEventFilter = TypedEventFilter<FactoryDisabledEvent>;
interface PoolCreatedEventObject {
    pool: string;
}
type PoolCreatedEvent = TypedEvent<[string], PoolCreatedEventObject>;
type PoolCreatedEventFilter = TypedEventFilter<PoolCreatedEvent>;
interface YearnLinearPoolCreatedEventObject {
    pool: string;
    protocolId: BigNumber$1;
}
type YearnLinearPoolCreatedEvent = TypedEvent<[
    string,
    BigNumber$1
], YearnLinearPoolCreatedEventObject>;
type YearnLinearPoolCreatedEventFilter = TypedEventFilter<YearnLinearPoolCreatedEvent>;
interface YearnLinearPoolFactory extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: YearnLinearPoolFactoryInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        create(name: PromiseOrValue<string>, symbol: PromiseOrValue<string>, mainToken: PromiseOrValue<string>, wrappedToken: PromiseOrValue<string>, upperTarget: PromiseOrValue<BigNumberish$1>, swapFeePercentage: PromiseOrValue<BigNumberish$1>, owner: PromiseOrValue<string>, protocolId: PromiseOrValue<BigNumberish$1>, salt: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        disable(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[string]>;
        getAuthorizer(overrides?: CallOverrides): Promise<[string]>;
        getCreationCode(overrides?: CallOverrides): Promise<[string]>;
        getCreationCodeContracts(overrides?: CallOverrides): Promise<[string, string] & {
            contractA: string;
            contractB: string;
        }>;
        getLastCreatedPool(overrides?: CallOverrides): Promise<[string]>;
        getPauseConfiguration(overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1
        ] & {
            pauseWindowDuration: BigNumber$1;
            bufferPeriodDuration: BigNumber$1;
        }>;
        getPoolVersion(overrides?: CallOverrides): Promise<[string]>;
        getProtocolFeePercentagesProvider(overrides?: CallOverrides): Promise<[string]>;
        getVault(overrides?: CallOverrides): Promise<[string]>;
        isDisabled(overrides?: CallOverrides): Promise<[boolean]>;
        isPoolFromFactory(pool: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;
        version(overrides?: CallOverrides): Promise<[string]>;
    };
    create(name: PromiseOrValue<string>, symbol: PromiseOrValue<string>, mainToken: PromiseOrValue<string>, wrappedToken: PromiseOrValue<string>, upperTarget: PromiseOrValue<BigNumberish$1>, swapFeePercentage: PromiseOrValue<BigNumberish$1>, owner: PromiseOrValue<string>, protocolId: PromiseOrValue<BigNumberish$1>, salt: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    disable(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
    getAuthorizer(overrides?: CallOverrides): Promise<string>;
    getCreationCode(overrides?: CallOverrides): Promise<string>;
    getCreationCodeContracts(overrides?: CallOverrides): Promise<[string, string] & {
        contractA: string;
        contractB: string;
    }>;
    getLastCreatedPool(overrides?: CallOverrides): Promise<string>;
    getPauseConfiguration(overrides?: CallOverrides): Promise<[
        BigNumber$1,
        BigNumber$1
    ] & {
        pauseWindowDuration: BigNumber$1;
        bufferPeriodDuration: BigNumber$1;
    }>;
    getPoolVersion(overrides?: CallOverrides): Promise<string>;
    getProtocolFeePercentagesProvider(overrides?: CallOverrides): Promise<string>;
    getVault(overrides?: CallOverrides): Promise<string>;
    isDisabled(overrides?: CallOverrides): Promise<boolean>;
    isPoolFromFactory(pool: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
    version(overrides?: CallOverrides): Promise<string>;
    callStatic: {
        create(name: PromiseOrValue<string>, symbol: PromiseOrValue<string>, mainToken: PromiseOrValue<string>, wrappedToken: PromiseOrValue<string>, upperTarget: PromiseOrValue<BigNumberish$1>, swapFeePercentage: PromiseOrValue<BigNumberish$1>, owner: PromiseOrValue<string>, protocolId: PromiseOrValue<BigNumberish$1>, salt: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
        disable(overrides?: CallOverrides): Promise<void>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
        getAuthorizer(overrides?: CallOverrides): Promise<string>;
        getCreationCode(overrides?: CallOverrides): Promise<string>;
        getCreationCodeContracts(overrides?: CallOverrides): Promise<[string, string] & {
            contractA: string;
            contractB: string;
        }>;
        getLastCreatedPool(overrides?: CallOverrides): Promise<string>;
        getPauseConfiguration(overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1
        ] & {
            pauseWindowDuration: BigNumber$1;
            bufferPeriodDuration: BigNumber$1;
        }>;
        getPoolVersion(overrides?: CallOverrides): Promise<string>;
        getProtocolFeePercentagesProvider(overrides?: CallOverrides): Promise<string>;
        getVault(overrides?: CallOverrides): Promise<string>;
        isDisabled(overrides?: CallOverrides): Promise<boolean>;
        isPoolFromFactory(pool: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
        version(overrides?: CallOverrides): Promise<string>;
    };
    filters: {
        "FactoryDisabled()"(): FactoryDisabledEventFilter;
        FactoryDisabled(): FactoryDisabledEventFilter;
        "PoolCreated(address)"(pool?: PromiseOrValue<string> | null): PoolCreatedEventFilter;
        PoolCreated(pool?: PromiseOrValue<string> | null): PoolCreatedEventFilter;
        "YearnLinearPoolCreated(address,uint256)"(pool?: PromiseOrValue<string> | null, protocolId?: PromiseOrValue<BigNumberish$1> | null): YearnLinearPoolCreatedEventFilter;
        YearnLinearPoolCreated(pool?: PromiseOrValue<string> | null, protocolId?: PromiseOrValue<BigNumberish$1> | null): YearnLinearPoolCreatedEventFilter;
    };
    estimateGas: {
        create(name: PromiseOrValue<string>, symbol: PromiseOrValue<string>, mainToken: PromiseOrValue<string>, wrappedToken: PromiseOrValue<string>, upperTarget: PromiseOrValue<BigNumberish$1>, swapFeePercentage: PromiseOrValue<BigNumberish$1>, owner: PromiseOrValue<string>, protocolId: PromiseOrValue<BigNumberish$1>, salt: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        disable(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getAuthorizer(overrides?: CallOverrides): Promise<BigNumber$1>;
        getCreationCode(overrides?: CallOverrides): Promise<BigNumber$1>;
        getCreationCodeContracts(overrides?: CallOverrides): Promise<BigNumber$1>;
        getLastCreatedPool(overrides?: CallOverrides): Promise<BigNumber$1>;
        getPauseConfiguration(overrides?: CallOverrides): Promise<BigNumber$1>;
        getPoolVersion(overrides?: CallOverrides): Promise<BigNumber$1>;
        getProtocolFeePercentagesProvider(overrides?: CallOverrides): Promise<BigNumber$1>;
        getVault(overrides?: CallOverrides): Promise<BigNumber$1>;
        isDisabled(overrides?: CallOverrides): Promise<BigNumber$1>;
        isPoolFromFactory(pool: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        version(overrides?: CallOverrides): Promise<BigNumber$1>;
    };
    populateTransaction: {
        create(name: PromiseOrValue<string>, symbol: PromiseOrValue<string>, mainToken: PromiseOrValue<string>, wrappedToken: PromiseOrValue<string>, upperTarget: PromiseOrValue<BigNumberish$1>, swapFeePercentage: PromiseOrValue<BigNumberish$1>, owner: PromiseOrValue<string>, protocolId: PromiseOrValue<BigNumberish$1>, salt: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        disable(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getAuthorizer(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getCreationCode(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getCreationCodeContracts(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getLastCreatedPool(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getPauseConfiguration(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getPoolVersion(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getProtocolFeePercentagesProvider(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getVault(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        isDisabled(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        isPoolFromFactory(pool: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        version(overrides?: CallOverrides): Promise<PopulatedTransaction>;
    };
}

declare namespace GyroECLPMath {
    type ParamsStruct = {
        alpha: PromiseOrValue<BigNumberish$1>;
        beta: PromiseOrValue<BigNumberish$1>;
        c: PromiseOrValue<BigNumberish$1>;
        s: PromiseOrValue<BigNumberish$1>;
        lambda: PromiseOrValue<BigNumberish$1>;
    };
    type ParamsStructOutput = [
        BigNumber$1,
        BigNumber$1,
        BigNumber$1,
        BigNumber$1,
        BigNumber$1
    ] & {
        alpha: BigNumber$1;
        beta: BigNumber$1;
        c: BigNumber$1;
        s: BigNumber$1;
        lambda: BigNumber$1;
    };
    type Vector2Struct = {
        x: PromiseOrValue<BigNumberish$1>;
        y: PromiseOrValue<BigNumberish$1>;
    };
    type Vector2StructOutput = [BigNumber$1, BigNumber$1] & {
        x: BigNumber$1;
        y: BigNumber$1;
    };
    type DerivedParamsStruct = {
        tauAlpha: GyroECLPMath.Vector2Struct;
        tauBeta: GyroECLPMath.Vector2Struct;
        u: PromiseOrValue<BigNumberish$1>;
        v: PromiseOrValue<BigNumberish$1>;
        w: PromiseOrValue<BigNumberish$1>;
        z: PromiseOrValue<BigNumberish$1>;
        dSq: PromiseOrValue<BigNumberish$1>;
    };
    type DerivedParamsStructOutput = [
        GyroECLPMath.Vector2StructOutput,
        GyroECLPMath.Vector2StructOutput,
        BigNumber$1,
        BigNumber$1,
        BigNumber$1,
        BigNumber$1,
        BigNumber$1
    ] & {
        tauAlpha: GyroECLPMath.Vector2StructOutput;
        tauBeta: GyroECLPMath.Vector2StructOutput;
        u: BigNumber$1;
        v: BigNumber$1;
        w: BigNumber$1;
        z: BigNumber$1;
        dSq: BigNumber$1;
    };
}
declare namespace ICappedLiquidity {
    type CapParamsStruct = {
        capEnabled: PromiseOrValue<boolean>;
        perAddressCap: PromiseOrValue<BigNumberish$1>;
        globalCap: PromiseOrValue<BigNumberish$1>;
    };
    type CapParamsStructOutput = [boolean, BigNumber$1, BigNumber$1] & {
        capEnabled: boolean;
        perAddressCap: BigNumber$1;
        globalCap: BigNumber$1;
    };
}
declare namespace IPriceOracle {
    type OracleAccumulatorQueryStruct = {
        variable: PromiseOrValue<BigNumberish$1>;
        ago: PromiseOrValue<BigNumberish$1>;
    };
    type OracleAccumulatorQueryStructOutput = [number, BigNumber$1] & {
        variable: number;
        ago: BigNumber$1;
    };
    type OracleAverageQueryStruct = {
        variable: PromiseOrValue<BigNumberish$1>;
        secs: PromiseOrValue<BigNumberish$1>;
        ago: PromiseOrValue<BigNumberish$1>;
    };
    type OracleAverageQueryStructOutput = [
        number,
        BigNumber$1,
        BigNumber$1
    ] & {
        variable: number;
        secs: BigNumber$1;
        ago: BigNumber$1;
    };
}
declare namespace IPoolSwapStructs {
    type SwapRequestStruct = {
        kind: PromiseOrValue<BigNumberish$1>;
        tokenIn: PromiseOrValue<string>;
        tokenOut: PromiseOrValue<string>;
        amount: PromiseOrValue<BigNumberish$1>;
        poolId: PromiseOrValue<BytesLike>;
        lastChangeBlock: PromiseOrValue<BigNumberish$1>;
        from: PromiseOrValue<string>;
        to: PromiseOrValue<string>;
        userData: PromiseOrValue<BytesLike>;
    };
    type SwapRequestStructOutput = [
        number,
        string,
        string,
        BigNumber$1,
        string,
        BigNumber$1,
        string,
        string,
        string
    ] & {
        kind: number;
        tokenIn: string;
        tokenOut: string;
        amount: BigNumber$1;
        poolId: string;
        lastChangeBlock: BigNumber$1;
        from: string;
        to: string;
        userData: string;
    };
}
interface GyroEV2Interface extends utils.Interface {
    functions: {
        "DOMAIN_SEPARATOR()": FunctionFragment;
        "_dSq()": FunctionFragment;
        "_paramsAlpha()": FunctionFragment;
        "_paramsBeta()": FunctionFragment;
        "_paramsC()": FunctionFragment;
        "_paramsLambda()": FunctionFragment;
        "_paramsS()": FunctionFragment;
        "_tauAlphaX()": FunctionFragment;
        "_tauAlphaY()": FunctionFragment;
        "_tauBetaX()": FunctionFragment;
        "_tauBetaY()": FunctionFragment;
        "_u()": FunctionFragment;
        "_v()": FunctionFragment;
        "_w()": FunctionFragment;
        "_z()": FunctionFragment;
        "allowance(address,address)": FunctionFragment;
        "approve(address,uint256)": FunctionFragment;
        "balanceOf(address)": FunctionFragment;
        "capManager()": FunctionFragment;
        "capParams()": FunctionFragment;
        "changePauseManager(address)": FunctionFragment;
        "decimals()": FunctionFragment;
        "decreaseAllowance(address,uint256)": FunctionFragment;
        "dirtyUninitializedOracleSamples(uint256,uint256)": FunctionFragment;
        "enableOracle()": FunctionFragment;
        "getActionId(bytes4)": FunctionFragment;
        "getAuthorizer()": FunctionFragment;
        "getECLPParams()": FunctionFragment;
        "getInvariant()": FunctionFragment;
        "getLargestSafeQueryWindow()": FunctionFragment;
        "getLastInvariant()": FunctionFragment;
        "getLatest(uint8)": FunctionFragment;
        "getMiscData()": FunctionFragment;
        "getNormalizedWeights()": FunctionFragment;
        "getOwner()": FunctionFragment;
        "getPastAccumulators((uint8,uint256)[])": FunctionFragment;
        "getPausedState()": FunctionFragment;
        "getPoolId()": FunctionFragment;
        "getPrice()": FunctionFragment;
        "getRate()": FunctionFragment;
        "getSample(uint256)": FunctionFragment;
        "getSwapFeePercentage()": FunctionFragment;
        "getTimeWeightedAverage((uint8,uint256,uint256)[])": FunctionFragment;
        "getTokenRates()": FunctionFragment;
        "getTotalSamples()": FunctionFragment;
        "getVault()": FunctionFragment;
        "gyroConfig()": FunctionFragment;
        "increaseAllowance(address,uint256)": FunctionFragment;
        "name()": FunctionFragment;
        "nonces(address)": FunctionFragment;
        "onExitPool(bytes32,address,address,uint256[],uint256,uint256,bytes)": FunctionFragment;
        "onJoinPool(bytes32,address,address,uint256[],uint256,uint256,bytes)": FunctionFragment;
        "onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256)": FunctionFragment;
        "pause()": FunctionFragment;
        "pauseManager()": FunctionFragment;
        "permit(address,address,uint256,uint256,uint8,bytes32,bytes32)": FunctionFragment;
        "queryExit(bytes32,address,address,uint256[],uint256,uint256,bytes)": FunctionFragment;
        "queryJoin(bytes32,address,address,uint256[],uint256,uint256,bytes)": FunctionFragment;
        "rateProvider0()": FunctionFragment;
        "rateProvider1()": FunctionFragment;
        "setCapManager(address)": FunctionFragment;
        "setCapParams((bool,uint120,uint128))": FunctionFragment;
        "setPaused(bool)": FunctionFragment;
        "setSwapFeePercentage(uint256)": FunctionFragment;
        "symbol()": FunctionFragment;
        "totalSupply()": FunctionFragment;
        "transfer(address,uint256)": FunctionFragment;
        "transferFrom(address,address,uint256)": FunctionFragment;
        "unpause()": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "DOMAIN_SEPARATOR" | "_dSq" | "_paramsAlpha" | "_paramsBeta" | "_paramsC" | "_paramsLambda" | "_paramsS" | "_tauAlphaX" | "_tauAlphaY" | "_tauBetaX" | "_tauBetaY" | "_u" | "_v" | "_w" | "_z" | "allowance" | "approve" | "balanceOf" | "capManager" | "capParams" | "changePauseManager" | "decimals" | "decreaseAllowance" | "dirtyUninitializedOracleSamples" | "enableOracle" | "getActionId" | "getAuthorizer" | "getECLPParams" | "getInvariant" | "getLargestSafeQueryWindow" | "getLastInvariant" | "getLatest" | "getMiscData" | "getNormalizedWeights" | "getOwner" | "getPastAccumulators" | "getPausedState" | "getPoolId" | "getPrice" | "getRate" | "getSample" | "getSwapFeePercentage" | "getTimeWeightedAverage" | "getTokenRates" | "getTotalSamples" | "getVault" | "gyroConfig" | "increaseAllowance" | "name" | "nonces" | "onExitPool" | "onJoinPool" | "onSwap" | "pause" | "pauseManager" | "permit" | "queryExit" | "queryJoin" | "rateProvider0" | "rateProvider1" | "setCapManager" | "setCapParams" | "setPaused" | "setSwapFeePercentage" | "symbol" | "totalSupply" | "transfer" | "transferFrom" | "unpause"): FunctionFragment;
    encodeFunctionData(functionFragment: "DOMAIN_SEPARATOR", values?: undefined): string;
    encodeFunctionData(functionFragment: "_dSq", values?: undefined): string;
    encodeFunctionData(functionFragment: "_paramsAlpha", values?: undefined): string;
    encodeFunctionData(functionFragment: "_paramsBeta", values?: undefined): string;
    encodeFunctionData(functionFragment: "_paramsC", values?: undefined): string;
    encodeFunctionData(functionFragment: "_paramsLambda", values?: undefined): string;
    encodeFunctionData(functionFragment: "_paramsS", values?: undefined): string;
    encodeFunctionData(functionFragment: "_tauAlphaX", values?: undefined): string;
    encodeFunctionData(functionFragment: "_tauAlphaY", values?: undefined): string;
    encodeFunctionData(functionFragment: "_tauBetaX", values?: undefined): string;
    encodeFunctionData(functionFragment: "_tauBetaY", values?: undefined): string;
    encodeFunctionData(functionFragment: "_u", values?: undefined): string;
    encodeFunctionData(functionFragment: "_v", values?: undefined): string;
    encodeFunctionData(functionFragment: "_w", values?: undefined): string;
    encodeFunctionData(functionFragment: "_z", values?: undefined): string;
    encodeFunctionData(functionFragment: "allowance", values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "approve", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "balanceOf", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "capManager", values?: undefined): string;
    encodeFunctionData(functionFragment: "capParams", values?: undefined): string;
    encodeFunctionData(functionFragment: "changePauseManager", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "decimals", values?: undefined): string;
    encodeFunctionData(functionFragment: "decreaseAllowance", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "dirtyUninitializedOracleSamples", values: [PromiseOrValue<BigNumberish$1>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "enableOracle", values?: undefined): string;
    encodeFunctionData(functionFragment: "getActionId", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "getAuthorizer", values?: undefined): string;
    encodeFunctionData(functionFragment: "getECLPParams", values?: undefined): string;
    encodeFunctionData(functionFragment: "getInvariant", values?: undefined): string;
    encodeFunctionData(functionFragment: "getLargestSafeQueryWindow", values?: undefined): string;
    encodeFunctionData(functionFragment: "getLastInvariant", values?: undefined): string;
    encodeFunctionData(functionFragment: "getLatest", values: [PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "getMiscData", values?: undefined): string;
    encodeFunctionData(functionFragment: "getNormalizedWeights", values?: undefined): string;
    encodeFunctionData(functionFragment: "getOwner", values?: undefined): string;
    encodeFunctionData(functionFragment: "getPastAccumulators", values: [IPriceOracle.OracleAccumulatorQueryStruct[]]): string;
    encodeFunctionData(functionFragment: "getPausedState", values?: undefined): string;
    encodeFunctionData(functionFragment: "getPoolId", values?: undefined): string;
    encodeFunctionData(functionFragment: "getPrice", values?: undefined): string;
    encodeFunctionData(functionFragment: "getRate", values?: undefined): string;
    encodeFunctionData(functionFragment: "getSample", values: [PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "getSwapFeePercentage", values?: undefined): string;
    encodeFunctionData(functionFragment: "getTimeWeightedAverage", values: [IPriceOracle.OracleAverageQueryStruct[]]): string;
    encodeFunctionData(functionFragment: "getTokenRates", values?: undefined): string;
    encodeFunctionData(functionFragment: "getTotalSamples", values?: undefined): string;
    encodeFunctionData(functionFragment: "getVault", values?: undefined): string;
    encodeFunctionData(functionFragment: "gyroConfig", values?: undefined): string;
    encodeFunctionData(functionFragment: "increaseAllowance", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "name", values?: undefined): string;
    encodeFunctionData(functionFragment: "nonces", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "onExitPool", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "onJoinPool", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "onSwap", values: [
        IPoolSwapStructs.SwapRequestStruct,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "pause", values?: undefined): string;
    encodeFunctionData(functionFragment: "pauseManager", values?: undefined): string;
    encodeFunctionData(functionFragment: "permit", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "queryExit", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "queryJoin", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>[],
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BigNumberish$1>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "rateProvider0", values?: undefined): string;
    encodeFunctionData(functionFragment: "rateProvider1", values?: undefined): string;
    encodeFunctionData(functionFragment: "setCapManager", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "setCapParams", values: [ICappedLiquidity.CapParamsStruct]): string;
    encodeFunctionData(functionFragment: "setPaused", values: [PromiseOrValue<boolean>]): string;
    encodeFunctionData(functionFragment: "setSwapFeePercentage", values: [PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "symbol", values?: undefined): string;
    encodeFunctionData(functionFragment: "totalSupply", values?: undefined): string;
    encodeFunctionData(functionFragment: "transfer", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "transferFrom", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish$1>
    ]): string;
    encodeFunctionData(functionFragment: "unpause", values?: undefined): string;
    decodeFunctionResult(functionFragment: "DOMAIN_SEPARATOR", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "_dSq", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "_paramsAlpha", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "_paramsBeta", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "_paramsC", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "_paramsLambda", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "_paramsS", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "_tauAlphaX", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "_tauAlphaY", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "_tauBetaX", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "_tauBetaY", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "_u", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "_v", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "_w", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "_z", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "allowance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "approve", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "balanceOf", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "capManager", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "capParams", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "changePauseManager", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "decimals", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "decreaseAllowance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "dirtyUninitializedOracleSamples", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "enableOracle", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getActionId", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getAuthorizer", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getECLPParams", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getInvariant", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getLargestSafeQueryWindow", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getLastInvariant", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getLatest", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getMiscData", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getNormalizedWeights", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getOwner", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getPastAccumulators", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getPausedState", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getPoolId", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getPrice", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getRate", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getSample", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getSwapFeePercentage", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getTimeWeightedAverage", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getTokenRates", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getTotalSamples", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getVault", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "gyroConfig", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "increaseAllowance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "name", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "nonces", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "onExitPool", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "onJoinPool", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "onSwap", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "pause", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "pauseManager", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "permit", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "queryExit", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "queryJoin", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "rateProvider0", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "rateProvider1", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setCapManager", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setCapParams", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setPaused", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setSwapFeePercentage", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "symbol", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "totalSupply", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "transfer", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "transferFrom", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "unpause", data: BytesLike): Result;
    events: {
        "Approval(address,address,uint256)": EventFragment;
        "CapManagerUpdated(address)": EventFragment;
        "CapParamsUpdated(tuple)": EventFragment;
        "ECLPDerivedParamsValidated(bool)": EventFragment;
        "ECLPParamsValidated(bool)": EventFragment;
        "InvariantAterInitializeJoin(uint256)": EventFragment;
        "InvariantOldAndNew(uint256,uint256)": EventFragment;
        "OracleEnabledChanged(bool)": EventFragment;
        "OracleIndexUpdated(uint256)": EventFragment;
        "PauseManagerChanged(address,address)": EventFragment;
        "PausedLocally()": EventFragment;
        "PausedStateChanged(bool)": EventFragment;
        "SwapFeePercentageChanged(uint256)": EventFragment;
        "SwapParams(uint256[],tuple,uint256)": EventFragment;
        "Transfer(address,address,uint256)": EventFragment;
        "UnpausedLocally()": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "Approval"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "CapManagerUpdated"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "CapParamsUpdated"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "ECLPDerivedParamsValidated"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "ECLPParamsValidated"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "InvariantAterInitializeJoin"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "InvariantOldAndNew"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "OracleEnabledChanged"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "OracleIndexUpdated"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "PauseManagerChanged"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "PausedLocally"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "PausedStateChanged"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "SwapFeePercentageChanged"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "SwapParams"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Transfer"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "UnpausedLocally"): EventFragment;
}
interface ApprovalEventObject {
    owner: string;
    spender: string;
    value: BigNumber$1;
}
type ApprovalEvent = TypedEvent<[
    string,
    string,
    BigNumber$1
], ApprovalEventObject>;
type ApprovalEventFilter = TypedEventFilter<ApprovalEvent>;
interface CapManagerUpdatedEventObject {
    capManager: string;
}
type CapManagerUpdatedEvent = TypedEvent<[
    string
], CapManagerUpdatedEventObject>;
type CapManagerUpdatedEventFilter = TypedEventFilter<CapManagerUpdatedEvent>;
interface CapParamsUpdatedEventObject {
    params: ICappedLiquidity.CapParamsStructOutput;
}
type CapParamsUpdatedEvent = TypedEvent<[
    ICappedLiquidity.CapParamsStructOutput
], CapParamsUpdatedEventObject>;
type CapParamsUpdatedEventFilter = TypedEventFilter<CapParamsUpdatedEvent>;
interface ECLPDerivedParamsValidatedEventObject {
    derivedParamsValidated: boolean;
}
type ECLPDerivedParamsValidatedEvent = TypedEvent<[
    boolean
], ECLPDerivedParamsValidatedEventObject>;
type ECLPDerivedParamsValidatedEventFilter = TypedEventFilter<ECLPDerivedParamsValidatedEvent>;
interface ECLPParamsValidatedEventObject {
    paramsValidated: boolean;
}
type ECLPParamsValidatedEvent = TypedEvent<[
    boolean
], ECLPParamsValidatedEventObject>;
type ECLPParamsValidatedEventFilter = TypedEventFilter<ECLPParamsValidatedEvent>;
interface InvariantAterInitializeJoinEventObject {
    invariantAfterJoin: BigNumber$1;
}
type InvariantAterInitializeJoinEvent = TypedEvent<[
    BigNumber$1
], InvariantAterInitializeJoinEventObject>;
type InvariantAterInitializeJoinEventFilter = TypedEventFilter<InvariantAterInitializeJoinEvent>;
interface InvariantOldAndNewEventObject {
    oldInvariant: BigNumber$1;
    newInvariant: BigNumber$1;
}
type InvariantOldAndNewEvent = TypedEvent<[
    BigNumber$1,
    BigNumber$1
], InvariantOldAndNewEventObject>;
type InvariantOldAndNewEventFilter = TypedEventFilter<InvariantOldAndNewEvent>;
interface OracleEnabledChangedEventObject {
    enabled: boolean;
}
type OracleEnabledChangedEvent = TypedEvent<[
    boolean
], OracleEnabledChangedEventObject>;
type OracleEnabledChangedEventFilter = TypedEventFilter<OracleEnabledChangedEvent>;
interface OracleIndexUpdatedEventObject {
    oracleUpdatedIndex: BigNumber$1;
}
type OracleIndexUpdatedEvent = TypedEvent<[
    BigNumber$1
], OracleIndexUpdatedEventObject>;
type OracleIndexUpdatedEventFilter = TypedEventFilter<OracleIndexUpdatedEvent>;
interface PauseManagerChangedEventObject {
    oldPauseManager: string;
    newPauseManager: string;
}
type PauseManagerChangedEvent = TypedEvent<[
    string,
    string
], PauseManagerChangedEventObject>;
type PauseManagerChangedEventFilter = TypedEventFilter<PauseManagerChangedEvent>;
interface PausedLocallyEventObject {
}
type PausedLocallyEvent = TypedEvent<[], PausedLocallyEventObject>;
type PausedLocallyEventFilter = TypedEventFilter<PausedLocallyEvent>;
interface PausedStateChangedEventObject {
    paused: boolean;
}
type PausedStateChangedEvent = TypedEvent<[
    boolean
], PausedStateChangedEventObject>;
type PausedStateChangedEventFilter = TypedEventFilter<PausedStateChangedEvent>;
interface SwapFeePercentageChangedEventObject {
    swapFeePercentage: BigNumber$1;
}
type SwapFeePercentageChangedEvent = TypedEvent<[
    BigNumber$1
], SwapFeePercentageChangedEventObject>;
type SwapFeePercentageChangedEventFilter = TypedEventFilter<SwapFeePercentageChangedEvent>;
interface SwapParamsEventObject {
    balances: BigNumber$1[];
    invariant: GyroECLPMath.Vector2StructOutput;
    amount: BigNumber$1;
}
type SwapParamsEvent = TypedEvent<[
    BigNumber$1[],
    GyroECLPMath.Vector2StructOutput,
    BigNumber$1
], SwapParamsEventObject>;
type SwapParamsEventFilter = TypedEventFilter<SwapParamsEvent>;
interface TransferEventObject {
    from: string;
    to: string;
    value: BigNumber$1;
}
type TransferEvent = TypedEvent<[
    string,
    string,
    BigNumber$1
], TransferEventObject>;
type TransferEventFilter = TypedEventFilter<TransferEvent>;
interface UnpausedLocallyEventObject {
}
type UnpausedLocallyEvent = TypedEvent<[], UnpausedLocallyEventObject>;
type UnpausedLocallyEventFilter = TypedEventFilter<UnpausedLocallyEvent>;
interface GyroEV2 extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: GyroEV2Interface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<[string]>;
        _dSq(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        _paramsAlpha(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        _paramsBeta(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        _paramsC(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        _paramsLambda(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        _paramsS(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        _tauAlphaX(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        _tauAlphaY(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        _tauBetaX(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        _tauBetaY(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        _u(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        _v(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        _w(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        _z(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        capManager(overrides?: CallOverrides): Promise<[string]>;
        capParams(overrides?: CallOverrides): Promise<[ICappedLiquidity.CapParamsStructOutput]>;
        changePauseManager(_pauseManager: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        decimals(overrides?: CallOverrides): Promise<[number]>;
        decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        dirtyUninitializedOracleSamples(startIndex: PromiseOrValue<BigNumberish$1>, endIndex: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        enableOracle(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[string]>;
        getAuthorizer(overrides?: CallOverrides): Promise<[string]>;
        getECLPParams(overrides?: CallOverrides): Promise<[
            GyroECLPMath.ParamsStructOutput,
            GyroECLPMath.DerivedParamsStructOutput
        ] & {
            params: GyroECLPMath.ParamsStructOutput;
            d: GyroECLPMath.DerivedParamsStructOutput;
        }>;
        getInvariant(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getLargestSafeQueryWindow(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getLastInvariant(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getLatest(variable: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getMiscData(overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1,
            BigNumber$1,
            BigNumber$1,
            boolean,
            BigNumber$1
        ] & {
            logInvariant: BigNumber$1;
            logTotalSupply: BigNumber$1;
            oracleSampleCreationTimestamp: BigNumber$1;
            oracleIndex: BigNumber$1;
            oracleEnabled: boolean;
            swapFeePercentage: BigNumber$1;
        }>;
        getNormalizedWeights(overrides?: CallOverrides): Promise<[BigNumber$1[]]>;
        getOwner(overrides?: CallOverrides): Promise<[string]>;
        getPastAccumulators(queries: IPriceOracle.OracleAccumulatorQueryStruct[], overrides?: CallOverrides): Promise<[BigNumber$1[]] & {
            results: BigNumber$1[];
        }>;
        getPausedState(overrides?: CallOverrides): Promise<[
            boolean,
            BigNumber$1,
            BigNumber$1
        ] & {
            paused: boolean;
            pauseWindowEndTime: BigNumber$1;
            bufferPeriodEndTime: BigNumber$1;
        }>;
        getPoolId(overrides?: CallOverrides): Promise<[string]>;
        getPrice(overrides?: CallOverrides): Promise<[BigNumber$1] & {
            spotPrice: BigNumber$1;
        }>;
        getRate(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getSample(index: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1,
            BigNumber$1,
            BigNumber$1,
            BigNumber$1,
            BigNumber$1,
            BigNumber$1
        ] & {
            logPairPrice: BigNumber$1;
            accLogPairPrice: BigNumber$1;
            logBptPrice: BigNumber$1;
            accLogBptPrice: BigNumber$1;
            logInvariant: BigNumber$1;
            accLogInvariant: BigNumber$1;
            timestamp: BigNumber$1;
        }>;
        getSwapFeePercentage(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getTimeWeightedAverage(queries: IPriceOracle.OracleAverageQueryStruct[], overrides?: CallOverrides): Promise<[BigNumber$1[]] & {
            results: BigNumber$1[];
        }>;
        getTokenRates(overrides?: CallOverrides): Promise<[BigNumber$1, BigNumber$1] & {
            rate0: BigNumber$1;
            rate1: BigNumber$1;
        }>;
        getTotalSamples(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getVault(overrides?: CallOverrides): Promise<[string]>;
        gyroConfig(overrides?: CallOverrides): Promise<[string]>;
        increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        name(overrides?: CallOverrides): Promise<[string]>;
        nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        onJoinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        onSwap(request: IPoolSwapStructs.SwapRequestStruct, balanceTokenIn: PromiseOrValue<BigNumberish$1>, balanceTokenOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        pause(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        pauseManager(overrides?: CallOverrides): Promise<[string]>;
        permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        queryExit(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1[]
        ] & {
            bptIn: BigNumber$1;
            amountsOut: BigNumber$1[];
        }>;
        queryJoin(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1[]
        ] & {
            bptOut: BigNumber$1;
            amountsIn: BigNumber$1[];
        }>;
        rateProvider0(overrides?: CallOverrides): Promise<[string]>;
        rateProvider1(overrides?: CallOverrides): Promise<[string]>;
        setCapManager(_capManager: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setCapParams(params: ICappedLiquidity.CapParamsStruct, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setPaused(paused: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setSwapFeePercentage(swapFeePercentage: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        symbol(overrides?: CallOverrides): Promise<[string]>;
        totalSupply(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        unpause(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
    };
    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;
    _dSq(overrides?: CallOverrides): Promise<BigNumber$1>;
    _paramsAlpha(overrides?: CallOverrides): Promise<BigNumber$1>;
    _paramsBeta(overrides?: CallOverrides): Promise<BigNumber$1>;
    _paramsC(overrides?: CallOverrides): Promise<BigNumber$1>;
    _paramsLambda(overrides?: CallOverrides): Promise<BigNumber$1>;
    _paramsS(overrides?: CallOverrides): Promise<BigNumber$1>;
    _tauAlphaX(overrides?: CallOverrides): Promise<BigNumber$1>;
    _tauAlphaY(overrides?: CallOverrides): Promise<BigNumber$1>;
    _tauBetaX(overrides?: CallOverrides): Promise<BigNumber$1>;
    _tauBetaY(overrides?: CallOverrides): Promise<BigNumber$1>;
    _u(overrides?: CallOverrides): Promise<BigNumber$1>;
    _v(overrides?: CallOverrides): Promise<BigNumber$1>;
    _w(overrides?: CallOverrides): Promise<BigNumber$1>;
    _z(overrides?: CallOverrides): Promise<BigNumber$1>;
    allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    capManager(overrides?: CallOverrides): Promise<string>;
    capParams(overrides?: CallOverrides): Promise<ICappedLiquidity.CapParamsStructOutput>;
    changePauseManager(_pauseManager: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    decimals(overrides?: CallOverrides): Promise<number>;
    decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    dirtyUninitializedOracleSamples(startIndex: PromiseOrValue<BigNumberish$1>, endIndex: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    enableOracle(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
    getAuthorizer(overrides?: CallOverrides): Promise<string>;
    getECLPParams(overrides?: CallOverrides): Promise<[
        GyroECLPMath.ParamsStructOutput,
        GyroECLPMath.DerivedParamsStructOutput
    ] & {
        params: GyroECLPMath.ParamsStructOutput;
        d: GyroECLPMath.DerivedParamsStructOutput;
    }>;
    getInvariant(overrides?: CallOverrides): Promise<BigNumber$1>;
    getLargestSafeQueryWindow(overrides?: CallOverrides): Promise<BigNumber$1>;
    getLastInvariant(overrides?: CallOverrides): Promise<BigNumber$1>;
    getLatest(variable: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
    getMiscData(overrides?: CallOverrides): Promise<[
        BigNumber$1,
        BigNumber$1,
        BigNumber$1,
        BigNumber$1,
        boolean,
        BigNumber$1
    ] & {
        logInvariant: BigNumber$1;
        logTotalSupply: BigNumber$1;
        oracleSampleCreationTimestamp: BigNumber$1;
        oracleIndex: BigNumber$1;
        oracleEnabled: boolean;
        swapFeePercentage: BigNumber$1;
    }>;
    getNormalizedWeights(overrides?: CallOverrides): Promise<BigNumber$1[]>;
    getOwner(overrides?: CallOverrides): Promise<string>;
    getPastAccumulators(queries: IPriceOracle.OracleAccumulatorQueryStruct[], overrides?: CallOverrides): Promise<BigNumber$1[]>;
    getPausedState(overrides?: CallOverrides): Promise<[
        boolean,
        BigNumber$1,
        BigNumber$1
    ] & {
        paused: boolean;
        pauseWindowEndTime: BigNumber$1;
        bufferPeriodEndTime: BigNumber$1;
    }>;
    getPoolId(overrides?: CallOverrides): Promise<string>;
    getPrice(overrides?: CallOverrides): Promise<BigNumber$1>;
    getRate(overrides?: CallOverrides): Promise<BigNumber$1>;
    getSample(index: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<[
        BigNumber$1,
        BigNumber$1,
        BigNumber$1,
        BigNumber$1,
        BigNumber$1,
        BigNumber$1,
        BigNumber$1
    ] & {
        logPairPrice: BigNumber$1;
        accLogPairPrice: BigNumber$1;
        logBptPrice: BigNumber$1;
        accLogBptPrice: BigNumber$1;
        logInvariant: BigNumber$1;
        accLogInvariant: BigNumber$1;
        timestamp: BigNumber$1;
    }>;
    getSwapFeePercentage(overrides?: CallOverrides): Promise<BigNumber$1>;
    getTimeWeightedAverage(queries: IPriceOracle.OracleAverageQueryStruct[], overrides?: CallOverrides): Promise<BigNumber$1[]>;
    getTokenRates(overrides?: CallOverrides): Promise<[BigNumber$1, BigNumber$1] & {
        rate0: BigNumber$1;
        rate1: BigNumber$1;
    }>;
    getTotalSamples(overrides?: CallOverrides): Promise<BigNumber$1>;
    getVault(overrides?: CallOverrides): Promise<string>;
    gyroConfig(overrides?: CallOverrides): Promise<string>;
    increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    name(overrides?: CallOverrides): Promise<string>;
    nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    onJoinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    onSwap(request: IPoolSwapStructs.SwapRequestStruct, balanceTokenIn: PromiseOrValue<BigNumberish$1>, balanceTokenOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    pause(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    pauseManager(overrides?: CallOverrides): Promise<string>;
    permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    queryExit(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[
        BigNumber$1,
        BigNumber$1[]
    ] & {
        bptIn: BigNumber$1;
        amountsOut: BigNumber$1[];
    }>;
    queryJoin(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[
        BigNumber$1,
        BigNumber$1[]
    ] & {
        bptOut: BigNumber$1;
        amountsIn: BigNumber$1[];
    }>;
    rateProvider0(overrides?: CallOverrides): Promise<string>;
    rateProvider1(overrides?: CallOverrides): Promise<string>;
    setCapManager(_capManager: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setCapParams(params: ICappedLiquidity.CapParamsStruct, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setPaused(paused: PromiseOrValue<boolean>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setSwapFeePercentage(swapFeePercentage: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    symbol(overrides?: CallOverrides): Promise<string>;
    totalSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
    transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    unpause(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;
        _dSq(overrides?: CallOverrides): Promise<BigNumber$1>;
        _paramsAlpha(overrides?: CallOverrides): Promise<BigNumber$1>;
        _paramsBeta(overrides?: CallOverrides): Promise<BigNumber$1>;
        _paramsC(overrides?: CallOverrides): Promise<BigNumber$1>;
        _paramsLambda(overrides?: CallOverrides): Promise<BigNumber$1>;
        _paramsS(overrides?: CallOverrides): Promise<BigNumber$1>;
        _tauAlphaX(overrides?: CallOverrides): Promise<BigNumber$1>;
        _tauAlphaY(overrides?: CallOverrides): Promise<BigNumber$1>;
        _tauBetaX(overrides?: CallOverrides): Promise<BigNumber$1>;
        _tauBetaY(overrides?: CallOverrides): Promise<BigNumber$1>;
        _u(overrides?: CallOverrides): Promise<BigNumber$1>;
        _v(overrides?: CallOverrides): Promise<BigNumber$1>;
        _w(overrides?: CallOverrides): Promise<BigNumber$1>;
        _z(overrides?: CallOverrides): Promise<BigNumber$1>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        capManager(overrides?: CallOverrides): Promise<string>;
        capParams(overrides?: CallOverrides): Promise<ICappedLiquidity.CapParamsStructOutput>;
        changePauseManager(_pauseManager: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
        decimals(overrides?: CallOverrides): Promise<number>;
        decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        dirtyUninitializedOracleSamples(startIndex: PromiseOrValue<BigNumberish$1>, endIndex: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        enableOracle(overrides?: CallOverrides): Promise<void>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
        getAuthorizer(overrides?: CallOverrides): Promise<string>;
        getECLPParams(overrides?: CallOverrides): Promise<[
            GyroECLPMath.ParamsStructOutput,
            GyroECLPMath.DerivedParamsStructOutput
        ] & {
            params: GyroECLPMath.ParamsStructOutput;
            d: GyroECLPMath.DerivedParamsStructOutput;
        }>;
        getInvariant(overrides?: CallOverrides): Promise<BigNumber$1>;
        getLargestSafeQueryWindow(overrides?: CallOverrides): Promise<BigNumber$1>;
        getLastInvariant(overrides?: CallOverrides): Promise<BigNumber$1>;
        getLatest(variable: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getMiscData(overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1,
            BigNumber$1,
            BigNumber$1,
            boolean,
            BigNumber$1
        ] & {
            logInvariant: BigNumber$1;
            logTotalSupply: BigNumber$1;
            oracleSampleCreationTimestamp: BigNumber$1;
            oracleIndex: BigNumber$1;
            oracleEnabled: boolean;
            swapFeePercentage: BigNumber$1;
        }>;
        getNormalizedWeights(overrides?: CallOverrides): Promise<BigNumber$1[]>;
        getOwner(overrides?: CallOverrides): Promise<string>;
        getPastAccumulators(queries: IPriceOracle.OracleAccumulatorQueryStruct[], overrides?: CallOverrides): Promise<BigNumber$1[]>;
        getPausedState(overrides?: CallOverrides): Promise<[
            boolean,
            BigNumber$1,
            BigNumber$1
        ] & {
            paused: boolean;
            pauseWindowEndTime: BigNumber$1;
            bufferPeriodEndTime: BigNumber$1;
        }>;
        getPoolId(overrides?: CallOverrides): Promise<string>;
        getPrice(overrides?: CallOverrides): Promise<BigNumber$1>;
        getRate(overrides?: CallOverrides): Promise<BigNumber$1>;
        getSample(index: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1,
            BigNumber$1,
            BigNumber$1,
            BigNumber$1,
            BigNumber$1,
            BigNumber$1
        ] & {
            logPairPrice: BigNumber$1;
            accLogPairPrice: BigNumber$1;
            logBptPrice: BigNumber$1;
            accLogBptPrice: BigNumber$1;
            logInvariant: BigNumber$1;
            accLogInvariant: BigNumber$1;
            timestamp: BigNumber$1;
        }>;
        getSwapFeePercentage(overrides?: CallOverrides): Promise<BigNumber$1>;
        getTimeWeightedAverage(queries: IPriceOracle.OracleAverageQueryStruct[], overrides?: CallOverrides): Promise<BigNumber$1[]>;
        getTokenRates(overrides?: CallOverrides): Promise<[BigNumber$1, BigNumber$1] & {
            rate0: BigNumber$1;
            rate1: BigNumber$1;
        }>;
        getTotalSamples(overrides?: CallOverrides): Promise<BigNumber$1>;
        getVault(overrides?: CallOverrides): Promise<string>;
        gyroConfig(overrides?: CallOverrides): Promise<string>;
        increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        name(overrides?: CallOverrides): Promise<string>;
        nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[BigNumber$1[], BigNumber$1[]]>;
        onJoinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[
            BigNumber$1[],
            BigNumber$1[]
        ] & {
            amountsIn: BigNumber$1[];
            dueProtocolFeeAmounts: BigNumber$1[];
        }>;
        onSwap(request: IPoolSwapStructs.SwapRequestStruct, balanceTokenIn: PromiseOrValue<BigNumberish$1>, balanceTokenOut: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        pause(overrides?: CallOverrides): Promise<void>;
        pauseManager(overrides?: CallOverrides): Promise<string>;
        permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<void>;
        queryExit(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1[]
        ] & {
            bptIn: BigNumber$1;
            amountsOut: BigNumber$1[];
        }>;
        queryJoin(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1[]
        ] & {
            bptOut: BigNumber$1;
            amountsIn: BigNumber$1[];
        }>;
        rateProvider0(overrides?: CallOverrides): Promise<string>;
        rateProvider1(overrides?: CallOverrides): Promise<string>;
        setCapManager(_capManager: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
        setCapParams(params: ICappedLiquidity.CapParamsStruct, overrides?: CallOverrides): Promise<void>;
        setPaused(paused: PromiseOrValue<boolean>, overrides?: CallOverrides): Promise<void>;
        setSwapFeePercentage(swapFeePercentage: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        symbol(overrides?: CallOverrides): Promise<string>;
        totalSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
        transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<boolean>;
        unpause(overrides?: CallOverrides): Promise<void>;
    };
    filters: {
        "Approval(address,address,uint256)"(owner?: PromiseOrValue<string> | null, spender?: PromiseOrValue<string> | null, value?: null): ApprovalEventFilter;
        Approval(owner?: PromiseOrValue<string> | null, spender?: PromiseOrValue<string> | null, value?: null): ApprovalEventFilter;
        "CapManagerUpdated(address)"(capManager?: null): CapManagerUpdatedEventFilter;
        CapManagerUpdated(capManager?: null): CapManagerUpdatedEventFilter;
        "CapParamsUpdated(tuple)"(params?: null): CapParamsUpdatedEventFilter;
        CapParamsUpdated(params?: null): CapParamsUpdatedEventFilter;
        "ECLPDerivedParamsValidated(bool)"(derivedParamsValidated?: null): ECLPDerivedParamsValidatedEventFilter;
        ECLPDerivedParamsValidated(derivedParamsValidated?: null): ECLPDerivedParamsValidatedEventFilter;
        "ECLPParamsValidated(bool)"(paramsValidated?: null): ECLPParamsValidatedEventFilter;
        ECLPParamsValidated(paramsValidated?: null): ECLPParamsValidatedEventFilter;
        "InvariantAterInitializeJoin(uint256)"(invariantAfterJoin?: null): InvariantAterInitializeJoinEventFilter;
        InvariantAterInitializeJoin(invariantAfterJoin?: null): InvariantAterInitializeJoinEventFilter;
        "InvariantOldAndNew(uint256,uint256)"(oldInvariant?: null, newInvariant?: null): InvariantOldAndNewEventFilter;
        InvariantOldAndNew(oldInvariant?: null, newInvariant?: null): InvariantOldAndNewEventFilter;
        "OracleEnabledChanged(bool)"(enabled?: null): OracleEnabledChangedEventFilter;
        OracleEnabledChanged(enabled?: null): OracleEnabledChangedEventFilter;
        "OracleIndexUpdated(uint256)"(oracleUpdatedIndex?: null): OracleIndexUpdatedEventFilter;
        OracleIndexUpdated(oracleUpdatedIndex?: null): OracleIndexUpdatedEventFilter;
        "PauseManagerChanged(address,address)"(oldPauseManager?: null, newPauseManager?: null): PauseManagerChangedEventFilter;
        PauseManagerChanged(oldPauseManager?: null, newPauseManager?: null): PauseManagerChangedEventFilter;
        "PausedLocally()"(): PausedLocallyEventFilter;
        PausedLocally(): PausedLocallyEventFilter;
        "PausedStateChanged(bool)"(paused?: null): PausedStateChangedEventFilter;
        PausedStateChanged(paused?: null): PausedStateChangedEventFilter;
        "SwapFeePercentageChanged(uint256)"(swapFeePercentage?: null): SwapFeePercentageChangedEventFilter;
        SwapFeePercentageChanged(swapFeePercentage?: null): SwapFeePercentageChangedEventFilter;
        "SwapParams(uint256[],tuple,uint256)"(balances?: null, invariant?: null, amount?: null): SwapParamsEventFilter;
        SwapParams(balances?: null, invariant?: null, amount?: null): SwapParamsEventFilter;
        "Transfer(address,address,uint256)"(from?: PromiseOrValue<string> | null, to?: PromiseOrValue<string> | null, value?: null): TransferEventFilter;
        Transfer(from?: PromiseOrValue<string> | null, to?: PromiseOrValue<string> | null, value?: null): TransferEventFilter;
        "UnpausedLocally()"(): UnpausedLocallyEventFilter;
        UnpausedLocally(): UnpausedLocallyEventFilter;
    };
    estimateGas: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<BigNumber$1>;
        _dSq(overrides?: CallOverrides): Promise<BigNumber$1>;
        _paramsAlpha(overrides?: CallOverrides): Promise<BigNumber$1>;
        _paramsBeta(overrides?: CallOverrides): Promise<BigNumber$1>;
        _paramsC(overrides?: CallOverrides): Promise<BigNumber$1>;
        _paramsLambda(overrides?: CallOverrides): Promise<BigNumber$1>;
        _paramsS(overrides?: CallOverrides): Promise<BigNumber$1>;
        _tauAlphaX(overrides?: CallOverrides): Promise<BigNumber$1>;
        _tauAlphaY(overrides?: CallOverrides): Promise<BigNumber$1>;
        _tauBetaX(overrides?: CallOverrides): Promise<BigNumber$1>;
        _tauBetaY(overrides?: CallOverrides): Promise<BigNumber$1>;
        _u(overrides?: CallOverrides): Promise<BigNumber$1>;
        _v(overrides?: CallOverrides): Promise<BigNumber$1>;
        _w(overrides?: CallOverrides): Promise<BigNumber$1>;
        _z(overrides?: CallOverrides): Promise<BigNumber$1>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        capManager(overrides?: CallOverrides): Promise<BigNumber$1>;
        capParams(overrides?: CallOverrides): Promise<BigNumber$1>;
        changePauseManager(_pauseManager: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        decimals(overrides?: CallOverrides): Promise<BigNumber$1>;
        decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        dirtyUninitializedOracleSamples(startIndex: PromiseOrValue<BigNumberish$1>, endIndex: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        enableOracle(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getAuthorizer(overrides?: CallOverrides): Promise<BigNumber$1>;
        getECLPParams(overrides?: CallOverrides): Promise<BigNumber$1>;
        getInvariant(overrides?: CallOverrides): Promise<BigNumber$1>;
        getLargestSafeQueryWindow(overrides?: CallOverrides): Promise<BigNumber$1>;
        getLastInvariant(overrides?: CallOverrides): Promise<BigNumber$1>;
        getLatest(variable: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getMiscData(overrides?: CallOverrides): Promise<BigNumber$1>;
        getNormalizedWeights(overrides?: CallOverrides): Promise<BigNumber$1>;
        getOwner(overrides?: CallOverrides): Promise<BigNumber$1>;
        getPastAccumulators(queries: IPriceOracle.OracleAccumulatorQueryStruct[], overrides?: CallOverrides): Promise<BigNumber$1>;
        getPausedState(overrides?: CallOverrides): Promise<BigNumber$1>;
        getPoolId(overrides?: CallOverrides): Promise<BigNumber$1>;
        getPrice(overrides?: CallOverrides): Promise<BigNumber$1>;
        getRate(overrides?: CallOverrides): Promise<BigNumber$1>;
        getSample(index: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getSwapFeePercentage(overrides?: CallOverrides): Promise<BigNumber$1>;
        getTimeWeightedAverage(queries: IPriceOracle.OracleAverageQueryStruct[], overrides?: CallOverrides): Promise<BigNumber$1>;
        getTokenRates(overrides?: CallOverrides): Promise<BigNumber$1>;
        getTotalSamples(overrides?: CallOverrides): Promise<BigNumber$1>;
        getVault(overrides?: CallOverrides): Promise<BigNumber$1>;
        gyroConfig(overrides?: CallOverrides): Promise<BigNumber$1>;
        increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        name(overrides?: CallOverrides): Promise<BigNumber$1>;
        nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        onJoinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        onSwap(request: IPoolSwapStructs.SwapRequestStruct, balanceTokenIn: PromiseOrValue<BigNumberish$1>, balanceTokenOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        pause(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        pauseManager(overrides?: CallOverrides): Promise<BigNumber$1>;
        permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        queryExit(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber$1>;
        queryJoin(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber$1>;
        rateProvider0(overrides?: CallOverrides): Promise<BigNumber$1>;
        rateProvider1(overrides?: CallOverrides): Promise<BigNumber$1>;
        setCapManager(_capManager: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        setCapParams(params: ICappedLiquidity.CapParamsStruct, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        setPaused(paused: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        setSwapFeePercentage(swapFeePercentage: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        symbol(overrides?: CallOverrides): Promise<BigNumber$1>;
        totalSupply(overrides?: CallOverrides): Promise<BigNumber$1>;
        transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        unpause(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
    };
    populateTransaction: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        _dSq(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        _paramsAlpha(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        _paramsBeta(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        _paramsC(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        _paramsLambda(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        _paramsS(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        _tauAlphaX(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        _tauAlphaY(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        _tauBetaX(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        _tauBetaY(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        _u(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        _v(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        _w(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        _z(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        allowance(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        approve(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        balanceOf(account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        capManager(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        capParams(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        changePauseManager(_pauseManager: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        decimals(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        decreaseAllowance(spender: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        dirtyUninitializedOracleSamples(startIndex: PromiseOrValue<BigNumberish$1>, endIndex: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        enableOracle(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getAuthorizer(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getECLPParams(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getInvariant(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getLargestSafeQueryWindow(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getLastInvariant(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getLatest(variable: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getMiscData(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getNormalizedWeights(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getOwner(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getPastAccumulators(queries: IPriceOracle.OracleAccumulatorQueryStruct[], overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getPausedState(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getPoolId(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getPrice(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getRate(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getSample(index: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getSwapFeePercentage(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getTimeWeightedAverage(queries: IPriceOracle.OracleAverageQueryStruct[], overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getTokenRates(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getTotalSamples(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getVault(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        gyroConfig(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        increaseAllowance(spender: PromiseOrValue<string>, addedValue: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        name(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        nonces(owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        onExitPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        onJoinPool(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        onSwap(request: IPoolSwapStructs.SwapRequestStruct, balanceTokenIn: PromiseOrValue<BigNumberish$1>, balanceTokenOut: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        pause(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        pauseManager(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        permit(owner: PromiseOrValue<string>, spender: PromiseOrValue<string>, value: PromiseOrValue<BigNumberish$1>, deadline: PromiseOrValue<BigNumberish$1>, v: PromiseOrValue<BigNumberish$1>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        queryExit(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        queryJoin(poolId: PromiseOrValue<BytesLike>, sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, balances: PromiseOrValue<BigNumberish$1>[], lastChangeBlock: PromiseOrValue<BigNumberish$1>, protocolSwapFeePercentage: PromiseOrValue<BigNumberish$1>, userData: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        rateProvider0(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        rateProvider1(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        setCapManager(_capManager: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setCapParams(params: ICappedLiquidity.CapParamsStruct, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setPaused(paused: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setSwapFeePercentage(swapFeePercentage: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        symbol(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        totalSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        transfer(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        transferFrom(sender: PromiseOrValue<string>, recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        unpause(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
    };
}

interface VeBalInterface extends utils.Interface {
    functions: {
        "token()": FunctionFragment;
        "name()": FunctionFragment;
        "symbol()": FunctionFragment;
        "decimals()": FunctionFragment;
        "admin()": FunctionFragment;
        "commit_smart_wallet_checker(address)": FunctionFragment;
        "apply_smart_wallet_checker()": FunctionFragment;
        "get_last_user_slope(address)": FunctionFragment;
        "user_point_history__ts(address,uint256)": FunctionFragment;
        "locked__end(address)": FunctionFragment;
        "checkpoint()": FunctionFragment;
        "deposit_for(address,uint256)": FunctionFragment;
        "create_lock(uint256,uint256)": FunctionFragment;
        "increase_amount(uint256)": FunctionFragment;
        "increase_unlock_time(uint256)": FunctionFragment;
        "withdraw()": FunctionFragment;
        "balanceOf(address)": FunctionFragment;
        "balanceOf(address,uint256)": FunctionFragment;
        "balanceOfAt(address,uint256)": FunctionFragment;
        "totalSupply()": FunctionFragment;
        "totalSupply(uint256)": FunctionFragment;
        "totalSupplyAt(uint256)": FunctionFragment;
        "supply()": FunctionFragment;
        "locked(address)": FunctionFragment;
        "epoch()": FunctionFragment;
        "point_history(uint256)": FunctionFragment;
        "user_point_history(address,uint256)": FunctionFragment;
        "user_point_epoch(address)": FunctionFragment;
        "slope_changes(uint256)": FunctionFragment;
        "future_smart_wallet_checker()": FunctionFragment;
        "smart_wallet_checker()": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "token" | "name" | "symbol" | "decimals" | "admin" | "commit_smart_wallet_checker" | "apply_smart_wallet_checker" | "get_last_user_slope" | "user_point_history__ts" | "locked__end" | "checkpoint" | "deposit_for" | "create_lock" | "increase_amount" | "increase_unlock_time" | "withdraw" | "balanceOf(address)" | "balanceOf(address,uint256)" | "balanceOfAt" | "totalSupply()" | "totalSupply(uint256)" | "totalSupplyAt" | "supply" | "locked" | "epoch" | "point_history" | "user_point_history" | "user_point_epoch" | "slope_changes" | "future_smart_wallet_checker" | "smart_wallet_checker"): FunctionFragment;
    encodeFunctionData(functionFragment: "token", values?: undefined): string;
    encodeFunctionData(functionFragment: "name", values?: undefined): string;
    encodeFunctionData(functionFragment: "symbol", values?: undefined): string;
    encodeFunctionData(functionFragment: "decimals", values?: undefined): string;
    encodeFunctionData(functionFragment: "admin", values?: undefined): string;
    encodeFunctionData(functionFragment: "commit_smart_wallet_checker", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "apply_smart_wallet_checker", values?: undefined): string;
    encodeFunctionData(functionFragment: "get_last_user_slope", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "user_point_history__ts", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "locked__end", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "checkpoint", values?: undefined): string;
    encodeFunctionData(functionFragment: "deposit_for", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "create_lock", values: [PromiseOrValue<BigNumberish$1>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "increase_amount", values: [PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "increase_unlock_time", values: [PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "withdraw", values?: undefined): string;
    encodeFunctionData(functionFragment: "balanceOf(address)", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "balanceOf(address,uint256)", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "balanceOfAt", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "totalSupply()", values?: undefined): string;
    encodeFunctionData(functionFragment: "totalSupply(uint256)", values: [PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "totalSupplyAt", values: [PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "supply", values?: undefined): string;
    encodeFunctionData(functionFragment: "locked", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "epoch", values?: undefined): string;
    encodeFunctionData(functionFragment: "point_history", values: [PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "user_point_history", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "user_point_epoch", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "slope_changes", values: [PromiseOrValue<BigNumberish$1>]): string;
    encodeFunctionData(functionFragment: "future_smart_wallet_checker", values?: undefined): string;
    encodeFunctionData(functionFragment: "smart_wallet_checker", values?: undefined): string;
    decodeFunctionResult(functionFragment: "token", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "name", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "symbol", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "decimals", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "admin", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "commit_smart_wallet_checker", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "apply_smart_wallet_checker", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "get_last_user_slope", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "user_point_history__ts", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "locked__end", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "checkpoint", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "deposit_for", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "create_lock", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "increase_amount", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "increase_unlock_time", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "withdraw", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "balanceOf(address)", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "balanceOf(address,uint256)", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "balanceOfAt", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "totalSupply()", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "totalSupply(uint256)", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "totalSupplyAt", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "supply", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "locked", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "epoch", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "point_history", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "user_point_history", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "user_point_epoch", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "slope_changes", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "future_smart_wallet_checker", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "smart_wallet_checker", data: BytesLike): Result;
    events: {
        "Deposit(address,uint256,uint256,int128,uint256)": EventFragment;
        "Withdraw(address,uint256,uint256)": EventFragment;
        "Supply(uint256,uint256)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "Deposit"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Withdraw"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Supply"): EventFragment;
}
interface DepositEventObject {
    provider: string;
    value: BigNumber$1;
    locktime: BigNumber$1;
    type: BigNumber$1;
    ts: BigNumber$1;
}
type DepositEvent = TypedEvent<[
    string,
    BigNumber$1,
    BigNumber$1,
    BigNumber$1,
    BigNumber$1
], DepositEventObject>;
type DepositEventFilter = TypedEventFilter<DepositEvent>;
interface WithdrawEventObject {
    provider: string;
    value: BigNumber$1;
    ts: BigNumber$1;
}
type WithdrawEvent = TypedEvent<[
    string,
    BigNumber$1,
    BigNumber$1
], WithdrawEventObject>;
type WithdrawEventFilter = TypedEventFilter<WithdrawEvent>;
interface SupplyEventObject {
    prevSupply: BigNumber$1;
    supply: BigNumber$1;
}
type SupplyEvent = TypedEvent<[BigNumber$1, BigNumber$1], SupplyEventObject>;
type SupplyEventFilter = TypedEventFilter<SupplyEvent>;
interface VeBal$1 extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: VeBalInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        token(overrides?: CallOverrides): Promise<[string]>;
        name(overrides?: CallOverrides): Promise<[string]>;
        symbol(overrides?: CallOverrides): Promise<[string]>;
        decimals(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        admin(overrides?: CallOverrides): Promise<[string]>;
        commit_smart_wallet_checker(addr: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        apply_smart_wallet_checker(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        get_last_user_slope(addr: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        user_point_history__ts(_addr: PromiseOrValue<string>, _idx: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        locked__end(_addr: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        checkpoint(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        deposit_for(_addr: PromiseOrValue<string>, _value: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        create_lock(_value: PromiseOrValue<BigNumberish$1>, _unlock_time: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        increase_amount(_value: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        increase_unlock_time(_unlock_time: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        withdraw(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        "balanceOf(address)"(addr: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        "balanceOf(address,uint256)"(addr: PromiseOrValue<string>, _t: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        balanceOfAt(addr: PromiseOrValue<string>, _block: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        "totalSupply()"(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        "totalSupply(uint256)"(t: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        totalSupplyAt(_block: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        supply(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        locked(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[
            [BigNumber$1, BigNumber$1] & {
                amount: BigNumber$1;
                end: BigNumber$1;
            }
        ]>;
        epoch(overrides?: CallOverrides): Promise<[BigNumber$1]>;
        point_history(arg0: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<[
            [
                BigNumber$1,
                BigNumber$1,
                BigNumber$1,
                BigNumber$1
            ] & {
                bias: BigNumber$1;
                slope: BigNumber$1;
                ts: BigNumber$1;
                blk: BigNumber$1;
            }
        ]>;
        user_point_history(arg0: PromiseOrValue<string>, arg1: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<[
            [
                BigNumber$1,
                BigNumber$1,
                BigNumber$1,
                BigNumber$1
            ] & {
                bias: BigNumber$1;
                slope: BigNumber$1;
                ts: BigNumber$1;
                blk: BigNumber$1;
            }
        ]>;
        user_point_epoch(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        slope_changes(arg0: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        future_smart_wallet_checker(overrides?: CallOverrides): Promise<[string]>;
        smart_wallet_checker(overrides?: CallOverrides): Promise<[string]>;
    };
    token(overrides?: CallOverrides): Promise<string>;
    name(overrides?: CallOverrides): Promise<string>;
    symbol(overrides?: CallOverrides): Promise<string>;
    decimals(overrides?: CallOverrides): Promise<BigNumber$1>;
    admin(overrides?: CallOverrides): Promise<string>;
    commit_smart_wallet_checker(addr: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    apply_smart_wallet_checker(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    get_last_user_slope(addr: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    user_point_history__ts(_addr: PromiseOrValue<string>, _idx: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
    locked__end(_addr: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    checkpoint(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    deposit_for(_addr: PromiseOrValue<string>, _value: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    create_lock(_value: PromiseOrValue<BigNumberish$1>, _unlock_time: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    increase_amount(_value: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    increase_unlock_time(_unlock_time: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    withdraw(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    "balanceOf(address)"(addr: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    "balanceOf(address,uint256)"(addr: PromiseOrValue<string>, _t: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
    balanceOfAt(addr: PromiseOrValue<string>, _block: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
    "totalSupply()"(overrides?: CallOverrides): Promise<BigNumber$1>;
    "totalSupply(uint256)"(t: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
    totalSupplyAt(_block: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
    supply(overrides?: CallOverrides): Promise<BigNumber$1>;
    locked(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1, BigNumber$1] & {
        amount: BigNumber$1;
        end: BigNumber$1;
    }>;
    epoch(overrides?: CallOverrides): Promise<BigNumber$1>;
    point_history(arg0: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<[
        BigNumber$1,
        BigNumber$1,
        BigNumber$1,
        BigNumber$1
    ] & {
        bias: BigNumber$1;
        slope: BigNumber$1;
        ts: BigNumber$1;
        blk: BigNumber$1;
    }>;
    user_point_history(arg0: PromiseOrValue<string>, arg1: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<[
        BigNumber$1,
        BigNumber$1,
        BigNumber$1,
        BigNumber$1
    ] & {
        bias: BigNumber$1;
        slope: BigNumber$1;
        ts: BigNumber$1;
        blk: BigNumber$1;
    }>;
    user_point_epoch(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    slope_changes(arg0: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
    future_smart_wallet_checker(overrides?: CallOverrides): Promise<string>;
    smart_wallet_checker(overrides?: CallOverrides): Promise<string>;
    callStatic: {
        token(overrides?: CallOverrides): Promise<string>;
        name(overrides?: CallOverrides): Promise<string>;
        symbol(overrides?: CallOverrides): Promise<string>;
        decimals(overrides?: CallOverrides): Promise<BigNumber$1>;
        admin(overrides?: CallOverrides): Promise<string>;
        commit_smart_wallet_checker(addr: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
        apply_smart_wallet_checker(overrides?: CallOverrides): Promise<void>;
        get_last_user_slope(addr: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        user_point_history__ts(_addr: PromiseOrValue<string>, _idx: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        locked__end(_addr: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        checkpoint(overrides?: CallOverrides): Promise<void>;
        deposit_for(_addr: PromiseOrValue<string>, _value: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        create_lock(_value: PromiseOrValue<BigNumberish$1>, _unlock_time: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        increase_amount(_value: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        increase_unlock_time(_unlock_time: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<void>;
        withdraw(overrides?: CallOverrides): Promise<void>;
        "balanceOf(address)"(addr: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        "balanceOf(address,uint256)"(addr: PromiseOrValue<string>, _t: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        balanceOfAt(addr: PromiseOrValue<string>, _block: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        "totalSupply()"(overrides?: CallOverrides): Promise<BigNumber$1>;
        "totalSupply(uint256)"(t: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        totalSupplyAt(_block: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        supply(overrides?: CallOverrides): Promise<BigNumber$1>;
        locked(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1, BigNumber$1] & {
            amount: BigNumber$1;
            end: BigNumber$1;
        }>;
        epoch(overrides?: CallOverrides): Promise<BigNumber$1>;
        point_history(arg0: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1,
            BigNumber$1,
            BigNumber$1
        ] & {
            bias: BigNumber$1;
            slope: BigNumber$1;
            ts: BigNumber$1;
            blk: BigNumber$1;
        }>;
        user_point_history(arg0: PromiseOrValue<string>, arg1: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<[
            BigNumber$1,
            BigNumber$1,
            BigNumber$1,
            BigNumber$1
        ] & {
            bias: BigNumber$1;
            slope: BigNumber$1;
            ts: BigNumber$1;
            blk: BigNumber$1;
        }>;
        user_point_epoch(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        slope_changes(arg0: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        future_smart_wallet_checker(overrides?: CallOverrides): Promise<string>;
        smart_wallet_checker(overrides?: CallOverrides): Promise<string>;
    };
    filters: {
        "Deposit(address,uint256,uint256,int128,uint256)"(provider?: PromiseOrValue<string> | null, value?: null, locktime?: PromiseOrValue<BigNumberish$1> | null, type?: null, ts?: null): DepositEventFilter;
        Deposit(provider?: PromiseOrValue<string> | null, value?: null, locktime?: PromiseOrValue<BigNumberish$1> | null, type?: null, ts?: null): DepositEventFilter;
        "Withdraw(address,uint256,uint256)"(provider?: PromiseOrValue<string> | null, value?: null, ts?: null): WithdrawEventFilter;
        Withdraw(provider?: PromiseOrValue<string> | null, value?: null, ts?: null): WithdrawEventFilter;
        "Supply(uint256,uint256)"(prevSupply?: null, supply?: null): SupplyEventFilter;
        Supply(prevSupply?: null, supply?: null): SupplyEventFilter;
    };
    estimateGas: {
        token(overrides?: CallOverrides): Promise<BigNumber$1>;
        name(overrides?: CallOverrides): Promise<BigNumber$1>;
        symbol(overrides?: CallOverrides): Promise<BigNumber$1>;
        decimals(overrides?: CallOverrides): Promise<BigNumber$1>;
        admin(overrides?: CallOverrides): Promise<BigNumber$1>;
        commit_smart_wallet_checker(addr: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        apply_smart_wallet_checker(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        get_last_user_slope(addr: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        user_point_history__ts(_addr: PromiseOrValue<string>, _idx: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        locked__end(_addr: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        checkpoint(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        deposit_for(_addr: PromiseOrValue<string>, _value: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        create_lock(_value: PromiseOrValue<BigNumberish$1>, _unlock_time: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        increase_amount(_value: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        increase_unlock_time(_unlock_time: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        withdraw(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        "balanceOf(address)"(addr: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        "balanceOf(address,uint256)"(addr: PromiseOrValue<string>, _t: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        balanceOfAt(addr: PromiseOrValue<string>, _block: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        "totalSupply()"(overrides?: CallOverrides): Promise<BigNumber$1>;
        "totalSupply(uint256)"(t: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        totalSupplyAt(_block: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        supply(overrides?: CallOverrides): Promise<BigNumber$1>;
        locked(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        epoch(overrides?: CallOverrides): Promise<BigNumber$1>;
        point_history(arg0: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        user_point_history(arg0: PromiseOrValue<string>, arg1: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        user_point_epoch(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        slope_changes(arg0: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<BigNumber$1>;
        future_smart_wallet_checker(overrides?: CallOverrides): Promise<BigNumber$1>;
        smart_wallet_checker(overrides?: CallOverrides): Promise<BigNumber$1>;
    };
    populateTransaction: {
        token(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        name(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        symbol(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        decimals(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        admin(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        commit_smart_wallet_checker(addr: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        apply_smart_wallet_checker(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        get_last_user_slope(addr: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        user_point_history__ts(_addr: PromiseOrValue<string>, _idx: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        locked__end(_addr: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        checkpoint(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        deposit_for(_addr: PromiseOrValue<string>, _value: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        create_lock(_value: PromiseOrValue<BigNumberish$1>, _unlock_time: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        increase_amount(_value: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        increase_unlock_time(_unlock_time: PromiseOrValue<BigNumberish$1>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        withdraw(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        "balanceOf(address)"(addr: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        "balanceOf(address,uint256)"(addr: PromiseOrValue<string>, _t: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        balanceOfAt(addr: PromiseOrValue<string>, _block: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        "totalSupply()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        "totalSupply(uint256)"(t: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        totalSupplyAt(_block: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        supply(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        locked(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        epoch(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        point_history(arg0: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        user_point_history(arg0: PromiseOrValue<string>, arg1: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        user_point_epoch(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        slope_changes(arg0: PromiseOrValue<BigNumberish$1>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        future_smart_wallet_checker(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        smart_wallet_checker(overrides?: CallOverrides): Promise<PopulatedTransaction>;
    };
}

interface VeDelegationProxyInterface extends utils.Interface {
    functions: {
        "adjustedBalanceOf(address)": FunctionFragment;
        "adjusted_balance_of(address)": FunctionFragment;
        "getActionId(bytes4)": FunctionFragment;
        "getAuthorizer()": FunctionFragment;
        "getDelegationImplementation()": FunctionFragment;
        "getVault()": FunctionFragment;
        "getVotingEscrow()": FunctionFragment;
        "killDelegation()": FunctionFragment;
        "setDelegation(address)": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "adjustedBalanceOf" | "adjusted_balance_of" | "getActionId" | "getAuthorizer" | "getDelegationImplementation" | "getVault" | "getVotingEscrow" | "killDelegation" | "setDelegation"): FunctionFragment;
    encodeFunctionData(functionFragment: "adjustedBalanceOf", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "adjusted_balance_of", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "getActionId", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "getAuthorizer", values?: undefined): string;
    encodeFunctionData(functionFragment: "getDelegationImplementation", values?: undefined): string;
    encodeFunctionData(functionFragment: "getVault", values?: undefined): string;
    encodeFunctionData(functionFragment: "getVotingEscrow", values?: undefined): string;
    encodeFunctionData(functionFragment: "killDelegation", values?: undefined): string;
    encodeFunctionData(functionFragment: "setDelegation", values: [PromiseOrValue<string>]): string;
    decodeFunctionResult(functionFragment: "adjustedBalanceOf", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "adjusted_balance_of", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getActionId", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getAuthorizer", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getDelegationImplementation", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getVault", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getVotingEscrow", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "killDelegation", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setDelegation", data: BytesLike): Result;
    events: {
        "DelegationImplementationUpdated(address)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "DelegationImplementationUpdated"): EventFragment;
}
interface DelegationImplementationUpdatedEventObject {
    newImplementation: string;
}
type DelegationImplementationUpdatedEvent = TypedEvent<[
    string
], DelegationImplementationUpdatedEventObject>;
type DelegationImplementationUpdatedEventFilter = TypedEventFilter<DelegationImplementationUpdatedEvent>;
interface VeDelegationProxy extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: VeDelegationProxyInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        adjustedBalanceOf(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        adjusted_balance_of(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber$1]>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[string]>;
        getAuthorizer(overrides?: CallOverrides): Promise<[string]>;
        getDelegationImplementation(overrides?: CallOverrides): Promise<[string]>;
        getVault(overrides?: CallOverrides): Promise<[string]>;
        getVotingEscrow(overrides?: CallOverrides): Promise<[string]>;
        killDelegation(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setDelegation(delegation: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
    };
    adjustedBalanceOf(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    adjusted_balance_of(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
    getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
    getAuthorizer(overrides?: CallOverrides): Promise<string>;
    getDelegationImplementation(overrides?: CallOverrides): Promise<string>;
    getVault(overrides?: CallOverrides): Promise<string>;
    getVotingEscrow(overrides?: CallOverrides): Promise<string>;
    killDelegation(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setDelegation(delegation: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        adjustedBalanceOf(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        adjusted_balance_of(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
        getAuthorizer(overrides?: CallOverrides): Promise<string>;
        getDelegationImplementation(overrides?: CallOverrides): Promise<string>;
        getVault(overrides?: CallOverrides): Promise<string>;
        getVotingEscrow(overrides?: CallOverrides): Promise<string>;
        killDelegation(overrides?: CallOverrides): Promise<void>;
        setDelegation(delegation: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
    };
    filters: {
        "DelegationImplementationUpdated(address)"(newImplementation?: PromiseOrValue<string> | null): DelegationImplementationUpdatedEventFilter;
        DelegationImplementationUpdated(newImplementation?: PromiseOrValue<string> | null): DelegationImplementationUpdatedEventFilter;
    };
    estimateGas: {
        adjustedBalanceOf(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        adjusted_balance_of(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber$1>;
        getAuthorizer(overrides?: CallOverrides): Promise<BigNumber$1>;
        getDelegationImplementation(overrides?: CallOverrides): Promise<BigNumber$1>;
        getVault(overrides?: CallOverrides): Promise<BigNumber$1>;
        getVotingEscrow(overrides?: CallOverrides): Promise<BigNumber$1>;
        killDelegation(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
        setDelegation(delegation: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber$1>;
    };
    populateTransaction: {
        adjustedBalanceOf(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        adjusted_balance_of(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getActionId(selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getAuthorizer(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getDelegationImplementation(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getVault(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getVotingEscrow(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        killDelegation(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setDelegation(delegation: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
    };
}

declare class AaveLinearPool__factory {
    static readonly abi: readonly [{
        readonly inputs: readonly [{
            readonly components: readonly [{
                readonly internalType: "contract IVault";
                readonly name: "vault";
                readonly type: "address";
            }, {
                readonly internalType: "string";
                readonly name: "name";
                readonly type: "string";
            }, {
                readonly internalType: "string";
                readonly name: "symbol";
                readonly type: "string";
            }, {
                readonly internalType: "contract IERC20";
                readonly name: "mainToken";
                readonly type: "address";
            }, {
                readonly internalType: "contract IERC20";
                readonly name: "wrappedToken";
                readonly type: "address";
            }, {
                readonly internalType: "address";
                readonly name: "assetManager";
                readonly type: "address";
            }, {
                readonly internalType: "uint256";
                readonly name: "upperTarget";
                readonly type: "uint256";
            }, {
                readonly internalType: "uint256";
                readonly name: "swapFeePercentage";
                readonly type: "uint256";
            }, {
                readonly internalType: "uint256";
                readonly name: "pauseWindowDuration";
                readonly type: "uint256";
            }, {
                readonly internalType: "uint256";
                readonly name: "bufferPeriodDuration";
                readonly type: "uint256";
            }, {
                readonly internalType: "address";
                readonly name: "owner";
                readonly type: "address";
            }, {
                readonly internalType: "string";
                readonly name: "version";
                readonly type: "string";
            }];
            readonly internalType: "struct AaveLinearPool.ConstructorArgs";
            readonly name: "args";
            readonly type: "tuple";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "constructor";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }, {
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "value";
            readonly type: "uint256";
        }];
        readonly name: "Approval";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "bool";
            readonly name: "paused";
            readonly type: "bool";
        }];
        readonly name: "PausedStateChanged";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "bool";
            readonly name: "enabled";
            readonly type: "bool";
        }];
        readonly name: "RecoveryModeStateChanged";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "swapFeePercentage";
            readonly type: "uint256";
        }];
        readonly name: "SwapFeePercentageChanged";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "contract IERC20";
            readonly name: "token";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "lowerTarget";
            readonly type: "uint256";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "upperTarget";
            readonly type: "uint256";
        }];
        readonly name: "TargetsSet";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "from";
            readonly type: "address";
        }, {
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "to";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "value";
            readonly type: "uint256";
        }];
        readonly name: "Transfer";
        readonly type: "event";
    }, {
        readonly inputs: readonly [];
        readonly name: "DOMAIN_SEPARATOR";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }];
        readonly name: "allowance";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "approve";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "account";
            readonly type: "address";
        }];
        readonly name: "balanceOf";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "decimals";
        readonly outputs: readonly [{
            readonly internalType: "uint8";
            readonly name: "";
            readonly type: "uint8";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "decreaseAllowance";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "disableRecoveryMode";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "enableRecoveryMode";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes4";
            readonly name: "selector";
            readonly type: "bytes4";
        }];
        readonly name: "getActionId";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getAuthorizer";
        readonly outputs: readonly [{
            readonly internalType: "contract IAuthorizer";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getBptIndex";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "pure";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getDomainSeparator";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getMainIndex";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getMainToken";
        readonly outputs: readonly [{
            readonly internalType: "contract IERC20";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "account";
            readonly type: "address";
        }];
        readonly name: "getNextNonce";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getOwner";
        readonly outputs: readonly [{
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getPausedState";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "paused";
            readonly type: "bool";
        }, {
            readonly internalType: "uint256";
            readonly name: "pauseWindowEndTime";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "bufferPeriodEndTime";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getPoolId";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getProtocolFeesCollector";
        readonly outputs: readonly [{
            readonly internalType: "contract IProtocolFeesCollector";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getRate";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getScalingFactors";
        readonly outputs: readonly [{
            readonly internalType: "uint256[]";
            readonly name: "";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getSwapFeePercentage";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getTargets";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "lowerTarget";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "upperTarget";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getVault";
        readonly outputs: readonly [{
            readonly internalType: "contract IVault";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getVirtualSupply";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getWrappedIndex";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getWrappedToken";
        readonly outputs: readonly [{
            readonly internalType: "contract IERC20";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getWrappedTokenRate";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "inRecoveryMode";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "addedValue";
            readonly type: "uint256";
        }];
        readonly name: "increaseAllowance";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "initialize";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "name";
        readonly outputs: readonly [{
            readonly internalType: "string";
            readonly name: "";
            readonly type: "string";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }];
        readonly name: "nonces";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "balances";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes";
            readonly name: "userData";
            readonly type: "bytes";
        }];
        readonly name: "onExitPool";
        readonly outputs: readonly [{
            readonly internalType: "uint256[]";
            readonly name: "amountsOut";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "dueProtocolFees";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "balances";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes";
            readonly name: "userData";
            readonly type: "bytes";
        }];
        readonly name: "onJoinPool";
        readonly outputs: readonly [{
            readonly internalType: "uint256[]";
            readonly name: "amountsIn";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "dueProtocolFees";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly components: readonly [{
                readonly internalType: "enum IVault.SwapKind";
                readonly name: "kind";
                readonly type: "uint8";
            }, {
                readonly internalType: "contract IERC20";
                readonly name: "tokenIn";
                readonly type: "address";
            }, {
                readonly internalType: "contract IERC20";
                readonly name: "tokenOut";
                readonly type: "address";
            }, {
                readonly internalType: "uint256";
                readonly name: "amount";
                readonly type: "uint256";
            }, {
                readonly internalType: "bytes32";
                readonly name: "poolId";
                readonly type: "bytes32";
            }, {
                readonly internalType: "uint256";
                readonly name: "lastChangeBlock";
                readonly type: "uint256";
            }, {
                readonly internalType: "address";
                readonly name: "from";
                readonly type: "address";
            }, {
                readonly internalType: "address";
                readonly name: "to";
                readonly type: "address";
            }, {
                readonly internalType: "bytes";
                readonly name: "userData";
                readonly type: "bytes";
            }];
            readonly internalType: "struct IPoolSwapStructs.SwapRequest";
            readonly name: "request";
            readonly type: "tuple";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "balances";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "indexIn";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "indexOut";
            readonly type: "uint256";
        }];
        readonly name: "onSwap";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly components: readonly [{
                readonly internalType: "enum IVault.SwapKind";
                readonly name: "kind";
                readonly type: "uint8";
            }, {
                readonly internalType: "contract IERC20";
                readonly name: "tokenIn";
                readonly type: "address";
            }, {
                readonly internalType: "contract IERC20";
                readonly name: "tokenOut";
                readonly type: "address";
            }, {
                readonly internalType: "uint256";
                readonly name: "amount";
                readonly type: "uint256";
            }, {
                readonly internalType: "bytes32";
                readonly name: "poolId";
                readonly type: "bytes32";
            }, {
                readonly internalType: "uint256";
                readonly name: "lastChangeBlock";
                readonly type: "uint256";
            }, {
                readonly internalType: "address";
                readonly name: "from";
                readonly type: "address";
            }, {
                readonly internalType: "address";
                readonly name: "to";
                readonly type: "address";
            }, {
                readonly internalType: "bytes";
                readonly name: "userData";
                readonly type: "bytes";
            }];
            readonly internalType: "struct IPoolSwapStructs.SwapRequest";
            readonly name: "request";
            readonly type: "tuple";
        }, {
            readonly internalType: "uint256";
            readonly name: "balanceTokenIn";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "balanceTokenOut";
            readonly type: "uint256";
        }];
        readonly name: "onSwap";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "pause";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "value";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "deadline";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint8";
            readonly name: "v";
            readonly type: "uint8";
        }, {
            readonly internalType: "bytes32";
            readonly name: "r";
            readonly type: "bytes32";
        }, {
            readonly internalType: "bytes32";
            readonly name: "s";
            readonly type: "bytes32";
        }];
        readonly name: "permit";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "balances";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes";
            readonly name: "userData";
            readonly type: "bytes";
        }];
        readonly name: "queryExit";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "bptIn";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "amountsOut";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "balances";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes";
            readonly name: "userData";
            readonly type: "bytes";
        }];
        readonly name: "queryJoin";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "bptOut";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "amountsIn";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "swapFeePercentage";
            readonly type: "uint256";
        }];
        readonly name: "setSwapFeePercentage";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "newLowerTarget";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "newUpperTarget";
            readonly type: "uint256";
        }];
        readonly name: "setTargets";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "symbol";
        readonly outputs: readonly [{
            readonly internalType: "string";
            readonly name: "";
            readonly type: "string";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "totalSupply";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "transfer";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "transferFrom";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "unpause";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "version";
        readonly outputs: readonly [{
            readonly internalType: "string";
            readonly name: "";
            readonly type: "string";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }];
    static createInterface(): AaveLinearPoolInterface;
    static connect(address: string, signerOrProvider: Signer | Provider): AaveLinearPool;
}

declare class AaveLinearPoolFactory__factory {
    static readonly abi: readonly [{
        readonly inputs: readonly [{
            readonly internalType: "contract IVault";
            readonly name: "vault";
            readonly type: "address";
        }, {
            readonly internalType: "contract IProtocolFeePercentagesProvider";
            readonly name: "protocolFeeProvider";
            readonly type: "address";
        }, {
            readonly internalType: "contract IBalancerQueries";
            readonly name: "queries";
            readonly type: "address";
        }, {
            readonly internalType: "string";
            readonly name: "factoryVersion";
            readonly type: "string";
        }, {
            readonly internalType: "string";
            readonly name: "poolVersion";
            readonly type: "string";
        }, {
            readonly internalType: "uint256";
            readonly name: "initialPauseWindowDuration";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "bufferPeriodDuration";
            readonly type: "uint256";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "constructor";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "pool";
            readonly type: "address";
        }, {
            readonly indexed: true;
            readonly internalType: "uint256";
            readonly name: "protocolId";
            readonly type: "uint256";
        }];
        readonly name: "AaveLinearPoolCreated";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [];
        readonly name: "FactoryDisabled";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "pool";
            readonly type: "address";
        }];
        readonly name: "PoolCreated";
        readonly type: "event";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "string";
            readonly name: "name";
            readonly type: "string";
        }, {
            readonly internalType: "string";
            readonly name: "symbol";
            readonly type: "string";
        }, {
            readonly internalType: "contract IERC20";
            readonly name: "mainToken";
            readonly type: "address";
        }, {
            readonly internalType: "contract IERC20";
            readonly name: "wrappedToken";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "upperTarget";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "swapFeePercentage";
            readonly type: "uint256";
        }, {
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "protocolId";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes32";
            readonly name: "salt";
            readonly type: "bytes32";
        }];
        readonly name: "create";
        readonly outputs: readonly [{
            readonly internalType: "contract AaveLinearPool";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "disable";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes4";
            readonly name: "selector";
            readonly type: "bytes4";
        }];
        readonly name: "getActionId";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getAuthorizer";
        readonly outputs: readonly [{
            readonly internalType: "contract IAuthorizer";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getCreationCode";
        readonly outputs: readonly [{
            readonly internalType: "bytes";
            readonly name: "";
            readonly type: "bytes";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getCreationCodeContracts";
        readonly outputs: readonly [{
            readonly internalType: "address";
            readonly name: "contractA";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "contractB";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getLastCreatedPool";
        readonly outputs: readonly [{
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getPauseConfiguration";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "pauseWindowDuration";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "bufferPeriodDuration";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getPoolVersion";
        readonly outputs: readonly [{
            readonly internalType: "string";
            readonly name: "";
            readonly type: "string";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getProtocolFeePercentagesProvider";
        readonly outputs: readonly [{
            readonly internalType: "contract IProtocolFeePercentagesProvider";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getVault";
        readonly outputs: readonly [{
            readonly internalType: "contract IVault";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "isDisabled";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "pool";
            readonly type: "address";
        }];
        readonly name: "isPoolFromFactory";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "version";
        readonly outputs: readonly [{
            readonly internalType: "string";
            readonly name: "";
            readonly type: "string";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }];
    static createInterface(): AaveLinearPoolFactoryInterface;
    static connect(address: string, signerOrProvider: Signer | Provider): AaveLinearPoolFactory;
}

declare class AaveWrapping__factory {
    static readonly abi: readonly [{
        readonly inputs: readonly [{
            readonly internalType: "contract IERC20";
            readonly name: "token";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "approveVault";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getVault";
        readonly outputs: readonly [{
            readonly internalType: "contract IVault";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "contract IStaticATokenLM";
            readonly name: "staticToken";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }, {
            readonly internalType: "bool";
            readonly name: "toUnderlying";
            readonly type: "bool";
        }, {
            readonly internalType: "uint256";
            readonly name: "outputReference";
            readonly type: "uint256";
        }];
        readonly name: "unwrapAaveStaticToken";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "contract IStaticATokenLM";
            readonly name: "staticToken";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }, {
            readonly internalType: "bool";
            readonly name: "fromUnderlying";
            readonly type: "bool";
        }, {
            readonly internalType: "uint256";
            readonly name: "outputReference";
            readonly type: "uint256";
        }];
        readonly name: "wrapAaveDynamicToken";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
        readonly type: "function";
    }];
    static createInterface(): AaveWrappingInterface;
    static connect(address: string, signerOrProvider: Signer | Provider): AaveWrapping;
}

declare class Authoriser__factory {
    static readonly abi: readonly [{
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "admin";
            readonly type: "address";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "constructor";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "bytes32";
            readonly name: "role";
            readonly type: "bytes32";
        }, {
            readonly indexed: true;
            readonly internalType: "bytes32";
            readonly name: "previousAdminRole";
            readonly type: "bytes32";
        }, {
            readonly indexed: true;
            readonly internalType: "bytes32";
            readonly name: "newAdminRole";
            readonly type: "bytes32";
        }];
        readonly name: "RoleAdminChanged";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "bytes32";
            readonly name: "role";
            readonly type: "bytes32";
        }, {
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "account";
            readonly type: "address";
        }, {
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }];
        readonly name: "RoleGranted";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "bytes32";
            readonly name: "role";
            readonly type: "bytes32";
        }, {
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "account";
            readonly type: "address";
        }, {
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }];
        readonly name: "RoleRevoked";
        readonly type: "event";
    }, {
        readonly inputs: readonly [];
        readonly name: "DEFAULT_ADMIN_ROLE";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "actionId";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "account";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }];
        readonly name: "canPerform";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "role";
            readonly type: "bytes32";
        }];
        readonly name: "getRoleAdmin";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "role";
            readonly type: "bytes32";
        }, {
            readonly internalType: "uint256";
            readonly name: "index";
            readonly type: "uint256";
        }];
        readonly name: "getRoleMember";
        readonly outputs: readonly [{
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "role";
            readonly type: "bytes32";
        }];
        readonly name: "getRoleMemberCount";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "role";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "account";
            readonly type: "address";
        }];
        readonly name: "grantRole";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32[]";
            readonly name: "roles";
            readonly type: "bytes32[]";
        }, {
            readonly internalType: "address";
            readonly name: "account";
            readonly type: "address";
        }];
        readonly name: "grantRoles";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32[]";
            readonly name: "roles";
            readonly type: "bytes32[]";
        }, {
            readonly internalType: "address[]";
            readonly name: "accounts";
            readonly type: "address[]";
        }];
        readonly name: "grantRolesToMany";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "role";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "account";
            readonly type: "address";
        }];
        readonly name: "hasRole";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "role";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "account";
            readonly type: "address";
        }];
        readonly name: "renounceRole";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "role";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "account";
            readonly type: "address";
        }];
        readonly name: "revokeRole";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32[]";
            readonly name: "roles";
            readonly type: "bytes32[]";
        }, {
            readonly internalType: "address";
            readonly name: "account";
            readonly type: "address";
        }];
        readonly name: "revokeRoles";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32[]";
            readonly name: "roles";
            readonly type: "bytes32[]";
        }, {
            readonly internalType: "address[]";
            readonly name: "accounts";
            readonly type: "address[]";
        }];
        readonly name: "revokeRolesFromMany";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }];
    static createInterface(): AuthoriserInterface;
    static connect(address: string, signerOrProvider: Signer | Provider): Authoriser;
}

declare class BalancerHelpers__factory {
    static readonly abi: readonly [{
        readonly inputs: readonly [{
            readonly internalType: "contract IVault";
            readonly name: "_vault";
            readonly type: "address";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "constructor";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly components: readonly [{
                readonly internalType: "contract IAsset[]";
                readonly name: "assets";
                readonly type: "address[]";
            }, {
                readonly internalType: "uint256[]";
                readonly name: "minAmountsOut";
                readonly type: "uint256[]";
            }, {
                readonly internalType: "bytes";
                readonly name: "userData";
                readonly type: "bytes";
            }, {
                readonly internalType: "bool";
                readonly name: "toInternalBalance";
                readonly type: "bool";
            }];
            readonly internalType: "struct IVault.ExitPoolRequest";
            readonly name: "request";
            readonly type: "tuple";
        }];
        readonly name: "queryExit";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "bptIn";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "amountsOut";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly components: readonly [{
                readonly internalType: "contract IAsset[]";
                readonly name: "assets";
                readonly type: "address[]";
            }, {
                readonly internalType: "uint256[]";
                readonly name: "maxAmountsIn";
                readonly type: "uint256[]";
            }, {
                readonly internalType: "bytes";
                readonly name: "userData";
                readonly type: "bytes";
            }, {
                readonly internalType: "bool";
                readonly name: "fromInternalBalance";
                readonly type: "bool";
            }];
            readonly internalType: "struct IVault.JoinPoolRequest";
            readonly name: "request";
            readonly type: "tuple";
        }];
        readonly name: "queryJoin";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "bptOut";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "amountsIn";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "vault";
        readonly outputs: readonly [{
            readonly internalType: "contract IVault";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }];
    static createInterface(): BalancerHelpersInterface;
    static connect(address: string, signerOrProvider: Signer | Provider): BalancerHelpers;
}

declare class BalancerMinter__factory {
    static readonly abi: readonly [{
        readonly inputs: readonly [{
            readonly internalType: "contract IBalancerTokenAdmin";
            readonly name: "tokenAdmin";
            readonly type: "address";
        }, {
            readonly internalType: "contract IGaugeController";
            readonly name: "gaugeController";
            readonly type: "address";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "constructor";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly internalType: "address";
            readonly name: "gauge";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "minted";
            readonly type: "uint256";
        }];
        readonly name: "Minted";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "user";
            readonly type: "address";
        }, {
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "minter";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly internalType: "bool";
            readonly name: "approval";
            readonly type: "bool";
        }];
        readonly name: "MinterApprovalSet";
        readonly type: "event";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "minter";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "user";
            readonly type: "address";
        }];
        readonly name: "allowed_to_mint_for";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getBalancerToken";
        readonly outputs: readonly [{
            readonly internalType: "contract IERC20";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getBalancerTokenAdmin";
        readonly outputs: readonly [{
            readonly internalType: "contract IBalancerTokenAdmin";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getDomainSeparator";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getGaugeController";
        readonly outputs: readonly [{
            readonly internalType: "contract IGaugeController";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "minter";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "user";
            readonly type: "address";
        }];
        readonly name: "getMinterApproval";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "user";
            readonly type: "address";
        }];
        readonly name: "getNextNonce";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "gauge";
            readonly type: "address";
        }];
        readonly name: "mint";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "gauge";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "user";
            readonly type: "address";
        }];
        readonly name: "mintFor";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address[]";
            readonly name: "gauges";
            readonly type: "address[]";
        }];
        readonly name: "mintMany";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address[]";
            readonly name: "gauges";
            readonly type: "address[]";
        }, {
            readonly internalType: "address";
            readonly name: "user";
            readonly type: "address";
        }];
        readonly name: "mintManyFor";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "gauge";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "user";
            readonly type: "address";
        }];
        readonly name: "mint_for";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address[8]";
            readonly name: "gauges";
            readonly type: "address[8]";
        }];
        readonly name: "mint_many";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "user";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "gauge";
            readonly type: "address";
        }];
        readonly name: "minted";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "minter";
            readonly type: "address";
        }, {
            readonly internalType: "bool";
            readonly name: "approval";
            readonly type: "bool";
        }];
        readonly name: "setMinterApproval";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "minter";
            readonly type: "address";
        }, {
            readonly internalType: "bool";
            readonly name: "approval";
            readonly type: "bool";
        }, {
            readonly internalType: "address";
            readonly name: "user";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "deadline";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint8";
            readonly name: "v";
            readonly type: "uint8";
        }, {
            readonly internalType: "bytes32";
            readonly name: "r";
            readonly type: "bytes32";
        }, {
            readonly internalType: "bytes32";
            readonly name: "s";
            readonly type: "bytes32";
        }];
        readonly name: "setMinterApprovalWithSignature";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "minter";
            readonly type: "address";
        }];
        readonly name: "toggle_approve_mint";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }];
    static createInterface(): BalancerMinterInterface;
    static connect(address: string, signerOrProvider: Signer | Provider): BalancerMinter;
}

declare class BalancerPoolDataQueries__factory {
    static readonly abi: readonly [{
        readonly inputs: readonly [{
            readonly internalType: "contract IVault";
            readonly name: "_vault";
            readonly type: "address";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "constructor";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address[]";
            readonly name: "poolAddresses";
            readonly type: "address[]";
        }];
        readonly name: "getAmpForPools";
        readonly outputs: readonly [{
            readonly internalType: "uint256[]";
            readonly name: "";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address[]";
            readonly name: "poolAddresses";
            readonly type: "address[]";
        }];
        readonly name: "getInRecoveryModeForPools";
        readonly outputs: readonly [{
            readonly internalType: "bool[]";
            readonly name: "";
            readonly type: "bool[]";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address[]";
            readonly name: "poolAddresses";
            readonly type: "address[]";
        }];
        readonly name: "getIsPausedForPools";
        readonly outputs: readonly [{
            readonly internalType: "bool[]";
            readonly name: "";
            readonly type: "bool[]";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address[]";
            readonly name: "poolAddresses";
            readonly type: "address[]";
        }];
        readonly name: "getLinearTargetsForPools";
        readonly outputs: readonly [{
            readonly internalType: "uint256[][]";
            readonly name: "";
            readonly type: "uint256[][]";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address[]";
            readonly name: "poolAddresses";
            readonly type: "address[]";
        }];
        readonly name: "getNormalizedWeightsForPools";
        readonly outputs: readonly [{
            readonly internalType: "uint256[][]";
            readonly name: "";
            readonly type: "uint256[][]";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32[]";
            readonly name: "poolIds";
            readonly type: "bytes32[]";
        }, {
            readonly components: readonly [{
                readonly internalType: "bool";
                readonly name: "loadTokenBalanceUpdatesAfterBlock";
                readonly type: "bool";
            }, {
                readonly internalType: "bool";
                readonly name: "loadTotalSupply";
                readonly type: "bool";
            }, {
                readonly internalType: "bool";
                readonly name: "loadSwapFees";
                readonly type: "bool";
            }, {
                readonly internalType: "bool";
                readonly name: "loadLinearWrappedTokenRates";
                readonly type: "bool";
            }, {
                readonly internalType: "bool";
                readonly name: "loadLinearTargets";
                readonly type: "bool";
            }, {
                readonly internalType: "bool";
                readonly name: "loadNormalizedWeights";
                readonly type: "bool";
            }, {
                readonly internalType: "bool";
                readonly name: "loadScalingFactors";
                readonly type: "bool";
            }, {
                readonly internalType: "bool";
                readonly name: "loadAmps";
                readonly type: "bool";
            }, {
                readonly internalType: "bool";
                readonly name: "loadRates";
                readonly type: "bool";
            }, {
                readonly internalType: "uint256";
                readonly name: "blockNumber";
                readonly type: "uint256";
            }, {
                readonly internalType: "enum TotalSupplyType[]";
                readonly name: "totalSupplyTypes";
                readonly type: "uint8[]";
            }, {
                readonly internalType: "enum SwapFeeType[]";
                readonly name: "swapFeeTypes";
                readonly type: "uint8[]";
            }, {
                readonly internalType: "uint256[]";
                readonly name: "linearPoolIdxs";
                readonly type: "uint256[]";
            }, {
                readonly internalType: "uint256[]";
                readonly name: "weightedPoolIdxs";
                readonly type: "uint256[]";
            }, {
                readonly internalType: "uint256[]";
                readonly name: "scalingFactorPoolIdxs";
                readonly type: "uint256[]";
            }, {
                readonly internalType: "uint256[]";
                readonly name: "ampPoolIdxs";
                readonly type: "uint256[]";
            }, {
                readonly internalType: "uint256[]";
                readonly name: "ratePoolIdxs";
                readonly type: "uint256[]";
            }];
            readonly internalType: "struct PoolDataQueryConfig";
            readonly name: "config";
            readonly type: "tuple";
        }];
        readonly name: "getPoolData";
        readonly outputs: readonly [{
            readonly internalType: "uint256[][]";
            readonly name: "balances";
            readonly type: "uint256[][]";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "totalSupplies";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "swapFees";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "linearWrappedTokenRates";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256[][]";
            readonly name: "linearTargets";
            readonly type: "uint256[][]";
        }, {
            readonly internalType: "uint256[][]";
            readonly name: "weights";
            readonly type: "uint256[][]";
        }, {
            readonly internalType: "uint256[][]";
            readonly name: "scalingFactors";
            readonly type: "uint256[][]";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "amps";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "rates";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "ignoreIdxs";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32[]";
            readonly name: "poolIds";
            readonly type: "bytes32[]";
        }, {
            readonly components: readonly [{
                readonly internalType: "bool";
                readonly name: "loadInRecoveryMode";
                readonly type: "bool";
            }, {
                readonly internalType: "bool";
                readonly name: "loadIsPaused";
                readonly type: "bool";
            }];
            readonly internalType: "struct PoolStatusQueryConfig";
            readonly name: "config";
            readonly type: "tuple";
        }];
        readonly name: "getPoolStatus";
        readonly outputs: readonly [{
            readonly internalType: "bool[]";
            readonly name: "isPaused";
            readonly type: "bool[]";
        }, {
            readonly internalType: "bool[]";
            readonly name: "inRecoveryMode";
            readonly type: "bool[]";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32[]";
            readonly name: "poolIds";
            readonly type: "bytes32[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "blockNumber";
            readonly type: "uint256";
        }];
        readonly name: "getPoolTokenBalancesWithUpdatesAfterBlock";
        readonly outputs: readonly [{
            readonly internalType: "uint256[][]";
            readonly name: "";
            readonly type: "uint256[][]";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address[]";
            readonly name: "poolAddresses";
            readonly type: "address[]";
        }];
        readonly name: "getRateForPools";
        readonly outputs: readonly [{
            readonly internalType: "uint256[]";
            readonly name: "";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address[]";
            readonly name: "poolAddresses";
            readonly type: "address[]";
        }];
        readonly name: "getScalingFactorsForPools";
        readonly outputs: readonly [{
            readonly internalType: "uint256[][]";
            readonly name: "";
            readonly type: "uint256[][]";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address[]";
            readonly name: "poolAddresses";
            readonly type: "address[]";
        }, {
            readonly internalType: "enum SwapFeeType[]";
            readonly name: "swapFeeTypes";
            readonly type: "uint8[]";
        }];
        readonly name: "getSwapFeePercentageForPools";
        readonly outputs: readonly [{
            readonly internalType: "uint256[]";
            readonly name: "";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address[]";
            readonly name: "poolAddresses";
            readonly type: "address[]";
        }, {
            readonly internalType: "enum TotalSupplyType[]";
            readonly name: "totalSupplyTypes";
            readonly type: "uint8[]";
        }];
        readonly name: "getTotalSupplyForPools";
        readonly outputs: readonly [{
            readonly internalType: "uint256[]";
            readonly name: "";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address[]";
            readonly name: "poolAddresses";
            readonly type: "address[]";
        }];
        readonly name: "getWrappedTokenRateForLinearPools";
        readonly outputs: readonly [{
            readonly internalType: "uint256[]";
            readonly name: "";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "vault";
        readonly outputs: readonly [{
            readonly internalType: "contract IVault";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }];
    static createInterface(): BalancerPoolDataQueriesInterface;
    static connect(address: string, signerOrProvider: Signer | Provider): BalancerPoolDataQueries;
}

declare class BalancerRelayer__factory {
    static readonly abi: readonly [{
        readonly inputs: readonly [{
            readonly internalType: "contract IVault";
            readonly name: "vault";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "libraryAddress";
            readonly type: "address";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "constructor";
    }, {
        readonly inputs: readonly [];
        readonly name: "getLibrary";
        readonly outputs: readonly [{
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getVault";
        readonly outputs: readonly [{
            readonly internalType: "contract IVault";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes[]";
            readonly name: "data";
            readonly type: "bytes[]";
        }];
        readonly name: "multicall";
        readonly outputs: readonly [{
            readonly internalType: "bytes[]";
            readonly name: "results";
            readonly type: "bytes[]";
        }];
        readonly stateMutability: "payable";
        readonly type: "function";
    }, {
        readonly stateMutability: "payable";
        readonly type: "receive";
    }];
    static createInterface(): BalancerRelayerInterface;
    static connect(address: string, signerOrProvider: Signer | Provider): BalancerRelayer;
}

declare class BatchRelayerLibrary__factory {
    static readonly abi: readonly [{
        readonly inputs: readonly [{
            readonly internalType: "contract IVault";
            readonly name: "vault";
            readonly type: "address";
        }, {
            readonly internalType: "contract IERC20";
            readonly name: "wstETH";
            readonly type: "address";
        }, {
            readonly internalType: "contract IBalancerMinter";
            readonly name: "minter";
            readonly type: "address";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "constructor";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "contract IERC20";
            readonly name: "token";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "approveVault";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "enum IVault.SwapKind";
            readonly name: "kind";
            readonly type: "uint8";
        }, {
            readonly components: readonly [{
                readonly internalType: "bytes32";
                readonly name: "poolId";
                readonly type: "bytes32";
            }, {
                readonly internalType: "uint256";
                readonly name: "assetInIndex";
                readonly type: "uint256";
            }, {
                readonly internalType: "uint256";
                readonly name: "assetOutIndex";
                readonly type: "uint256";
            }, {
                readonly internalType: "uint256";
                readonly name: "amount";
                readonly type: "uint256";
            }, {
                readonly internalType: "bytes";
                readonly name: "userData";
                readonly type: "bytes";
            }];
            readonly internalType: "struct IVault.BatchSwapStep[]";
            readonly name: "swaps";
            readonly type: "tuple[]";
        }, {
            readonly internalType: "contract IAsset[]";
            readonly name: "assets";
            readonly type: "address[]";
        }, {
            readonly components: readonly [{
                readonly internalType: "address";
                readonly name: "sender";
                readonly type: "address";
            }, {
                readonly internalType: "bool";
                readonly name: "fromInternalBalance";
                readonly type: "bool";
            }, {
                readonly internalType: "address payable";
                readonly name: "recipient";
                readonly type: "address";
            }, {
                readonly internalType: "bool";
                readonly name: "toInternalBalance";
                readonly type: "bool";
            }];
            readonly internalType: "struct IVault.FundManagement";
            readonly name: "funds";
            readonly type: "tuple";
        }, {
            readonly internalType: "int256[]";
            readonly name: "limits";
            readonly type: "int256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "deadline";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "value";
            readonly type: "uint256";
        }, {
            readonly components: readonly [{
                readonly internalType: "uint256";
                readonly name: "index";
                readonly type: "uint256";
            }, {
                readonly internalType: "uint256";
                readonly name: "key";
                readonly type: "uint256";
            }];
            readonly internalType: "struct VaultActions.OutputReference[]";
            readonly name: "outputReferences";
            readonly type: "tuple[]";
        }];
        readonly name: "batchSwap";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly internalType: "enum VaultActions.PoolKind";
            readonly name: "kind";
            readonly type: "uint8";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address payable";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly components: readonly [{
                readonly internalType: "contract IAsset[]";
                readonly name: "assets";
                readonly type: "address[]";
            }, {
                readonly internalType: "uint256[]";
                readonly name: "minAmountsOut";
                readonly type: "uint256[]";
            }, {
                readonly internalType: "bytes";
                readonly name: "userData";
                readonly type: "bytes";
            }, {
                readonly internalType: "bool";
                readonly name: "toInternalBalance";
                readonly type: "bool";
            }];
            readonly internalType: "struct IVault.ExitPoolRequest";
            readonly name: "request";
            readonly type: "tuple";
        }, {
            readonly components: readonly [{
                readonly internalType: "uint256";
                readonly name: "index";
                readonly type: "uint256";
            }, {
                readonly internalType: "uint256";
                readonly name: "key";
                readonly type: "uint256";
            }];
            readonly internalType: "struct VaultActions.OutputReference[]";
            readonly name: "outputReferences";
            readonly type: "tuple[]";
        }];
        readonly name: "exitPool";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "contract IStakingLiquidityGauge[]";
            readonly name: "gauges";
            readonly type: "address[]";
        }];
        readonly name: "gaugeClaimRewards";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "contract IStakingLiquidityGauge";
            readonly name: "gauge";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "gaugeDeposit";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address[]";
            readonly name: "gauges";
            readonly type: "address[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "outputReference";
            readonly type: "uint256";
        }];
        readonly name: "gaugeMint";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bool";
            readonly name: "approval";
            readonly type: "bool";
        }, {
            readonly internalType: "address";
            readonly name: "user";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "deadline";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint8";
            readonly name: "v";
            readonly type: "uint8";
        }, {
            readonly internalType: "bytes32";
            readonly name: "r";
            readonly type: "bytes32";
        }, {
            readonly internalType: "bytes32";
            readonly name: "s";
            readonly type: "bytes32";
        }];
        readonly name: "gaugeSetMinterApproval";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "contract IStakingLiquidityGauge";
            readonly name: "gauge";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "gaugeWithdraw";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getEntrypoint";
        readonly outputs: readonly [{
            readonly internalType: "contract IBalancerRelayer";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getVault";
        readonly outputs: readonly [{
            readonly internalType: "contract IVault";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly internalType: "enum VaultActions.PoolKind";
            readonly name: "kind";
            readonly type: "uint8";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly components: readonly [{
                readonly internalType: "contract IAsset[]";
                readonly name: "assets";
                readonly type: "address[]";
            }, {
                readonly internalType: "uint256[]";
                readonly name: "maxAmountsIn";
                readonly type: "uint256[]";
            }, {
                readonly internalType: "bytes";
                readonly name: "userData";
                readonly type: "bytes";
            }, {
                readonly internalType: "bool";
                readonly name: "fromInternalBalance";
                readonly type: "bool";
            }];
            readonly internalType: "struct IVault.JoinPoolRequest";
            readonly name: "request";
            readonly type: "tuple";
        }, {
            readonly internalType: "uint256";
            readonly name: "value";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "outputReference";
            readonly type: "uint256";
        }];
        readonly name: "joinPool";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly components: readonly [{
                readonly internalType: "enum IVault.UserBalanceOpKind";
                readonly name: "kind";
                readonly type: "uint8";
            }, {
                readonly internalType: "contract IAsset";
                readonly name: "asset";
                readonly type: "address";
            }, {
                readonly internalType: "uint256";
                readonly name: "amount";
                readonly type: "uint256";
            }, {
                readonly internalType: "address";
                readonly name: "sender";
                readonly type: "address";
            }, {
                readonly internalType: "address payable";
                readonly name: "recipient";
                readonly type: "address";
            }];
            readonly internalType: "struct IVault.UserBalanceOp[]";
            readonly name: "ops";
            readonly type: "tuple[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "value";
            readonly type: "uint256";
        }];
        readonly name: "manageUserBalance";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "ref";
            readonly type: "uint256";
        }];
        readonly name: "peekChainedReferenceValue";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "value";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "relayer";
            readonly type: "address";
        }, {
            readonly internalType: "bool";
            readonly name: "approved";
            readonly type: "bool";
        }, {
            readonly internalType: "bytes";
            readonly name: "authorisation";
            readonly type: "bytes";
        }];
        readonly name: "setRelayerApproval";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "outputReference";
            readonly type: "uint256";
        }];
        readonly name: "stakeETH";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "outputReference";
            readonly type: "uint256";
        }];
        readonly name: "stakeETHAndWrap";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly components: readonly [{
                readonly internalType: "bytes32";
                readonly name: "poolId";
                readonly type: "bytes32";
            }, {
                readonly internalType: "enum IVault.SwapKind";
                readonly name: "kind";
                readonly type: "uint8";
            }, {
                readonly internalType: "contract IAsset";
                readonly name: "assetIn";
                readonly type: "address";
            }, {
                readonly internalType: "contract IAsset";
                readonly name: "assetOut";
                readonly type: "address";
            }, {
                readonly internalType: "uint256";
                readonly name: "amount";
                readonly type: "uint256";
            }, {
                readonly internalType: "bytes";
                readonly name: "userData";
                readonly type: "bytes";
            }];
            readonly internalType: "struct IVault.SingleSwap";
            readonly name: "singleSwap";
            readonly type: "tuple";
        }, {
            readonly components: readonly [{
                readonly internalType: "address";
                readonly name: "sender";
                readonly type: "address";
            }, {
                readonly internalType: "bool";
                readonly name: "fromInternalBalance";
                readonly type: "bool";
            }, {
                readonly internalType: "address payable";
                readonly name: "recipient";
                readonly type: "address";
            }, {
                readonly internalType: "bool";
                readonly name: "toInternalBalance";
                readonly type: "bool";
            }];
            readonly internalType: "struct IVault.FundManagement";
            readonly name: "funds";
            readonly type: "tuple";
        }, {
            readonly internalType: "uint256";
            readonly name: "limit";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "deadline";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "value";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "outputReference";
            readonly type: "uint256";
        }];
        readonly name: "swap";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "contract IStaticATokenLM";
            readonly name: "staticToken";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }, {
            readonly internalType: "bool";
            readonly name: "toUnderlying";
            readonly type: "bool";
        }, {
            readonly internalType: "uint256";
            readonly name: "outputReference";
            readonly type: "uint256";
        }];
        readonly name: "unwrapAaveStaticToken";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "contract ICToken";
            readonly name: "wrappedToken";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "outputReference";
            readonly type: "uint256";
        }];
        readonly name: "unwrapCompoundV2";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "contract IERC4626";
            readonly name: "wrappedToken";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "outputReference";
            readonly type: "uint256";
        }];
        readonly name: "unwrapERC4626";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "contract IEulerToken";
            readonly name: "wrappedToken";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "outputReference";
            readonly type: "uint256";
        }];
        readonly name: "unwrapEuler";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "contract IGearboxDieselToken";
            readonly name: "wrappedToken";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "dieselAmount";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "outputReference";
            readonly type: "uint256";
        }];
        readonly name: "unwrapGearbox";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "contract IReaperTokenVault";
            readonly name: "vaultToken";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "outputReference";
            readonly type: "uint256";
        }];
        readonly name: "unwrapReaperVaultToken";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "contract IShareToken";
            readonly name: "wrappedToken";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "outputReference";
            readonly type: "uint256";
        }];
        readonly name: "unwrapShareToken";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "contract ITetuSmartVault";
            readonly name: "wrappedToken";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "outputReference";
            readonly type: "uint256";
        }];
        readonly name: "unwrapTetu";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "contract IUnbuttonToken";
            readonly name: "wrapperToken";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "outputReference";
            readonly type: "uint256";
        }];
        readonly name: "unwrapUnbuttonToken";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "outputReference";
            readonly type: "uint256";
        }];
        readonly name: "unwrapWstETH";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "contract IYearnTokenVault";
            readonly name: "wrappedToken";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "outputReference";
            readonly type: "uint256";
        }];
        readonly name: "unwrapYearn";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "contract IERC20Permit";
            readonly name: "token";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "value";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "deadline";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint8";
            readonly name: "v";
            readonly type: "uint8";
        }, {
            readonly internalType: "bytes32";
            readonly name: "r";
            readonly type: "bytes32";
        }, {
            readonly internalType: "bytes32";
            readonly name: "s";
            readonly type: "bytes32";
        }];
        readonly name: "vaultPermit";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "contract IERC20PermitDAI";
            readonly name: "token";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "holder";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "nonce";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "expiry";
            readonly type: "uint256";
        }, {
            readonly internalType: "bool";
            readonly name: "allowed";
            readonly type: "bool";
        }, {
            readonly internalType: "uint8";
            readonly name: "v";
            readonly type: "uint8";
        }, {
            readonly internalType: "bytes32";
            readonly name: "r";
            readonly type: "bytes32";
        }, {
            readonly internalType: "bytes32";
            readonly name: "s";
            readonly type: "bytes32";
        }];
        readonly name: "vaultPermitDAI";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "contract IStaticATokenLM";
            readonly name: "staticToken";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }, {
            readonly internalType: "bool";
            readonly name: "fromUnderlying";
            readonly type: "bool";
        }, {
            readonly internalType: "uint256";
            readonly name: "outputReference";
            readonly type: "uint256";
        }];
        readonly name: "wrapAaveDynamicToken";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "contract ICToken";
            readonly name: "wrappedToken";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "outputReference";
            readonly type: "uint256";
        }];
        readonly name: "wrapCompoundV2";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "contract IERC4626";
            readonly name: "wrappedToken";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "outputReference";
            readonly type: "uint256";
        }];
        readonly name: "wrapERC4626";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "contract IEulerToken";
            readonly name: "wrappedToken";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "eulerProtocol";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "outputReference";
            readonly type: "uint256";
        }];
        readonly name: "wrapEuler";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "contract IGearboxDieselToken";
            readonly name: "wrappedToken";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "mainAmount";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "outputReference";
            readonly type: "uint256";
        }];
        readonly name: "wrapGearbox";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "contract IReaperTokenVault";
            readonly name: "vaultToken";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "outputReference";
            readonly type: "uint256";
        }];
        readonly name: "wrapReaperVaultToken";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "contract IShareToken";
            readonly name: "wrappedToken";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "outputReference";
            readonly type: "uint256";
        }];
        readonly name: "wrapShareToken";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "outputReference";
            readonly type: "uint256";
        }];
        readonly name: "wrapStETH";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "contract ITetuSmartVault";
            readonly name: "wrappedToken";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "outputReference";
            readonly type: "uint256";
        }];
        readonly name: "wrapTetu";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "contract IUnbuttonToken";
            readonly name: "wrapperToken";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "uAmount";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "outputReference";
            readonly type: "uint256";
        }];
        readonly name: "wrapUnbuttonToken";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "contract IYearnTokenVault";
            readonly name: "wrappedToken";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "outputReference";
            readonly type: "uint256";
        }];
        readonly name: "wrapYearn";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
        readonly type: "function";
    }];
    static createInterface(): BatchRelayerLibraryInterface;
    static connect(address: string, signerOrProvider: Signer | Provider): BatchRelayerLibrary;
}

declare class ComposableStablePool__factory {
    static readonly abi: readonly [{
        readonly inputs: readonly [{
            readonly components: readonly [{
                readonly internalType: "contract IVault";
                readonly name: "vault";
                readonly type: "address";
            }, {
                readonly internalType: "contract IProtocolFeePercentagesProvider";
                readonly name: "protocolFeeProvider";
                readonly type: "address";
            }, {
                readonly internalType: "string";
                readonly name: "name";
                readonly type: "string";
            }, {
                readonly internalType: "string";
                readonly name: "symbol";
                readonly type: "string";
            }, {
                readonly internalType: "contract IERC20[]";
                readonly name: "tokens";
                readonly type: "address[]";
            }, {
                readonly internalType: "contract IRateProvider[]";
                readonly name: "rateProviders";
                readonly type: "address[]";
            }, {
                readonly internalType: "uint256[]";
                readonly name: "tokenRateCacheDurations";
                readonly type: "uint256[]";
            }, {
                readonly internalType: "bool[]";
                readonly name: "exemptFromYieldProtocolFeeFlags";
                readonly type: "bool[]";
            }, {
                readonly internalType: "uint256";
                readonly name: "amplificationParameter";
                readonly type: "uint256";
            }, {
                readonly internalType: "uint256";
                readonly name: "swapFeePercentage";
                readonly type: "uint256";
            }, {
                readonly internalType: "uint256";
                readonly name: "pauseWindowDuration";
                readonly type: "uint256";
            }, {
                readonly internalType: "uint256";
                readonly name: "bufferPeriodDuration";
                readonly type: "uint256";
            }, {
                readonly internalType: "address";
                readonly name: "owner";
                readonly type: "address";
            }];
            readonly internalType: "struct ComposableStablePool.NewPoolParams";
            readonly name: "params";
            readonly type: "tuple";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "constructor";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "startValue";
            readonly type: "uint256";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "endValue";
            readonly type: "uint256";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "startTime";
            readonly type: "uint256";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "endTime";
            readonly type: "uint256";
        }];
        readonly name: "AmpUpdateStarted";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "currentValue";
            readonly type: "uint256";
        }];
        readonly name: "AmpUpdateStopped";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }, {
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "value";
            readonly type: "uint256";
        }];
        readonly name: "Approval";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "bool";
            readonly name: "paused";
            readonly type: "bool";
        }];
        readonly name: "PausedStateChanged";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "uint256";
            readonly name: "feeType";
            readonly type: "uint256";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "protocolFeePercentage";
            readonly type: "uint256";
        }];
        readonly name: "ProtocolFeePercentageCacheUpdated";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "bool";
            readonly name: "enabled";
            readonly type: "bool";
        }];
        readonly name: "RecoveryModeStateChanged";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "swapFeePercentage";
            readonly type: "uint256";
        }];
        readonly name: "SwapFeePercentageChanged";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "uint256";
            readonly name: "tokenIndex";
            readonly type: "uint256";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "rate";
            readonly type: "uint256";
        }];
        readonly name: "TokenRateCacheUpdated";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "uint256";
            readonly name: "tokenIndex";
            readonly type: "uint256";
        }, {
            readonly indexed: true;
            readonly internalType: "contract IRateProvider";
            readonly name: "provider";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "cacheDuration";
            readonly type: "uint256";
        }];
        readonly name: "TokenRateProviderSet";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "from";
            readonly type: "address";
        }, {
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "to";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "value";
            readonly type: "uint256";
        }];
        readonly name: "Transfer";
        readonly type: "event";
    }, {
        readonly inputs: readonly [];
        readonly name: "DELEGATE_PROTOCOL_SWAP_FEES_SENTINEL";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "DOMAIN_SEPARATOR";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }];
        readonly name: "allowance";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "approve";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "account";
            readonly type: "address";
        }];
        readonly name: "balanceOf";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "decimals";
        readonly outputs: readonly [{
            readonly internalType: "uint8";
            readonly name: "";
            readonly type: "uint8";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "decreaseAllowance";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "disableRecoveryMode";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "enableRecoveryMode";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes4";
            readonly name: "selector";
            readonly type: "bytes4";
        }];
        readonly name: "getActionId";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getActualSupply";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getAmplificationParameter";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "value";
            readonly type: "uint256";
        }, {
            readonly internalType: "bool";
            readonly name: "isUpdating";
            readonly type: "bool";
        }, {
            readonly internalType: "uint256";
            readonly name: "precision";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getAuthorizer";
        readonly outputs: readonly [{
            readonly internalType: "contract IAuthorizer";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getBptIndex";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getDomainSeparator";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getLastJoinExitData";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "lastJoinExitAmplification";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "lastPostJoinExitInvariant";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getMinimumBpt";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "pure";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "account";
            readonly type: "address";
        }];
        readonly name: "getNextNonce";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getOwner";
        readonly outputs: readonly [{
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getPausedState";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "paused";
            readonly type: "bool";
        }, {
            readonly internalType: "uint256";
            readonly name: "pauseWindowEndTime";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "bufferPeriodEndTime";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getPoolId";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "feeType";
            readonly type: "uint256";
        }];
        readonly name: "getProtocolFeePercentageCache";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getProtocolFeesCollector";
        readonly outputs: readonly [{
            readonly internalType: "contract IProtocolFeesCollector";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getProtocolSwapFeeDelegation";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getRate";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getRateProviders";
        readonly outputs: readonly [{
            readonly internalType: "contract IRateProvider[]";
            readonly name: "";
            readonly type: "address[]";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getScalingFactors";
        readonly outputs: readonly [{
            readonly internalType: "uint256[]";
            readonly name: "";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getSwapFeePercentage";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "contract IERC20";
            readonly name: "token";
            readonly type: "address";
        }];
        readonly name: "getTokenRate";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "contract IERC20";
            readonly name: "token";
            readonly type: "address";
        }];
        readonly name: "getTokenRateCache";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "rate";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "oldRate";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "duration";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "expires";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getVault";
        readonly outputs: readonly [{
            readonly internalType: "contract IVault";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "inRecoveryMode";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "addedValue";
            readonly type: "uint256";
        }];
        readonly name: "increaseAllowance";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "contract IERC20";
            readonly name: "token";
            readonly type: "address";
        }];
        readonly name: "isTokenExemptFromYieldProtocolFee";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "name";
        readonly outputs: readonly [{
            readonly internalType: "string";
            readonly name: "";
            readonly type: "string";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }];
        readonly name: "nonces";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "balances";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "lastChangeBlock";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "protocolSwapFeePercentage";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes";
            readonly name: "userData";
            readonly type: "bytes";
        }];
        readonly name: "onExitPool";
        readonly outputs: readonly [{
            readonly internalType: "uint256[]";
            readonly name: "";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "balances";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "lastChangeBlock";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "protocolSwapFeePercentage";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes";
            readonly name: "userData";
            readonly type: "bytes";
        }];
        readonly name: "onJoinPool";
        readonly outputs: readonly [{
            readonly internalType: "uint256[]";
            readonly name: "";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly components: readonly [{
                readonly internalType: "enum IVault.SwapKind";
                readonly name: "kind";
                readonly type: "uint8";
            }, {
                readonly internalType: "contract IERC20";
                readonly name: "tokenIn";
                readonly type: "address";
            }, {
                readonly internalType: "contract IERC20";
                readonly name: "tokenOut";
                readonly type: "address";
            }, {
                readonly internalType: "uint256";
                readonly name: "amount";
                readonly type: "uint256";
            }, {
                readonly internalType: "bytes32";
                readonly name: "poolId";
                readonly type: "bytes32";
            }, {
                readonly internalType: "uint256";
                readonly name: "lastChangeBlock";
                readonly type: "uint256";
            }, {
                readonly internalType: "address";
                readonly name: "from";
                readonly type: "address";
            }, {
                readonly internalType: "address";
                readonly name: "to";
                readonly type: "address";
            }, {
                readonly internalType: "bytes";
                readonly name: "userData";
                readonly type: "bytes";
            }];
            readonly internalType: "struct IPoolSwapStructs.SwapRequest";
            readonly name: "swapRequest";
            readonly type: "tuple";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "balances";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "indexIn";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "indexOut";
            readonly type: "uint256";
        }];
        readonly name: "onSwap";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "pause";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "value";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "deadline";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint8";
            readonly name: "v";
            readonly type: "uint8";
        }, {
            readonly internalType: "bytes32";
            readonly name: "r";
            readonly type: "bytes32";
        }, {
            readonly internalType: "bytes32";
            readonly name: "s";
            readonly type: "bytes32";
        }];
        readonly name: "permit";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "balances";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "lastChangeBlock";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "protocolSwapFeePercentage";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes";
            readonly name: "userData";
            readonly type: "bytes";
        }];
        readonly name: "queryExit";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "bptIn";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "amountsOut";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "balances";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "lastChangeBlock";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "protocolSwapFeePercentage";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes";
            readonly name: "userData";
            readonly type: "bytes";
        }];
        readonly name: "queryJoin";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "bptOut";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "amountsIn";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "contract IERC20";
            readonly name: "token";
            readonly type: "address";
        }, {
            readonly internalType: "bytes";
            readonly name: "poolConfig";
            readonly type: "bytes";
        }];
        readonly name: "setAssetManagerPoolConfig";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "swapFeePercentage";
            readonly type: "uint256";
        }];
        readonly name: "setSwapFeePercentage";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "contract IERC20";
            readonly name: "token";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "duration";
            readonly type: "uint256";
        }];
        readonly name: "setTokenRateCacheDuration";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "rawEndValue";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "endTime";
            readonly type: "uint256";
        }];
        readonly name: "startAmplificationParameterUpdate";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "stopAmplificationParameterUpdate";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "symbol";
        readonly outputs: readonly [{
            readonly internalType: "string";
            readonly name: "";
            readonly type: "string";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "totalSupply";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "transfer";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "transferFrom";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "unpause";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "updateProtocolFeePercentageCache";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "contract IERC20";
            readonly name: "token";
            readonly type: "address";
        }];
        readonly name: "updateTokenRateCache";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }];
    static createInterface(): ComposableStablePoolInterface;
    static connect(address: string, signerOrProvider: Signer | Provider): ComposableStablePool;
}

declare class ComposableStablePoolFactory__factory {
    static readonly abi: readonly [{
        readonly inputs: readonly [{
            readonly internalType: "contract IVault";
            readonly name: "vault";
            readonly type: "address";
        }, {
            readonly internalType: "contract IProtocolFeePercentagesProvider";
            readonly name: "protocolFeeProvider";
            readonly type: "address";
        }, {
            readonly internalType: "string";
            readonly name: "factoryVersion";
            readonly type: "string";
        }, {
            readonly internalType: "string";
            readonly name: "poolVersion";
            readonly type: "string";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "constructor";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [];
        readonly name: "FactoryDisabled";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "pool";
            readonly type: "address";
        }];
        readonly name: "PoolCreated";
        readonly type: "event";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "string";
            readonly name: "name";
            readonly type: "string";
        }, {
            readonly internalType: "string";
            readonly name: "symbol";
            readonly type: "string";
        }, {
            readonly internalType: "contract IERC20[]";
            readonly name: "tokens";
            readonly type: "address[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "amplificationParameter";
            readonly type: "uint256";
        }, {
            readonly internalType: "contract IRateProvider[]";
            readonly name: "rateProviders";
            readonly type: "address[]";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "tokenRateCacheDurations";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "bool[]";
            readonly name: "exemptFromYieldProtocolFeeFlags";
            readonly type: "bool[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "swapFeePercentage";
            readonly type: "uint256";
        }, {
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }, {
            readonly internalType: "bytes32";
            readonly name: "salt";
            readonly type: "bytes32";
        }];
        readonly name: "create";
        readonly outputs: readonly [{
            readonly internalType: "contract ComposableStablePool";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "disable";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes4";
            readonly name: "selector";
            readonly type: "bytes4";
        }];
        readonly name: "getActionId";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getAuthorizer";
        readonly outputs: readonly [{
            readonly internalType: "contract IAuthorizer";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getCreationCode";
        readonly outputs: readonly [{
            readonly internalType: "bytes";
            readonly name: "";
            readonly type: "bytes";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getCreationCodeContracts";
        readonly outputs: readonly [{
            readonly internalType: "address";
            readonly name: "contractA";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "contractB";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getPauseConfiguration";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "pauseWindowDuration";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "bufferPeriodDuration";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getPoolVersion";
        readonly outputs: readonly [{
            readonly internalType: "string";
            readonly name: "";
            readonly type: "string";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getProtocolFeePercentagesProvider";
        readonly outputs: readonly [{
            readonly internalType: "contract IProtocolFeePercentagesProvider";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getVault";
        readonly outputs: readonly [{
            readonly internalType: "contract IVault";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "isDisabled";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "pool";
            readonly type: "address";
        }];
        readonly name: "isPoolFromFactory";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "version";
        readonly outputs: readonly [{
            readonly internalType: "string";
            readonly name: "";
            readonly type: "string";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }];
    static createInterface(): ComposableStablePoolFactoryInterface;
    static connect(address: string, signerOrProvider: Signer | Provider): ComposableStablePoolFactory;
}

declare class ConvergentCurvePool__factory {
    static readonly abi: readonly [{
        readonly inputs: readonly [{
            readonly internalType: "contract IERC20";
            readonly name: "_underlying";
            readonly type: "address";
        }, {
            readonly internalType: "contract IERC20";
            readonly name: "_bond";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "_expiration";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "_unitSeconds";
            readonly type: "uint256";
        }, {
            readonly internalType: "contract IVault";
            readonly name: "vault";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "_percentFee";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "_percentFeeGov";
            readonly type: "uint256";
        }, {
            readonly internalType: "address";
            readonly name: "_governance";
            readonly type: "address";
        }, {
            readonly internalType: "string";
            readonly name: "name";
            readonly type: "string";
        }, {
            readonly internalType: "string";
            readonly name: "symbol";
            readonly type: "string";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "constructor";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }, {
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "value";
            readonly type: "uint256";
        }];
        readonly name: "Approval";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "collectedBase";
            readonly type: "uint256";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "collectedBond";
            readonly type: "uint256";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "remainingBase";
            readonly type: "uint256";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "remainingBond";
            readonly type: "uint256";
        }];
        readonly name: "FeeCollection";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "from";
            readonly type: "address";
        }, {
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "to";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "value";
            readonly type: "uint256";
        }];
        readonly name: "Transfer";
        readonly type: "event";
    }, {
        readonly inputs: readonly [];
        readonly name: "DOMAIN_SEPARATOR";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "FEE_BOUND";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }];
        readonly name: "allowance";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "approve";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "account";
            readonly type: "address";
        }];
        readonly name: "balanceOf";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "bond";
        readonly outputs: readonly [{
            readonly internalType: "contract IERC20";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "bondDecimals";
        readonly outputs: readonly [{
            readonly internalType: "uint8";
            readonly name: "";
            readonly type: "uint8";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "decimals";
        readonly outputs: readonly [{
            readonly internalType: "uint8";
            readonly name: "";
            readonly type: "uint8";
        }];
        readonly stateMutability: "pure";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "decreaseApproval";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "expiration";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "feesBond";
        readonly outputs: readonly [{
            readonly internalType: "uint128";
            readonly name: "";
            readonly type: "uint128";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "feesUnderlying";
        readonly outputs: readonly [{
            readonly internalType: "uint128";
            readonly name: "";
            readonly type: "uint128";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getPoolId";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getVault";
        readonly outputs: readonly [{
            readonly internalType: "contract IVault";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "governance";
        readonly outputs: readonly [{
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "increaseApproval";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "name";
        readonly outputs: readonly [{
            readonly internalType: "string";
            readonly name: "";
            readonly type: "string";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }];
        readonly name: "nonces";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "currentBalances";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "protocolSwapFee";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes";
            readonly name: "userData";
            readonly type: "bytes";
        }];
        readonly name: "onExitPool";
        readonly outputs: readonly [{
            readonly internalType: "uint256[]";
            readonly name: "amountsOut";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "dueProtocolFeeAmounts";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "currentBalances";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "protocolSwapFee";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes";
            readonly name: "userData";
            readonly type: "bytes";
        }];
        readonly name: "onJoinPool";
        readonly outputs: readonly [{
            readonly internalType: "uint256[]";
            readonly name: "amountsIn";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "dueProtocolFeeAmounts";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly components: readonly [{
                readonly internalType: "enum IVault.SwapKind";
                readonly name: "kind";
                readonly type: "uint8";
            }, {
                readonly internalType: "contract IERC20";
                readonly name: "tokenIn";
                readonly type: "address";
            }, {
                readonly internalType: "contract IERC20";
                readonly name: "tokenOut";
                readonly type: "address";
            }, {
                readonly internalType: "uint256";
                readonly name: "amount";
                readonly type: "uint256";
            }, {
                readonly internalType: "bytes32";
                readonly name: "poolId";
                readonly type: "bytes32";
            }, {
                readonly internalType: "uint256";
                readonly name: "lastChangeBlock";
                readonly type: "uint256";
            }, {
                readonly internalType: "address";
                readonly name: "from";
                readonly type: "address";
            }, {
                readonly internalType: "address";
                readonly name: "to";
                readonly type: "address";
            }, {
                readonly internalType: "bytes";
                readonly name: "userData";
                readonly type: "bytes";
            }];
            readonly internalType: "struct IPoolSwapStructs.SwapRequest";
            readonly name: "swapRequest";
            readonly type: "tuple";
        }, {
            readonly internalType: "uint256";
            readonly name: "currentBalanceTokenIn";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "currentBalanceTokenOut";
            readonly type: "uint256";
        }];
        readonly name: "onSwap";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "percentFee";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "percentFeeGov";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "value";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "deadline";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint8";
            readonly name: "v";
            readonly type: "uint8";
        }, {
            readonly internalType: "bytes32";
            readonly name: "r";
            readonly type: "bytes32";
        }, {
            readonly internalType: "bytes32";
            readonly name: "s";
            readonly type: "bytes32";
        }];
        readonly name: "permit";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "amountX";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "reserveX";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "reserveY";
            readonly type: "uint256";
        }, {
            readonly internalType: "bool";
            readonly name: "out";
            readonly type: "bool";
        }];
        readonly name: "solveTradeInvariant";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "symbol";
        readonly outputs: readonly [{
            readonly internalType: "string";
            readonly name: "";
            readonly type: "string";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "totalSupply";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "transfer";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "transferFrom";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "underlying";
        readonly outputs: readonly [{
            readonly internalType: "contract IERC20";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "underlyingDecimals";
        readonly outputs: readonly [{
            readonly internalType: "uint8";
            readonly name: "";
            readonly type: "uint8";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "unitSeconds";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }];
    static createInterface(): ConvergentCurvePoolInterface;
    static connect(address: string, signerOrProvider: Signer | Provider): ConvergentCurvePool;
}

declare class ERC20__factory {
    static readonly abi: readonly [{
        readonly constant: true;
        readonly inputs: readonly [];
        readonly name: "name";
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "string";
        }];
        readonly payable: false;
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly constant: false;
        readonly inputs: readonly [{
            readonly name: "_spender";
            readonly type: "address";
        }, {
            readonly name: "_value";
            readonly type: "uint256";
        }];
        readonly name: "approve";
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "bool";
        }];
        readonly payable: false;
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly constant: true;
        readonly inputs: readonly [];
        readonly name: "totalSupply";
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly payable: false;
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly constant: false;
        readonly inputs: readonly [{
            readonly name: "_from";
            readonly type: "address";
        }, {
            readonly name: "_to";
            readonly type: "address";
        }, {
            readonly name: "_value";
            readonly type: "uint256";
        }];
        readonly name: "transferFrom";
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "bool";
        }];
        readonly payable: false;
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly constant: true;
        readonly inputs: readonly [];
        readonly name: "decimals";
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "uint8";
        }];
        readonly payable: false;
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly constant: true;
        readonly inputs: readonly [{
            readonly name: "_owner";
            readonly type: "address";
        }];
        readonly name: "balanceOf";
        readonly outputs: readonly [{
            readonly name: "balance";
            readonly type: "uint256";
        }];
        readonly payable: false;
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly constant: true;
        readonly inputs: readonly [];
        readonly name: "symbol";
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "string";
        }];
        readonly payable: false;
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly constant: false;
        readonly inputs: readonly [{
            readonly name: "_to";
            readonly type: "address";
        }, {
            readonly name: "_value";
            readonly type: "uint256";
        }];
        readonly name: "transfer";
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "bool";
        }];
        readonly payable: false;
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly constant: true;
        readonly inputs: readonly [{
            readonly name: "_owner";
            readonly type: "address";
        }, {
            readonly name: "_spender";
            readonly type: "address";
        }];
        readonly name: "allowance";
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly payable: false;
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly payable: true;
        readonly stateMutability: "payable";
        readonly type: "fallback";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly name: "owner";
            readonly type: "address";
        }, {
            readonly indexed: true;
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly name: "value";
            readonly type: "uint256";
        }];
        readonly name: "Approval";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly name: "from";
            readonly type: "address";
        }, {
            readonly indexed: true;
            readonly name: "to";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly name: "value";
            readonly type: "uint256";
        }];
        readonly name: "Transfer";
        readonly type: "event";
    }];
    static createInterface(): ERC20Interface;
    static connect(address: string, signerOrProvider: Signer | Provider): ERC20;
}

declare class ERC4626LinearPool__factory {
    static readonly abi: readonly [{
        readonly inputs: readonly [{
            readonly components: readonly [{
                readonly internalType: "contract IVault";
                readonly name: "vault";
                readonly type: "address";
            }, {
                readonly internalType: "string";
                readonly name: "name";
                readonly type: "string";
            }, {
                readonly internalType: "string";
                readonly name: "symbol";
                readonly type: "string";
            }, {
                readonly internalType: "contract IERC20";
                readonly name: "mainToken";
                readonly type: "address";
            }, {
                readonly internalType: "contract IERC20";
                readonly name: "wrappedToken";
                readonly type: "address";
            }, {
                readonly internalType: "address";
                readonly name: "assetManager";
                readonly type: "address";
            }, {
                readonly internalType: "uint256";
                readonly name: "upperTarget";
                readonly type: "uint256";
            }, {
                readonly internalType: "uint256";
                readonly name: "swapFeePercentage";
                readonly type: "uint256";
            }, {
                readonly internalType: "uint256";
                readonly name: "pauseWindowDuration";
                readonly type: "uint256";
            }, {
                readonly internalType: "uint256";
                readonly name: "bufferPeriodDuration";
                readonly type: "uint256";
            }, {
                readonly internalType: "address";
                readonly name: "owner";
                readonly type: "address";
            }, {
                readonly internalType: "string";
                readonly name: "version";
                readonly type: "string";
            }];
            readonly internalType: "struct ERC4626LinearPool.ConstructorArgs";
            readonly name: "args";
            readonly type: "tuple";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "constructor";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }, {
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "value";
            readonly type: "uint256";
        }];
        readonly name: "Approval";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "bool";
            readonly name: "paused";
            readonly type: "bool";
        }];
        readonly name: "PausedStateChanged";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "bool";
            readonly name: "enabled";
            readonly type: "bool";
        }];
        readonly name: "RecoveryModeStateChanged";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "swapFeePercentage";
            readonly type: "uint256";
        }];
        readonly name: "SwapFeePercentageChanged";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "contract IERC20";
            readonly name: "token";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "lowerTarget";
            readonly type: "uint256";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "upperTarget";
            readonly type: "uint256";
        }];
        readonly name: "TargetsSet";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "from";
            readonly type: "address";
        }, {
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "to";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "value";
            readonly type: "uint256";
        }];
        readonly name: "Transfer";
        readonly type: "event";
    }, {
        readonly inputs: readonly [];
        readonly name: "DOMAIN_SEPARATOR";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }];
        readonly name: "allowance";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "approve";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "account";
            readonly type: "address";
        }];
        readonly name: "balanceOf";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "decimals";
        readonly outputs: readonly [{
            readonly internalType: "uint8";
            readonly name: "";
            readonly type: "uint8";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "decreaseAllowance";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "disableRecoveryMode";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "enableRecoveryMode";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes4";
            readonly name: "selector";
            readonly type: "bytes4";
        }];
        readonly name: "getActionId";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getAuthorizer";
        readonly outputs: readonly [{
            readonly internalType: "contract IAuthorizer";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getBptIndex";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "pure";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getDomainSeparator";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getMainIndex";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getMainToken";
        readonly outputs: readonly [{
            readonly internalType: "contract IERC20";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "account";
            readonly type: "address";
        }];
        readonly name: "getNextNonce";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getOwner";
        readonly outputs: readonly [{
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getPausedState";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "paused";
            readonly type: "bool";
        }, {
            readonly internalType: "uint256";
            readonly name: "pauseWindowEndTime";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "bufferPeriodEndTime";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getPoolId";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getProtocolFeesCollector";
        readonly outputs: readonly [{
            readonly internalType: "contract IProtocolFeesCollector";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getRate";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getScalingFactors";
        readonly outputs: readonly [{
            readonly internalType: "uint256[]";
            readonly name: "";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getSwapFeePercentage";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getTargets";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "lowerTarget";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "upperTarget";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getVault";
        readonly outputs: readonly [{
            readonly internalType: "contract IVault";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getVirtualSupply";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getWrappedIndex";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getWrappedToken";
        readonly outputs: readonly [{
            readonly internalType: "contract IERC20";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getWrappedTokenRate";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "inRecoveryMode";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "addedValue";
            readonly type: "uint256";
        }];
        readonly name: "increaseAllowance";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "initialize";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "name";
        readonly outputs: readonly [{
            readonly internalType: "string";
            readonly name: "";
            readonly type: "string";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }];
        readonly name: "nonces";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "balances";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes";
            readonly name: "userData";
            readonly type: "bytes";
        }];
        readonly name: "onExitPool";
        readonly outputs: readonly [{
            readonly internalType: "uint256[]";
            readonly name: "amountsOut";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "dueProtocolFees";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "balances";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes";
            readonly name: "userData";
            readonly type: "bytes";
        }];
        readonly name: "onJoinPool";
        readonly outputs: readonly [{
            readonly internalType: "uint256[]";
            readonly name: "amountsIn";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "dueProtocolFees";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly components: readonly [{
                readonly internalType: "enum IVault.SwapKind";
                readonly name: "kind";
                readonly type: "uint8";
            }, {
                readonly internalType: "contract IERC20";
                readonly name: "tokenIn";
                readonly type: "address";
            }, {
                readonly internalType: "contract IERC20";
                readonly name: "tokenOut";
                readonly type: "address";
            }, {
                readonly internalType: "uint256";
                readonly name: "amount";
                readonly type: "uint256";
            }, {
                readonly internalType: "bytes32";
                readonly name: "poolId";
                readonly type: "bytes32";
            }, {
                readonly internalType: "uint256";
                readonly name: "lastChangeBlock";
                readonly type: "uint256";
            }, {
                readonly internalType: "address";
                readonly name: "from";
                readonly type: "address";
            }, {
                readonly internalType: "address";
                readonly name: "to";
                readonly type: "address";
            }, {
                readonly internalType: "bytes";
                readonly name: "userData";
                readonly type: "bytes";
            }];
            readonly internalType: "struct IPoolSwapStructs.SwapRequest";
            readonly name: "request";
            readonly type: "tuple";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "balances";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "indexIn";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "indexOut";
            readonly type: "uint256";
        }];
        readonly name: "onSwap";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly components: readonly [{
                readonly internalType: "enum IVault.SwapKind";
                readonly name: "kind";
                readonly type: "uint8";
            }, {
                readonly internalType: "contract IERC20";
                readonly name: "tokenIn";
                readonly type: "address";
            }, {
                readonly internalType: "contract IERC20";
                readonly name: "tokenOut";
                readonly type: "address";
            }, {
                readonly internalType: "uint256";
                readonly name: "amount";
                readonly type: "uint256";
            }, {
                readonly internalType: "bytes32";
                readonly name: "poolId";
                readonly type: "bytes32";
            }, {
                readonly internalType: "uint256";
                readonly name: "lastChangeBlock";
                readonly type: "uint256";
            }, {
                readonly internalType: "address";
                readonly name: "from";
                readonly type: "address";
            }, {
                readonly internalType: "address";
                readonly name: "to";
                readonly type: "address";
            }, {
                readonly internalType: "bytes";
                readonly name: "userData";
                readonly type: "bytes";
            }];
            readonly internalType: "struct IPoolSwapStructs.SwapRequest";
            readonly name: "request";
            readonly type: "tuple";
        }, {
            readonly internalType: "uint256";
            readonly name: "balanceTokenIn";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "balanceTokenOut";
            readonly type: "uint256";
        }];
        readonly name: "onSwap";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "pause";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "value";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "deadline";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint8";
            readonly name: "v";
            readonly type: "uint8";
        }, {
            readonly internalType: "bytes32";
            readonly name: "r";
            readonly type: "bytes32";
        }, {
            readonly internalType: "bytes32";
            readonly name: "s";
            readonly type: "bytes32";
        }];
        readonly name: "permit";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "balances";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes";
            readonly name: "userData";
            readonly type: "bytes";
        }];
        readonly name: "queryExit";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "bptIn";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "amountsOut";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "balances";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes";
            readonly name: "userData";
            readonly type: "bytes";
        }];
        readonly name: "queryJoin";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "bptOut";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "amountsIn";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "swapFeePercentage";
            readonly type: "uint256";
        }];
        readonly name: "setSwapFeePercentage";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "newLowerTarget";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "newUpperTarget";
            readonly type: "uint256";
        }];
        readonly name: "setTargets";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "symbol";
        readonly outputs: readonly [{
            readonly internalType: "string";
            readonly name: "";
            readonly type: "string";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "totalSupply";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "transfer";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "transferFrom";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "unpause";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "version";
        readonly outputs: readonly [{
            readonly internalType: "string";
            readonly name: "";
            readonly type: "string";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }];
    static createInterface(): ERC4626LinearPoolInterface;
    static connect(address: string, signerOrProvider: Signer | Provider): ERC4626LinearPool;
}

declare class ERC4626LinearPoolFactory__factory {
    static readonly abi: readonly [{
        readonly inputs: readonly [{
            readonly internalType: "contract IVault";
            readonly name: "vault";
            readonly type: "address";
        }, {
            readonly internalType: "contract IProtocolFeePercentagesProvider";
            readonly name: "protocolFeeProvider";
            readonly type: "address";
        }, {
            readonly internalType: "contract IBalancerQueries";
            readonly name: "queries";
            readonly type: "address";
        }, {
            readonly internalType: "string";
            readonly name: "factoryVersion";
            readonly type: "string";
        }, {
            readonly internalType: "string";
            readonly name: "poolVersion";
            readonly type: "string";
        }, {
            readonly internalType: "uint256";
            readonly name: "initialPauseWindowDuration";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "bufferPeriodDuration";
            readonly type: "uint256";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "constructor";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "pool";
            readonly type: "address";
        }, {
            readonly indexed: true;
            readonly internalType: "uint256";
            readonly name: "protocolId";
            readonly type: "uint256";
        }];
        readonly name: "Erc4626LinearPoolCreated";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [];
        readonly name: "FactoryDisabled";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "pool";
            readonly type: "address";
        }];
        readonly name: "PoolCreated";
        readonly type: "event";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "string";
            readonly name: "name";
            readonly type: "string";
        }, {
            readonly internalType: "string";
            readonly name: "symbol";
            readonly type: "string";
        }, {
            readonly internalType: "contract IERC20";
            readonly name: "mainToken";
            readonly type: "address";
        }, {
            readonly internalType: "contract IERC20";
            readonly name: "wrappedToken";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "upperTarget";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "swapFeePercentage";
            readonly type: "uint256";
        }, {
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "protocolId";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes32";
            readonly name: "salt";
            readonly type: "bytes32";
        }];
        readonly name: "create";
        readonly outputs: readonly [{
            readonly internalType: "contract LinearPool";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "disable";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes4";
            readonly name: "selector";
            readonly type: "bytes4";
        }];
        readonly name: "getActionId";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getAuthorizer";
        readonly outputs: readonly [{
            readonly internalType: "contract IAuthorizer";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getCreationCode";
        readonly outputs: readonly [{
            readonly internalType: "bytes";
            readonly name: "";
            readonly type: "bytes";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getCreationCodeContracts";
        readonly outputs: readonly [{
            readonly internalType: "address";
            readonly name: "contractA";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "contractB";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getLastCreatedPool";
        readonly outputs: readonly [{
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getPauseConfiguration";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "pauseWindowDuration";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "bufferPeriodDuration";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getPoolVersion";
        readonly outputs: readonly [{
            readonly internalType: "string";
            readonly name: "";
            readonly type: "string";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getProtocolFeePercentagesProvider";
        readonly outputs: readonly [{
            readonly internalType: "contract IProtocolFeePercentagesProvider";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getVault";
        readonly outputs: readonly [{
            readonly internalType: "contract IVault";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "isDisabled";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "pool";
            readonly type: "address";
        }];
        readonly name: "isPoolFromFactory";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "version";
        readonly outputs: readonly [{
            readonly internalType: "string";
            readonly name: "";
            readonly type: "string";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }];
    static createInterface(): ERC4626LinearPoolFactoryInterface;
    static connect(address: string, signerOrProvider: Signer | Provider): ERC4626LinearPoolFactory;
}

declare class EulerLinearPool__factory {
    static readonly abi: readonly [{
        readonly inputs: readonly [{
            readonly components: readonly [{
                readonly internalType: "contract IVault";
                readonly name: "vault";
                readonly type: "address";
            }, {
                readonly internalType: "string";
                readonly name: "name";
                readonly type: "string";
            }, {
                readonly internalType: "string";
                readonly name: "symbol";
                readonly type: "string";
            }, {
                readonly internalType: "contract IERC20";
                readonly name: "mainToken";
                readonly type: "address";
            }, {
                readonly internalType: "contract IERC20";
                readonly name: "wrappedToken";
                readonly type: "address";
            }, {
                readonly internalType: "address";
                readonly name: "assetManager";
                readonly type: "address";
            }, {
                readonly internalType: "uint256";
                readonly name: "upperTarget";
                readonly type: "uint256";
            }, {
                readonly internalType: "uint256";
                readonly name: "swapFeePercentage";
                readonly type: "uint256";
            }, {
                readonly internalType: "uint256";
                readonly name: "pauseWindowDuration";
                readonly type: "uint256";
            }, {
                readonly internalType: "uint256";
                readonly name: "bufferPeriodDuration";
                readonly type: "uint256";
            }, {
                readonly internalType: "address";
                readonly name: "owner";
                readonly type: "address";
            }, {
                readonly internalType: "string";
                readonly name: "version";
                readonly type: "string";
            }];
            readonly internalType: "struct EulerLinearPool.ConstructorArgs";
            readonly name: "args";
            readonly type: "tuple";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "constructor";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }, {
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "value";
            readonly type: "uint256";
        }];
        readonly name: "Approval";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "bool";
            readonly name: "paused";
            readonly type: "bool";
        }];
        readonly name: "PausedStateChanged";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "bool";
            readonly name: "enabled";
            readonly type: "bool";
        }];
        readonly name: "RecoveryModeStateChanged";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "swapFeePercentage";
            readonly type: "uint256";
        }];
        readonly name: "SwapFeePercentageChanged";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "contract IERC20";
            readonly name: "token";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "lowerTarget";
            readonly type: "uint256";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "upperTarget";
            readonly type: "uint256";
        }];
        readonly name: "TargetsSet";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "from";
            readonly type: "address";
        }, {
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "to";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "value";
            readonly type: "uint256";
        }];
        readonly name: "Transfer";
        readonly type: "event";
    }, {
        readonly inputs: readonly [];
        readonly name: "DOMAIN_SEPARATOR";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }];
        readonly name: "allowance";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "approve";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "account";
            readonly type: "address";
        }];
        readonly name: "balanceOf";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "decimals";
        readonly outputs: readonly [{
            readonly internalType: "uint8";
            readonly name: "";
            readonly type: "uint8";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "decreaseAllowance";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "disableRecoveryMode";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "enableRecoveryMode";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes4";
            readonly name: "selector";
            readonly type: "bytes4";
        }];
        readonly name: "getActionId";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getAuthorizer";
        readonly outputs: readonly [{
            readonly internalType: "contract IAuthorizer";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getBptIndex";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "pure";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getDomainSeparator";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getMainIndex";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getMainToken";
        readonly outputs: readonly [{
            readonly internalType: "contract IERC20";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "account";
            readonly type: "address";
        }];
        readonly name: "getNextNonce";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getOwner";
        readonly outputs: readonly [{
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getPausedState";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "paused";
            readonly type: "bool";
        }, {
            readonly internalType: "uint256";
            readonly name: "pauseWindowEndTime";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "bufferPeriodEndTime";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getPoolId";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getProtocolFeesCollector";
        readonly outputs: readonly [{
            readonly internalType: "contract IProtocolFeesCollector";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getRate";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getScalingFactors";
        readonly outputs: readonly [{
            readonly internalType: "uint256[]";
            readonly name: "";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getSwapFeePercentage";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getTargets";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "lowerTarget";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "upperTarget";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getVault";
        readonly outputs: readonly [{
            readonly internalType: "contract IVault";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getVirtualSupply";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getWrappedIndex";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getWrappedToken";
        readonly outputs: readonly [{
            readonly internalType: "contract IERC20";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getWrappedTokenRate";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "inRecoveryMode";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "addedValue";
            readonly type: "uint256";
        }];
        readonly name: "increaseAllowance";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "initialize";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "name";
        readonly outputs: readonly [{
            readonly internalType: "string";
            readonly name: "";
            readonly type: "string";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }];
        readonly name: "nonces";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "balances";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes";
            readonly name: "userData";
            readonly type: "bytes";
        }];
        readonly name: "onExitPool";
        readonly outputs: readonly [{
            readonly internalType: "uint256[]";
            readonly name: "amountsOut";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "dueProtocolFees";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "balances";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes";
            readonly name: "userData";
            readonly type: "bytes";
        }];
        readonly name: "onJoinPool";
        readonly outputs: readonly [{
            readonly internalType: "uint256[]";
            readonly name: "amountsIn";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "dueProtocolFees";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly components: readonly [{
                readonly internalType: "enum IVault.SwapKind";
                readonly name: "kind";
                readonly type: "uint8";
            }, {
                readonly internalType: "contract IERC20";
                readonly name: "tokenIn";
                readonly type: "address";
            }, {
                readonly internalType: "contract IERC20";
                readonly name: "tokenOut";
                readonly type: "address";
            }, {
                readonly internalType: "uint256";
                readonly name: "amount";
                readonly type: "uint256";
            }, {
                readonly internalType: "bytes32";
                readonly name: "poolId";
                readonly type: "bytes32";
            }, {
                readonly internalType: "uint256";
                readonly name: "lastChangeBlock";
                readonly type: "uint256";
            }, {
                readonly internalType: "address";
                readonly name: "from";
                readonly type: "address";
            }, {
                readonly internalType: "address";
                readonly name: "to";
                readonly type: "address";
            }, {
                readonly internalType: "bytes";
                readonly name: "userData";
                readonly type: "bytes";
            }];
            readonly internalType: "struct IPoolSwapStructs.SwapRequest";
            readonly name: "request";
            readonly type: "tuple";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "balances";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "indexIn";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "indexOut";
            readonly type: "uint256";
        }];
        readonly name: "onSwap";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly components: readonly [{
                readonly internalType: "enum IVault.SwapKind";
                readonly name: "kind";
                readonly type: "uint8";
            }, {
                readonly internalType: "contract IERC20";
                readonly name: "tokenIn";
                readonly type: "address";
            }, {
                readonly internalType: "contract IERC20";
                readonly name: "tokenOut";
                readonly type: "address";
            }, {
                readonly internalType: "uint256";
                readonly name: "amount";
                readonly type: "uint256";
            }, {
                readonly internalType: "bytes32";
                readonly name: "poolId";
                readonly type: "bytes32";
            }, {
                readonly internalType: "uint256";
                readonly name: "lastChangeBlock";
                readonly type: "uint256";
            }, {
                readonly internalType: "address";
                readonly name: "from";
                readonly type: "address";
            }, {
                readonly internalType: "address";
                readonly name: "to";
                readonly type: "address";
            }, {
                readonly internalType: "bytes";
                readonly name: "userData";
                readonly type: "bytes";
            }];
            readonly internalType: "struct IPoolSwapStructs.SwapRequest";
            readonly name: "request";
            readonly type: "tuple";
        }, {
            readonly internalType: "uint256";
            readonly name: "balanceTokenIn";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "balanceTokenOut";
            readonly type: "uint256";
        }];
        readonly name: "onSwap";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "pause";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "value";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "deadline";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint8";
            readonly name: "v";
            readonly type: "uint8";
        }, {
            readonly internalType: "bytes32";
            readonly name: "r";
            readonly type: "bytes32";
        }, {
            readonly internalType: "bytes32";
            readonly name: "s";
            readonly type: "bytes32";
        }];
        readonly name: "permit";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "balances";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes";
            readonly name: "userData";
            readonly type: "bytes";
        }];
        readonly name: "queryExit";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "bptIn";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "amountsOut";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "balances";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes";
            readonly name: "userData";
            readonly type: "bytes";
        }];
        readonly name: "queryJoin";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "bptOut";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "amountsIn";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "swapFeePercentage";
            readonly type: "uint256";
        }];
        readonly name: "setSwapFeePercentage";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "newLowerTarget";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "newUpperTarget";
            readonly type: "uint256";
        }];
        readonly name: "setTargets";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "symbol";
        readonly outputs: readonly [{
            readonly internalType: "string";
            readonly name: "";
            readonly type: "string";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "totalSupply";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "transfer";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "transferFrom";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "unpause";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "version";
        readonly outputs: readonly [{
            readonly internalType: "string";
            readonly name: "";
            readonly type: "string";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }];
    static createInterface(): EulerLinearPoolInterface;
    static connect(address: string, signerOrProvider: Signer | Provider): EulerLinearPool;
}

declare class EulerLinearPoolFactory__factory {
    static readonly abi: readonly [{
        readonly inputs: readonly [{
            readonly internalType: "contract IVault";
            readonly name: "vault";
            readonly type: "address";
        }, {
            readonly internalType: "contract IProtocolFeePercentagesProvider";
            readonly name: "protocolFeeProvider";
            readonly type: "address";
        }, {
            readonly internalType: "contract IBalancerQueries";
            readonly name: "queries";
            readonly type: "address";
        }, {
            readonly internalType: "string";
            readonly name: "factoryVersion";
            readonly type: "string";
        }, {
            readonly internalType: "string";
            readonly name: "poolVersion";
            readonly type: "string";
        }, {
            readonly internalType: "uint256";
            readonly name: "initialPauseWindowDuration";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "bufferPeriodDuration";
            readonly type: "uint256";
        }, {
            readonly internalType: "address";
            readonly name: "_eulerProtocol";
            readonly type: "address";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "constructor";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "pool";
            readonly type: "address";
        }, {
            readonly indexed: true;
            readonly internalType: "uint256";
            readonly name: "protocolId";
            readonly type: "uint256";
        }];
        readonly name: "EulerLinearPoolCreated";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [];
        readonly name: "FactoryDisabled";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "pool";
            readonly type: "address";
        }];
        readonly name: "PoolCreated";
        readonly type: "event";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "string";
            readonly name: "name";
            readonly type: "string";
        }, {
            readonly internalType: "string";
            readonly name: "symbol";
            readonly type: "string";
        }, {
            readonly internalType: "contract IERC20";
            readonly name: "mainToken";
            readonly type: "address";
        }, {
            readonly internalType: "contract IERC20";
            readonly name: "wrappedToken";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "upperTarget";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "swapFeePercentage";
            readonly type: "uint256";
        }, {
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "protocolId";
            readonly type: "uint256";
        }];
        readonly name: "create";
        readonly outputs: readonly [{
            readonly internalType: "contract LinearPool";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "disable";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "eulerProtocol";
        readonly outputs: readonly [{
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes4";
            readonly name: "selector";
            readonly type: "bytes4";
        }];
        readonly name: "getActionId";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getAuthorizer";
        readonly outputs: readonly [{
            readonly internalType: "contract IAuthorizer";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getCreationCode";
        readonly outputs: readonly [{
            readonly internalType: "bytes";
            readonly name: "";
            readonly type: "bytes";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getCreationCodeContracts";
        readonly outputs: readonly [{
            readonly internalType: "address";
            readonly name: "contractA";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "contractB";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getLastCreatedPool";
        readonly outputs: readonly [{
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getPauseConfiguration";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "pauseWindowDuration";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "bufferPeriodDuration";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getPoolVersion";
        readonly outputs: readonly [{
            readonly internalType: "string";
            readonly name: "";
            readonly type: "string";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getProtocolFeePercentagesProvider";
        readonly outputs: readonly [{
            readonly internalType: "contract IProtocolFeePercentagesProvider";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getVault";
        readonly outputs: readonly [{
            readonly internalType: "contract IVault";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "isDisabled";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "pool";
            readonly type: "address";
        }];
        readonly name: "isPoolFromFactory";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "version";
        readonly outputs: readonly [{
            readonly internalType: "string";
            readonly name: "";
            readonly type: "string";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }];
    static createInterface(): EulerLinearPoolFactoryInterface;
    static connect(address: string, signerOrProvider: Signer | Provider): EulerLinearPoolFactory;
}

declare class FXPool__factory {
    static readonly abi: readonly [{
        readonly inputs: readonly [{
            readonly internalType: "address[]";
            readonly name: "_assetsToRegister";
            readonly type: "address[]";
        }, {
            readonly internalType: "contract IVault";
            readonly name: "vault";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "_protocolPercentFee";
            readonly type: "uint256";
        }, {
            readonly internalType: "string";
            readonly name: "_name";
            readonly type: "string";
        }, {
            readonly internalType: "string";
            readonly name: "_symbol";
            readonly type: "string";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "constructor";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }, {
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "value";
            readonly type: "uint256";
        }];
        readonly name: "Approval";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "numeraire";
            readonly type: "address";
        }, {
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "reserve";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "weight";
            readonly type: "uint256";
        }];
        readonly name: "AssetIncluded";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "derivative";
            readonly type: "address";
        }, {
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "numeraire";
            readonly type: "address";
        }, {
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "reserve";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly internalType: "address";
            readonly name: "assimilator";
            readonly type: "address";
        }];
        readonly name: "AssimilatorIncluded";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "address";
            readonly name: "newCollector";
            readonly type: "address";
        }];
        readonly name: "ChangeCollectorAddress";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "bool";
            readonly name: "isEmergency";
            readonly type: "bool";
        }];
        readonly name: "EmergencyAlarm";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "lptAmountBurned";
            readonly type: "uint256";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256[]";
            readonly name: "amountsWithdrawn";
            readonly type: "uint256[]";
        }];
        readonly name: "EmergencyWithdraw";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "feesCollected";
            readonly type: "uint256";
        }];
        readonly name: "FeesAccrued";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "feesCollected";
            readonly type: "uint256";
        }];
        readonly name: "FeesCollected";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "lptAmountBurned";
            readonly type: "uint256";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256[]";
            readonly name: "amountsWithdrawn";
            readonly type: "uint256[]";
        }];
        readonly name: "OnExitPool";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "lptAmountMinted";
            readonly type: "uint256";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256[]";
            readonly name: "amountsDeposited";
            readonly type: "uint256[]";
        }];
        readonly name: "OnJoinPool";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "previousOwner";
            readonly type: "address";
        }, {
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "newOwner";
            readonly type: "address";
        }];
        readonly name: "OwnershipTransferred";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "alpha";
            readonly type: "uint256";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "beta";
            readonly type: "uint256";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "delta";
            readonly type: "uint256";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "epsilon";
            readonly type: "uint256";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "lambda";
            readonly type: "uint256";
        }];
        readonly name: "ParametersSet";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "address";
            readonly name: "account";
            readonly type: "address";
        }];
        readonly name: "Paused";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "address";
            readonly name: "updater";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "newProtocolPercentage";
            readonly type: "uint256";
        }];
        readonly name: "ProtocolFeeShareUpdated";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "trader";
            readonly type: "address";
        }, {
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "origin";
            readonly type: "address";
        }, {
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "target";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "originAmount";
            readonly type: "uint256";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "targetAmount";
            readonly type: "uint256";
        }];
        readonly name: "Trade";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "from";
            readonly type: "address";
        }, {
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "to";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "value";
            readonly type: "uint256";
        }];
        readonly name: "Transfer";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "address";
            readonly name: "account";
            readonly type: "address";
        }];
        readonly name: "Unpaused";
        readonly type: "event";
    }, {
        readonly inputs: readonly [];
        readonly name: "DOMAIN_SEPARATOR";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }];
        readonly name: "allowance";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "approve";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "_derivative";
            readonly type: "address";
        }];
        readonly name: "assimilator";
        readonly outputs: readonly [{
            readonly internalType: "address";
            readonly name: "assimilator_";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "account";
            readonly type: "address";
        }];
        readonly name: "balanceOf";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "collectorAddress";
        readonly outputs: readonly [{
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "curve";
        readonly outputs: readonly [{
            readonly internalType: "int128";
            readonly name: "alpha";
            readonly type: "int128";
        }, {
            readonly internalType: "int128";
            readonly name: "beta";
            readonly type: "int128";
        }, {
            readonly internalType: "int128";
            readonly name: "delta";
            readonly type: "int128";
        }, {
            readonly internalType: "int128";
            readonly name: "epsilon";
            readonly type: "int128";
        }, {
            readonly internalType: "int128";
            readonly name: "lambda";
            readonly type: "int128";
        }, {
            readonly internalType: "uint256";
            readonly name: "cap";
            readonly type: "uint256";
        }, {
            readonly internalType: "contract IVault";
            readonly name: "vault";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "fxPoolAddress";
            readonly type: "address";
        }, {
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "decimals";
        readonly outputs: readonly [{
            readonly internalType: "uint8";
            readonly name: "";
            readonly type: "uint8";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "decreaseAllowance";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly name: "derivatives";
        readonly outputs: readonly [{
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "emergency";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getPoolId";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getVault";
        readonly outputs: readonly [{
            readonly internalType: "contract IVault";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "addedValue";
            readonly type: "uint256";
        }];
        readonly name: "increaseAllowance";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address[]";
            readonly name: "_assets";
            readonly type: "address[]";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "_assetWeights";
            readonly type: "uint256[]";
        }];
        readonly name: "initialize";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "liquidity";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "total_";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "individual_";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "name";
        readonly outputs: readonly [{
            readonly internalType: "string";
            readonly name: "";
            readonly type: "string";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }];
        readonly name: "nonces";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly name: "numeraires";
        readonly outputs: readonly [{
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes";
            readonly name: "userData";
            readonly type: "bytes";
        }];
        readonly name: "onExitPool";
        readonly outputs: readonly [{
            readonly internalType: "uint256[]";
            readonly name: "amountsOut";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "dueProtocolFeeAmounts";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes";
            readonly name: "userData";
            readonly type: "bytes";
        }];
        readonly name: "onJoinPool";
        readonly outputs: readonly [{
            readonly internalType: "uint256[]";
            readonly name: "amountsIn";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "dueProtocolFeeAmounts";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly components: readonly [{
                readonly internalType: "enum IVault.SwapKind";
                readonly name: "kind";
                readonly type: "uint8";
            }, {
                readonly internalType: "contract IERC20";
                readonly name: "tokenIn";
                readonly type: "address";
            }, {
                readonly internalType: "contract IERC20";
                readonly name: "tokenOut";
                readonly type: "address";
            }, {
                readonly internalType: "uint256";
                readonly name: "amount";
                readonly type: "uint256";
            }, {
                readonly internalType: "bytes32";
                readonly name: "poolId";
                readonly type: "bytes32";
            }, {
                readonly internalType: "uint256";
                readonly name: "lastChangeBlock";
                readonly type: "uint256";
            }, {
                readonly internalType: "address";
                readonly name: "from";
                readonly type: "address";
            }, {
                readonly internalType: "address";
                readonly name: "to";
                readonly type: "address";
            }, {
                readonly internalType: "bytes";
                readonly name: "userData";
                readonly type: "bytes";
            }];
            readonly internalType: "struct IPoolSwapStructs.SwapRequest";
            readonly name: "swapRequest";
            readonly type: "tuple";
        }, {
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly name: "onSwap";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "owner";
        readonly outputs: readonly [{
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "paused";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "value";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "deadline";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint8";
            readonly name: "v";
            readonly type: "uint8";
        }, {
            readonly internalType: "bytes32";
            readonly name: "r";
            readonly type: "bytes32";
        }, {
            readonly internalType: "bytes32";
            readonly name: "s";
            readonly type: "bytes32";
        }];
        readonly name: "permit";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "protocolPercentFee";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "renounceOwnership";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly name: "reserves";
        readonly outputs: readonly [{
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "_cap";
            readonly type: "uint256";
        }];
        readonly name: "setCap";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "_collectorAddress";
            readonly type: "address";
        }];
        readonly name: "setCollectorAddress";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bool";
            readonly name: "_emergency";
            readonly type: "bool";
        }];
        readonly name: "setEmergency";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "_alpha";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "_beta";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "_feeAtHalt";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "_epsilon";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "_lambda";
            readonly type: "uint256";
        }];
        readonly name: "setParams";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "setPaused";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "_protocolPercentFee";
            readonly type: "uint256";
        }];
        readonly name: "setProtocolPercentFee";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "symbol";
        readonly outputs: readonly [{
            readonly internalType: "string";
            readonly name: "";
            readonly type: "string";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "totalSupply";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "totalUnclaimedFeesInNumeraire";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "transfer";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "transferFrom";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "newOwner";
            readonly type: "address";
        }];
        readonly name: "transferOwnership";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "totalDepositNumeraire";
            readonly type: "uint256";
        }];
        readonly name: "viewDeposit";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "viewParameters";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "alpha_";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "beta_";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "delta_";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "epsilon_";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "lambda_";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "_curvesToBurn";
            readonly type: "uint256";
        }];
        readonly name: "viewWithdraw";
        readonly outputs: readonly [{
            readonly internalType: "uint256[]";
            readonly name: "";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }];
    static createInterface(): FXPoolInterface;
    static connect(address: string, signerOrProvider: Signer | Provider): FXPool;
}

declare class GaugeClaimHelper__factory {
    static readonly abi: readonly [{
        readonly inputs: readonly [];
        readonly name: "CLAIM_FREQUENCY";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "contract IRewardsOnlyGauge";
            readonly name: "gauge";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "user";
            readonly type: "address";
        }];
        readonly name: "claimRewardsFromGauge";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "contract IRewardsOnlyGauge[]";
            readonly name: "gauges";
            readonly type: "address[]";
        }, {
            readonly internalType: "address";
            readonly name: "user";
            readonly type: "address";
        }];
        readonly name: "claimRewardsFromGauges";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "contract IRewardsOnlyGauge";
            readonly name: "gauge";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "user";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "token";
            readonly type: "address";
        }];
        readonly name: "getPendingRewards";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }];
    static createInterface(): GaugeClaimHelperInterface;
    static connect(address: string, signerOrProvider: Signer | Provider): GaugeClaimHelper;
}

declare class GearboxLinearPool__factory {
    static readonly abi: readonly [{
        readonly inputs: readonly [{
            readonly components: readonly [{
                readonly internalType: "contract IVault";
                readonly name: "vault";
                readonly type: "address";
            }, {
                readonly internalType: "string";
                readonly name: "name";
                readonly type: "string";
            }, {
                readonly internalType: "string";
                readonly name: "symbol";
                readonly type: "string";
            }, {
                readonly internalType: "contract IERC20";
                readonly name: "mainToken";
                readonly type: "address";
            }, {
                readonly internalType: "contract IERC20";
                readonly name: "wrappedToken";
                readonly type: "address";
            }, {
                readonly internalType: "address";
                readonly name: "assetManager";
                readonly type: "address";
            }, {
                readonly internalType: "uint256";
                readonly name: "upperTarget";
                readonly type: "uint256";
            }, {
                readonly internalType: "uint256";
                readonly name: "swapFeePercentage";
                readonly type: "uint256";
            }, {
                readonly internalType: "uint256";
                readonly name: "pauseWindowDuration";
                readonly type: "uint256";
            }, {
                readonly internalType: "uint256";
                readonly name: "bufferPeriodDuration";
                readonly type: "uint256";
            }, {
                readonly internalType: "address";
                readonly name: "owner";
                readonly type: "address";
            }, {
                readonly internalType: "string";
                readonly name: "version";
                readonly type: "string";
            }];
            readonly internalType: "struct GearboxLinearPool.ConstructorArgs";
            readonly name: "args";
            readonly type: "tuple";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "constructor";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }, {
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "value";
            readonly type: "uint256";
        }];
        readonly name: "Approval";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "bool";
            readonly name: "paused";
            readonly type: "bool";
        }];
        readonly name: "PausedStateChanged";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "bool";
            readonly name: "enabled";
            readonly type: "bool";
        }];
        readonly name: "RecoveryModeStateChanged";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "swapFeePercentage";
            readonly type: "uint256";
        }];
        readonly name: "SwapFeePercentageChanged";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "contract IERC20";
            readonly name: "token";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "lowerTarget";
            readonly type: "uint256";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "upperTarget";
            readonly type: "uint256";
        }];
        readonly name: "TargetsSet";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "from";
            readonly type: "address";
        }, {
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "to";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "value";
            readonly type: "uint256";
        }];
        readonly name: "Transfer";
        readonly type: "event";
    }, {
        readonly inputs: readonly [];
        readonly name: "DOMAIN_SEPARATOR";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }];
        readonly name: "allowance";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "approve";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "account";
            readonly type: "address";
        }];
        readonly name: "balanceOf";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "decimals";
        readonly outputs: readonly [{
            readonly internalType: "uint8";
            readonly name: "";
            readonly type: "uint8";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "decreaseAllowance";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "disableRecoveryMode";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "enableRecoveryMode";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes4";
            readonly name: "selector";
            readonly type: "bytes4";
        }];
        readonly name: "getActionId";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getAuthorizer";
        readonly outputs: readonly [{
            readonly internalType: "contract IAuthorizer";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getBptIndex";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "pure";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getDomainSeparator";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getMainIndex";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getMainToken";
        readonly outputs: readonly [{
            readonly internalType: "contract IERC20";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "account";
            readonly type: "address";
        }];
        readonly name: "getNextNonce";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getOwner";
        readonly outputs: readonly [{
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getPausedState";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "paused";
            readonly type: "bool";
        }, {
            readonly internalType: "uint256";
            readonly name: "pauseWindowEndTime";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "bufferPeriodEndTime";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getPoolId";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getProtocolFeesCollector";
        readonly outputs: readonly [{
            readonly internalType: "contract IProtocolFeesCollector";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getRate";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getScalingFactors";
        readonly outputs: readonly [{
            readonly internalType: "uint256[]";
            readonly name: "";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getSwapFeePercentage";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getTargets";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "lowerTarget";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "upperTarget";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getVault";
        readonly outputs: readonly [{
            readonly internalType: "contract IVault";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getVirtualSupply";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getWrappedIndex";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getWrappedToken";
        readonly outputs: readonly [{
            readonly internalType: "contract IERC20";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getWrappedTokenRate";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "inRecoveryMode";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "addedValue";
            readonly type: "uint256";
        }];
        readonly name: "increaseAllowance";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "initialize";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "name";
        readonly outputs: readonly [{
            readonly internalType: "string";
            readonly name: "";
            readonly type: "string";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }];
        readonly name: "nonces";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "balances";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes";
            readonly name: "userData";
            readonly type: "bytes";
        }];
        readonly name: "onExitPool";
        readonly outputs: readonly [{
            readonly internalType: "uint256[]";
            readonly name: "amountsOut";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "dueProtocolFees";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "balances";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes";
            readonly name: "userData";
            readonly type: "bytes";
        }];
        readonly name: "onJoinPool";
        readonly outputs: readonly [{
            readonly internalType: "uint256[]";
            readonly name: "amountsIn";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "dueProtocolFees";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly components: readonly [{
                readonly internalType: "enum IVault.SwapKind";
                readonly name: "kind";
                readonly type: "uint8";
            }, {
                readonly internalType: "contract IERC20";
                readonly name: "tokenIn";
                readonly type: "address";
            }, {
                readonly internalType: "contract IERC20";
                readonly name: "tokenOut";
                readonly type: "address";
            }, {
                readonly internalType: "uint256";
                readonly name: "amount";
                readonly type: "uint256";
            }, {
                readonly internalType: "bytes32";
                readonly name: "poolId";
                readonly type: "bytes32";
            }, {
                readonly internalType: "uint256";
                readonly name: "lastChangeBlock";
                readonly type: "uint256";
            }, {
                readonly internalType: "address";
                readonly name: "from";
                readonly type: "address";
            }, {
                readonly internalType: "address";
                readonly name: "to";
                readonly type: "address";
            }, {
                readonly internalType: "bytes";
                readonly name: "userData";
                readonly type: "bytes";
            }];
            readonly internalType: "struct IPoolSwapStructs.SwapRequest";
            readonly name: "request";
            readonly type: "tuple";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "balances";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "indexIn";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "indexOut";
            readonly type: "uint256";
        }];
        readonly name: "onSwap";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly components: readonly [{
                readonly internalType: "enum IVault.SwapKind";
                readonly name: "kind";
                readonly type: "uint8";
            }, {
                readonly internalType: "contract IERC20";
                readonly name: "tokenIn";
                readonly type: "address";
            }, {
                readonly internalType: "contract IERC20";
                readonly name: "tokenOut";
                readonly type: "address";
            }, {
                readonly internalType: "uint256";
                readonly name: "amount";
                readonly type: "uint256";
            }, {
                readonly internalType: "bytes32";
                readonly name: "poolId";
                readonly type: "bytes32";
            }, {
                readonly internalType: "uint256";
                readonly name: "lastChangeBlock";
                readonly type: "uint256";
            }, {
                readonly internalType: "address";
                readonly name: "from";
                readonly type: "address";
            }, {
                readonly internalType: "address";
                readonly name: "to";
                readonly type: "address";
            }, {
                readonly internalType: "bytes";
                readonly name: "userData";
                readonly type: "bytes";
            }];
            readonly internalType: "struct IPoolSwapStructs.SwapRequest";
            readonly name: "request";
            readonly type: "tuple";
        }, {
            readonly internalType: "uint256";
            readonly name: "balanceTokenIn";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "balanceTokenOut";
            readonly type: "uint256";
        }];
        readonly name: "onSwap";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "pause";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "value";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "deadline";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint8";
            readonly name: "v";
            readonly type: "uint8";
        }, {
            readonly internalType: "bytes32";
            readonly name: "r";
            readonly type: "bytes32";
        }, {
            readonly internalType: "bytes32";
            readonly name: "s";
            readonly type: "bytes32";
        }];
        readonly name: "permit";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "balances";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes";
            readonly name: "userData";
            readonly type: "bytes";
        }];
        readonly name: "queryExit";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "bptIn";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "amountsOut";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "balances";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes";
            readonly name: "userData";
            readonly type: "bytes";
        }];
        readonly name: "queryJoin";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "bptOut";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "amountsIn";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "swapFeePercentage";
            readonly type: "uint256";
        }];
        readonly name: "setSwapFeePercentage";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "newLowerTarget";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "newUpperTarget";
            readonly type: "uint256";
        }];
        readonly name: "setTargets";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "symbol";
        readonly outputs: readonly [{
            readonly internalType: "string";
            readonly name: "";
            readonly type: "string";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "totalSupply";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "transfer";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "transferFrom";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "unpause";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "version";
        readonly outputs: readonly [{
            readonly internalType: "string";
            readonly name: "";
            readonly type: "string";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }];
    static createInterface(): GearboxLinearPoolInterface;
    static connect(address: string, signerOrProvider: Signer | Provider): GearboxLinearPool;
}

declare class GearboxLinearPoolFactory__factory {
    static readonly abi: readonly [{
        readonly inputs: readonly [{
            readonly internalType: "contract IVault";
            readonly name: "vault";
            readonly type: "address";
        }, {
            readonly internalType: "contract IProtocolFeePercentagesProvider";
            readonly name: "protocolFeeProvider";
            readonly type: "address";
        }, {
            readonly internalType: "contract IBalancerQueries";
            readonly name: "queries";
            readonly type: "address";
        }, {
            readonly internalType: "string";
            readonly name: "factoryVersion";
            readonly type: "string";
        }, {
            readonly internalType: "string";
            readonly name: "poolVersion";
            readonly type: "string";
        }, {
            readonly internalType: "uint256";
            readonly name: "initialPauseWindowDuration";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "bufferPeriodDuration";
            readonly type: "uint256";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "constructor";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [];
        readonly name: "FactoryDisabled";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "pool";
            readonly type: "address";
        }, {
            readonly indexed: true;
            readonly internalType: "uint256";
            readonly name: "protocolId";
            readonly type: "uint256";
        }];
        readonly name: "GearboxLinearPoolCreated";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "pool";
            readonly type: "address";
        }];
        readonly name: "PoolCreated";
        readonly type: "event";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "string";
            readonly name: "name";
            readonly type: "string";
        }, {
            readonly internalType: "string";
            readonly name: "symbol";
            readonly type: "string";
        }, {
            readonly internalType: "contract IERC20";
            readonly name: "mainToken";
            readonly type: "address";
        }, {
            readonly internalType: "contract IERC20";
            readonly name: "wrappedToken";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "upperTarget";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "swapFeePercentage";
            readonly type: "uint256";
        }, {
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "protocolId";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes32";
            readonly name: "salt";
            readonly type: "bytes32";
        }];
        readonly name: "create";
        readonly outputs: readonly [{
            readonly internalType: "contract GearboxLinearPool";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "disable";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes4";
            readonly name: "selector";
            readonly type: "bytes4";
        }];
        readonly name: "getActionId";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getAuthorizer";
        readonly outputs: readonly [{
            readonly internalType: "contract IAuthorizer";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getCreationCode";
        readonly outputs: readonly [{
            readonly internalType: "bytes";
            readonly name: "";
            readonly type: "bytes";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getCreationCodeContracts";
        readonly outputs: readonly [{
            readonly internalType: "address";
            readonly name: "contractA";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "contractB";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getLastCreatedPool";
        readonly outputs: readonly [{
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getPauseConfiguration";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "pauseWindowDuration";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "bufferPeriodDuration";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getPoolVersion";
        readonly outputs: readonly [{
            readonly internalType: "string";
            readonly name: "";
            readonly type: "string";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getProtocolFeePercentagesProvider";
        readonly outputs: readonly [{
            readonly internalType: "contract IProtocolFeePercentagesProvider";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getVault";
        readonly outputs: readonly [{
            readonly internalType: "contract IVault";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "isDisabled";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "pool";
            readonly type: "address";
        }];
        readonly name: "isPoolFromFactory";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "version";
        readonly outputs: readonly [{
            readonly internalType: "string";
            readonly name: "";
            readonly type: "string";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }];
    static createInterface(): GearboxLinearPoolFactoryInterface;
    static connect(address: string, signerOrProvider: Signer | Provider): GearboxLinearPoolFactory;
}

declare class GyroConfig__factory {
    static readonly abi: readonly [{
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "bytes32";
            readonly name: "key";
            readonly type: "bytes32";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "previousValue";
            readonly type: "uint256";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "newValue";
            readonly type: "uint256";
        }];
        readonly name: "ConfigChanged";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "bytes32";
            readonly name: "key";
            readonly type: "bytes32";
        }];
        readonly name: "ConfigFrozen";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "bytes32";
            readonly name: "key";
            readonly type: "bytes32";
        }];
        readonly name: "ConfigUnset";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "address";
            readonly name: "newGovernor";
            readonly type: "address";
        }];
        readonly name: "GovernorChangeRequested";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "address";
            readonly name: "oldGovernor";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly internalType: "address";
            readonly name: "newGovernor";
            readonly type: "address";
        }];
        readonly name: "GovernorChanged";
        readonly type: "event";
    }, {
        readonly inputs: readonly [];
        readonly name: "acceptGovernance";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "newGovernor";
            readonly type: "address";
        }];
        readonly name: "changeGovernor";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "key";
            readonly type: "bytes32";
        }];
        readonly name: "freeze";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "key";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "defaultValue";
            readonly type: "address";
        }];
        readonly name: "getAddress";
        readonly outputs: readonly [{
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "key";
            readonly type: "bytes32";
        }];
        readonly name: "getAddress";
        readonly outputs: readonly [{
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "key";
            readonly type: "bytes32";
        }];
        readonly name: "getConfigMeta";
        readonly outputs: readonly [{
            readonly internalType: "uint8";
            readonly name: "";
            readonly type: "uint8";
        }, {
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "key";
            readonly type: "bytes32";
        }];
        readonly name: "getUint";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "governor";
        readonly outputs: readonly [{
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "key";
            readonly type: "bytes32";
        }];
        readonly name: "hasKey";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "_governor";
            readonly type: "address";
        }];
        readonly name: "initialize";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "listKeys";
        readonly outputs: readonly [{
            readonly internalType: "bytes32[]";
            readonly name: "";
            readonly type: "bytes32[]";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "pendingGovernor";
        readonly outputs: readonly [{
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "key";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "newValue";
            readonly type: "address";
        }];
        readonly name: "setAddress";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "key";
            readonly type: "bytes32";
        }, {
            readonly internalType: "uint256";
            readonly name: "newValue";
            readonly type: "uint256";
        }];
        readonly name: "setUint";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "key";
            readonly type: "bytes32";
        }];
        readonly name: "unset";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }];
    static createInterface(): GyroConfigInterface;
    static connect(address: string, signerOrProvider: Signer | Provider): GyroConfig;
}

declare class LidoRelayer__factory {
    static readonly abi: readonly [{
        readonly inputs: readonly [{
            readonly internalType: "contract IVault";
            readonly name: "vault";
            readonly type: "address";
        }, {
            readonly internalType: "contract IwstETH";
            readonly name: "wstETH";
            readonly type: "address";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "constructor";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "enum IVault.SwapKind";
            readonly name: "kind";
            readonly type: "uint8";
        }, {
            readonly components: readonly [{
                readonly internalType: "bytes32";
                readonly name: "poolId";
                readonly type: "bytes32";
            }, {
                readonly internalType: "uint256";
                readonly name: "assetInIndex";
                readonly type: "uint256";
            }, {
                readonly internalType: "uint256";
                readonly name: "assetOutIndex";
                readonly type: "uint256";
            }, {
                readonly internalType: "uint256";
                readonly name: "amount";
                readonly type: "uint256";
            }, {
                readonly internalType: "bytes";
                readonly name: "userData";
                readonly type: "bytes";
            }];
            readonly internalType: "struct IVault.BatchSwapStep[]";
            readonly name: "swaps";
            readonly type: "tuple[]";
        }, {
            readonly internalType: "contract IAsset[]";
            readonly name: "assets";
            readonly type: "address[]";
        }, {
            readonly components: readonly [{
                readonly internalType: "address";
                readonly name: "sender";
                readonly type: "address";
            }, {
                readonly internalType: "bool";
                readonly name: "fromInternalBalance";
                readonly type: "bool";
            }, {
                readonly internalType: "address payable";
                readonly name: "recipient";
                readonly type: "address";
            }, {
                readonly internalType: "bool";
                readonly name: "toInternalBalance";
                readonly type: "bool";
            }];
            readonly internalType: "struct IVault.FundManagement";
            readonly name: "funds";
            readonly type: "tuple";
        }, {
            readonly internalType: "int256[]";
            readonly name: "limits";
            readonly type: "int256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "deadline";
            readonly type: "uint256";
        }];
        readonly name: "batchSwap";
        readonly outputs: readonly [{
            readonly internalType: "int256[]";
            readonly name: "swapAmounts";
            readonly type: "int256[]";
        }];
        readonly stateMutability: "payable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address payable";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly components: readonly [{
                readonly internalType: "contract IAsset[]";
                readonly name: "assets";
                readonly type: "address[]";
            }, {
                readonly internalType: "uint256[]";
                readonly name: "minAmountsOut";
                readonly type: "uint256[]";
            }, {
                readonly internalType: "bytes";
                readonly name: "userData";
                readonly type: "bytes";
            }, {
                readonly internalType: "bool";
                readonly name: "toInternalBalance";
                readonly type: "bool";
            }];
            readonly internalType: "struct IVault.ExitPoolRequest";
            readonly name: "request";
            readonly type: "tuple";
        }];
        readonly name: "exitPool";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getStETH";
        readonly outputs: readonly [{
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getVault";
        readonly outputs: readonly [{
            readonly internalType: "contract IVault";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getWstETH";
        readonly outputs: readonly [{
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly components: readonly [{
                readonly internalType: "contract IAsset[]";
                readonly name: "assets";
                readonly type: "address[]";
            }, {
                readonly internalType: "uint256[]";
                readonly name: "maxAmountsIn";
                readonly type: "uint256[]";
            }, {
                readonly internalType: "bytes";
                readonly name: "userData";
                readonly type: "bytes";
            }, {
                readonly internalType: "bool";
                readonly name: "fromInternalBalance";
                readonly type: "bool";
            }];
            readonly internalType: "struct IVault.JoinPoolRequest";
            readonly name: "request";
            readonly type: "tuple";
        }];
        readonly name: "joinPool";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly components: readonly [{
                readonly internalType: "bytes32";
                readonly name: "poolId";
                readonly type: "bytes32";
            }, {
                readonly internalType: "enum IVault.SwapKind";
                readonly name: "kind";
                readonly type: "uint8";
            }, {
                readonly internalType: "contract IAsset";
                readonly name: "assetIn";
                readonly type: "address";
            }, {
                readonly internalType: "contract IAsset";
                readonly name: "assetOut";
                readonly type: "address";
            }, {
                readonly internalType: "uint256";
                readonly name: "amount";
                readonly type: "uint256";
            }, {
                readonly internalType: "bytes";
                readonly name: "userData";
                readonly type: "bytes";
            }];
            readonly internalType: "struct IVault.SingleSwap";
            readonly name: "singleSwap";
            readonly type: "tuple";
        }, {
            readonly components: readonly [{
                readonly internalType: "address";
                readonly name: "sender";
                readonly type: "address";
            }, {
                readonly internalType: "bool";
                readonly name: "fromInternalBalance";
                readonly type: "bool";
            }, {
                readonly internalType: "address payable";
                readonly name: "recipient";
                readonly type: "address";
            }, {
                readonly internalType: "bool";
                readonly name: "toInternalBalance";
                readonly type: "bool";
            }];
            readonly internalType: "struct IVault.FundManagement";
            readonly name: "funds";
            readonly type: "tuple";
        }, {
            readonly internalType: "uint256";
            readonly name: "limit";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "deadline";
            readonly type: "uint256";
        }];
        readonly name: "swap";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "swapAmount";
            readonly type: "uint256";
        }];
        readonly stateMutability: "payable";
        readonly type: "function";
    }, {
        readonly stateMutability: "payable";
        readonly type: "receive";
    }];
    static createInterface(): LidoRelayerInterface;
    static connect(address: string, signerOrProvider: Signer | Provider): LidoRelayer;
}

declare class LinearPool__factory {
    static readonly abi: readonly [{
        readonly inputs: readonly [{
            readonly internalType: "contract IVault";
            readonly name: "vault";
            readonly type: "address";
        }, {
            readonly internalType: "string";
            readonly name: "name";
            readonly type: "string";
        }, {
            readonly internalType: "string";
            readonly name: "symbol";
            readonly type: "string";
        }, {
            readonly internalType: "contract IERC20";
            readonly name: "mainToken";
            readonly type: "address";
        }, {
            readonly internalType: "contract IERC20";
            readonly name: "wrappedToken";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "upperTarget";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "swapFeePercentage";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "pauseWindowDuration";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "bufferPeriodDuration";
            readonly type: "uint256";
        }, {
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "constructor";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }, {
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "value";
            readonly type: "uint256";
        }];
        readonly name: "Approval";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "bool";
            readonly name: "paused";
            readonly type: "bool";
        }];
        readonly name: "PausedStateChanged";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "swapFeePercentage";
            readonly type: "uint256";
        }];
        readonly name: "SwapFeePercentageChanged";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "contract IERC20";
            readonly name: "token";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "lowerTarget";
            readonly type: "uint256";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "upperTarget";
            readonly type: "uint256";
        }];
        readonly name: "TargetsSet";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "from";
            readonly type: "address";
        }, {
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "to";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "value";
            readonly type: "uint256";
        }];
        readonly name: "Transfer";
        readonly type: "event";
    }, {
        readonly inputs: readonly [];
        readonly name: "DOMAIN_SEPARATOR";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }];
        readonly name: "allowance";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "approve";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "account";
            readonly type: "address";
        }];
        readonly name: "balanceOf";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "decimals";
        readonly outputs: readonly [{
            readonly internalType: "uint8";
            readonly name: "";
            readonly type: "uint8";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "decreaseAllowance";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes4";
            readonly name: "selector";
            readonly type: "bytes4";
        }];
        readonly name: "getActionId";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getAuthorizer";
        readonly outputs: readonly [{
            readonly internalType: "contract IAuthorizer";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getBptIndex";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getMainIndex";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getMainToken";
        readonly outputs: readonly [{
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getOwner";
        readonly outputs: readonly [{
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getPausedState";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "paused";
            readonly type: "bool";
        }, {
            readonly internalType: "uint256";
            readonly name: "pauseWindowEndTime";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "bufferPeriodEndTime";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getPoolId";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getRate";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getScalingFactors";
        readonly outputs: readonly [{
            readonly internalType: "uint256[]";
            readonly name: "";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getSwapFeePercentage";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getTargets";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "lowerTarget";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "upperTarget";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getVault";
        readonly outputs: readonly [{
            readonly internalType: "contract IVault";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getVirtualSupply";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getWrappedIndex";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getWrappedToken";
        readonly outputs: readonly [{
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getWrappedTokenRate";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "addedValue";
            readonly type: "uint256";
        }];
        readonly name: "increaseAllowance";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "initialize";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "name";
        readonly outputs: readonly [{
            readonly internalType: "string";
            readonly name: "";
            readonly type: "string";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }];
        readonly name: "nonces";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "balances";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "lastChangeBlock";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "protocolSwapFeePercentage";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes";
            readonly name: "userData";
            readonly type: "bytes";
        }];
        readonly name: "onExitPool";
        readonly outputs: readonly [{
            readonly internalType: "uint256[]";
            readonly name: "";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "balances";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "lastChangeBlock";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "protocolSwapFeePercentage";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes";
            readonly name: "userData";
            readonly type: "bytes";
        }];
        readonly name: "onJoinPool";
        readonly outputs: readonly [{
            readonly internalType: "uint256[]";
            readonly name: "";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly components: readonly [{
                readonly internalType: "enum IVault.SwapKind";
                readonly name: "kind";
                readonly type: "uint8";
            }, {
                readonly internalType: "contract IERC20";
                readonly name: "tokenIn";
                readonly type: "address";
            }, {
                readonly internalType: "contract IERC20";
                readonly name: "tokenOut";
                readonly type: "address";
            }, {
                readonly internalType: "uint256";
                readonly name: "amount";
                readonly type: "uint256";
            }, {
                readonly internalType: "bytes32";
                readonly name: "poolId";
                readonly type: "bytes32";
            }, {
                readonly internalType: "uint256";
                readonly name: "lastChangeBlock";
                readonly type: "uint256";
            }, {
                readonly internalType: "address";
                readonly name: "from";
                readonly type: "address";
            }, {
                readonly internalType: "address";
                readonly name: "to";
                readonly type: "address";
            }, {
                readonly internalType: "bytes";
                readonly name: "userData";
                readonly type: "bytes";
            }];
            readonly internalType: "struct IPoolSwapStructs.SwapRequest";
            readonly name: "request";
            readonly type: "tuple";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "balances";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "indexIn";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "indexOut";
            readonly type: "uint256";
        }];
        readonly name: "onSwap";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "value";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "deadline";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint8";
            readonly name: "v";
            readonly type: "uint8";
        }, {
            readonly internalType: "bytes32";
            readonly name: "r";
            readonly type: "bytes32";
        }, {
            readonly internalType: "bytes32";
            readonly name: "s";
            readonly type: "bytes32";
        }];
        readonly name: "permit";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "balances";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "lastChangeBlock";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "protocolSwapFeePercentage";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes";
            readonly name: "userData";
            readonly type: "bytes";
        }];
        readonly name: "queryExit";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "bptIn";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "amountsOut";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "balances";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "lastChangeBlock";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "protocolSwapFeePercentage";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes";
            readonly name: "userData";
            readonly type: "bytes";
        }];
        readonly name: "queryJoin";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "bptOut";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "amountsIn";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "contract IERC20";
            readonly name: "token";
            readonly type: "address";
        }, {
            readonly internalType: "bytes";
            readonly name: "poolConfig";
            readonly type: "bytes";
        }];
        readonly name: "setAssetManagerPoolConfig";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bool";
            readonly name: "paused";
            readonly type: "bool";
        }];
        readonly name: "setPaused";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "swapFeePercentage";
            readonly type: "uint256";
        }];
        readonly name: "setSwapFeePercentage";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "newLowerTarget";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "newUpperTarget";
            readonly type: "uint256";
        }];
        readonly name: "setTargets";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "symbol";
        readonly outputs: readonly [{
            readonly internalType: "string";
            readonly name: "";
            readonly type: "string";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "totalSupply";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "transfer";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "transferFrom";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }];
    static createInterface(): LinearPoolInterface$1;
    static connect(address: string, signerOrProvider: Signer | Provider): LinearPool;
}

declare class LiquidityGaugeV5__factory {
    static readonly abi: readonly [{
        readonly name: "Deposit";
        readonly inputs: readonly [{
            readonly name: "provider";
            readonly type: "address";
            readonly indexed: true;
        }, {
            readonly name: "value";
            readonly type: "uint256";
            readonly indexed: false;
        }];
        readonly anonymous: false;
        readonly type: "event";
    }, {
        readonly name: "Withdraw";
        readonly inputs: readonly [{
            readonly name: "provider";
            readonly type: "address";
            readonly indexed: true;
        }, {
            readonly name: "value";
            readonly type: "uint256";
            readonly indexed: false;
        }];
        readonly anonymous: false;
        readonly type: "event";
    }, {
        readonly name: "UpdateLiquidityLimit";
        readonly inputs: readonly [{
            readonly name: "user";
            readonly type: "address";
            readonly indexed: true;
        }, {
            readonly name: "original_balance";
            readonly type: "uint256";
            readonly indexed: false;
        }, {
            readonly name: "original_supply";
            readonly type: "uint256";
            readonly indexed: false;
        }, {
            readonly name: "working_balance";
            readonly type: "uint256";
            readonly indexed: false;
        }, {
            readonly name: "working_supply";
            readonly type: "uint256";
            readonly indexed: false;
        }];
        readonly anonymous: false;
        readonly type: "event";
    }, {
        readonly name: "Transfer";
        readonly inputs: readonly [{
            readonly name: "_from";
            readonly type: "address";
            readonly indexed: true;
        }, {
            readonly name: "_to";
            readonly type: "address";
            readonly indexed: true;
        }, {
            readonly name: "_value";
            readonly type: "uint256";
            readonly indexed: false;
        }];
        readonly anonymous: false;
        readonly type: "event";
    }, {
        readonly name: "Approval";
        readonly inputs: readonly [{
            readonly name: "_owner";
            readonly type: "address";
            readonly indexed: true;
        }, {
            readonly name: "_spender";
            readonly type: "address";
            readonly indexed: true;
        }, {
            readonly name: "_value";
            readonly type: "uint256";
            readonly indexed: false;
        }];
        readonly anonymous: false;
        readonly type: "event";
    }, {
        readonly stateMutability: "nonpayable";
        readonly type: "constructor";
        readonly inputs: readonly [{
            readonly name: "minter";
            readonly type: "address";
        }, {
            readonly name: "veBoostProxy";
            readonly type: "address";
        }];
        readonly outputs: readonly [];
    }, {
        readonly stateMutability: "nonpayable";
        readonly type: "function";
        readonly name: "deposit";
        readonly inputs: readonly [{
            readonly name: "_value";
            readonly type: "uint256";
        }];
        readonly outputs: readonly [];
    }, {
        readonly stateMutability: "nonpayable";
        readonly type: "function";
        readonly name: "deposit";
        readonly inputs: readonly [{
            readonly name: "_value";
            readonly type: "uint256";
        }, {
            readonly name: "_addr";
            readonly type: "address";
        }];
        readonly outputs: readonly [];
    }, {
        readonly stateMutability: "nonpayable";
        readonly type: "function";
        readonly name: "deposit";
        readonly inputs: readonly [{
            readonly name: "_value";
            readonly type: "uint256";
        }, {
            readonly name: "_addr";
            readonly type: "address";
        }, {
            readonly name: "_claim_rewards";
            readonly type: "bool";
        }];
        readonly outputs: readonly [];
    }, {
        readonly stateMutability: "nonpayable";
        readonly type: "function";
        readonly name: "withdraw";
        readonly inputs: readonly [{
            readonly name: "_value";
            readonly type: "uint256";
        }];
        readonly outputs: readonly [];
    }, {
        readonly stateMutability: "nonpayable";
        readonly type: "function";
        readonly name: "withdraw";
        readonly inputs: readonly [{
            readonly name: "_value";
            readonly type: "uint256";
        }, {
            readonly name: "_claim_rewards";
            readonly type: "bool";
        }];
        readonly outputs: readonly [];
    }, {
        readonly stateMutability: "nonpayable";
        readonly type: "function";
        readonly name: "claim_rewards";
        readonly inputs: readonly [];
        readonly outputs: readonly [];
    }, {
        readonly stateMutability: "nonpayable";
        readonly type: "function";
        readonly name: "claim_rewards";
        readonly inputs: readonly [{
            readonly name: "_addr";
            readonly type: "address";
        }];
        readonly outputs: readonly [];
    }, {
        readonly stateMutability: "nonpayable";
        readonly type: "function";
        readonly name: "claim_rewards";
        readonly inputs: readonly [{
            readonly name: "_addr";
            readonly type: "address";
        }, {
            readonly name: "_receiver";
            readonly type: "address";
        }];
        readonly outputs: readonly [];
    }, {
        readonly stateMutability: "nonpayable";
        readonly type: "function";
        readonly name: "transferFrom";
        readonly inputs: readonly [{
            readonly name: "_from";
            readonly type: "address";
        }, {
            readonly name: "_to";
            readonly type: "address";
        }, {
            readonly name: "_value";
            readonly type: "uint256";
        }];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "bool";
        }];
    }, {
        readonly stateMutability: "nonpayable";
        readonly type: "function";
        readonly name: "transfer";
        readonly inputs: readonly [{
            readonly name: "_to";
            readonly type: "address";
        }, {
            readonly name: "_value";
            readonly type: "uint256";
        }];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "bool";
        }];
    }, {
        readonly stateMutability: "nonpayable";
        readonly type: "function";
        readonly name: "approve";
        readonly inputs: readonly [{
            readonly name: "_spender";
            readonly type: "address";
        }, {
            readonly name: "_value";
            readonly type: "uint256";
        }];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "bool";
        }];
    }, {
        readonly stateMutability: "nonpayable";
        readonly type: "function";
        readonly name: "permit";
        readonly inputs: readonly [{
            readonly name: "_owner";
            readonly type: "address";
        }, {
            readonly name: "_spender";
            readonly type: "address";
        }, {
            readonly name: "_value";
            readonly type: "uint256";
        }, {
            readonly name: "_deadline";
            readonly type: "uint256";
        }, {
            readonly name: "_v";
            readonly type: "uint8";
        }, {
            readonly name: "_r";
            readonly type: "bytes32";
        }, {
            readonly name: "_s";
            readonly type: "bytes32";
        }];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "bool";
        }];
    }, {
        readonly stateMutability: "nonpayable";
        readonly type: "function";
        readonly name: "increaseAllowance";
        readonly inputs: readonly [{
            readonly name: "_spender";
            readonly type: "address";
        }, {
            readonly name: "_added_value";
            readonly type: "uint256";
        }];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "bool";
        }];
    }, {
        readonly stateMutability: "nonpayable";
        readonly type: "function";
        readonly name: "decreaseAllowance";
        readonly inputs: readonly [{
            readonly name: "_spender";
            readonly type: "address";
        }, {
            readonly name: "_subtracted_value";
            readonly type: "uint256";
        }];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "bool";
        }];
    }, {
        readonly stateMutability: "nonpayable";
        readonly type: "function";
        readonly name: "user_checkpoint";
        readonly inputs: readonly [{
            readonly name: "addr";
            readonly type: "address";
        }];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "bool";
        }];
    }, {
        readonly stateMutability: "nonpayable";
        readonly type: "function";
        readonly name: "set_rewards_receiver";
        readonly inputs: readonly [{
            readonly name: "_receiver";
            readonly type: "address";
        }];
        readonly outputs: readonly [];
    }, {
        readonly stateMutability: "nonpayable";
        readonly type: "function";
        readonly name: "kick";
        readonly inputs: readonly [{
            readonly name: "addr";
            readonly type: "address";
        }];
        readonly outputs: readonly [];
    }, {
        readonly stateMutability: "nonpayable";
        readonly type: "function";
        readonly name: "deposit_reward_token";
        readonly inputs: readonly [{
            readonly name: "_reward_token";
            readonly type: "address";
        }, {
            readonly name: "_amount";
            readonly type: "uint256";
        }];
        readonly outputs: readonly [];
    }, {
        readonly stateMutability: "nonpayable";
        readonly type: "function";
        readonly name: "add_reward";
        readonly inputs: readonly [{
            readonly name: "_reward_token";
            readonly type: "address";
        }, {
            readonly name: "_distributor";
            readonly type: "address";
        }];
        readonly outputs: readonly [];
    }, {
        readonly stateMutability: "nonpayable";
        readonly type: "function";
        readonly name: "set_reward_distributor";
        readonly inputs: readonly [{
            readonly name: "_reward_token";
            readonly type: "address";
        }, {
            readonly name: "_distributor";
            readonly type: "address";
        }];
        readonly outputs: readonly [];
    }, {
        readonly stateMutability: "nonpayable";
        readonly type: "function";
        readonly name: "set_killed";
        readonly inputs: readonly [{
            readonly name: "_is_killed";
            readonly type: "bool";
        }];
        readonly outputs: readonly [];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "claimed_reward";
        readonly inputs: readonly [{
            readonly name: "_addr";
            readonly type: "address";
        }, {
            readonly name: "_token";
            readonly type: "address";
        }];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "uint256";
        }];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "claimable_reward";
        readonly inputs: readonly [{
            readonly name: "_user";
            readonly type: "address";
        }, {
            readonly name: "_reward_token";
            readonly type: "address";
        }];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "uint256";
        }];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "claimable_reward_write";
        readonly inputs: readonly [{
            readonly name: "_addr";
            readonly type: "address";
        }, {
            readonly name: "_token";
            readonly type: "address";
        }];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "uint256";
        }];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "claimable_tokens";
        readonly inputs: readonly [{
            readonly name: "addr";
            readonly type: "address";
        }];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "uint256";
        }];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "integrate_checkpoint";
        readonly inputs: readonly [];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "uint256";
        }];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "future_epoch_time";
        readonly inputs: readonly [];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "uint256";
        }];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "inflation_rate";
        readonly inputs: readonly [];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "uint256";
        }];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "decimals";
        readonly inputs: readonly [];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "uint256";
        }];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "version";
        readonly inputs: readonly [];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "string";
        }];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "allowance";
        readonly inputs: readonly [{
            readonly name: "owner";
            readonly type: "address";
        }, {
            readonly name: "spender";
            readonly type: "address";
        }];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "uint256";
        }];
    }, {
        readonly stateMutability: "nonpayable";
        readonly type: "function";
        readonly name: "initialize";
        readonly inputs: readonly [{
            readonly name: "_lp_token";
            readonly type: "address";
        }];
        readonly outputs: readonly [];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "balanceOf";
        readonly inputs: readonly [{
            readonly name: "arg0";
            readonly type: "address";
        }];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "uint256";
        }];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "totalSupply";
        readonly inputs: readonly [];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "uint256";
        }];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "name";
        readonly inputs: readonly [];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "string";
        }];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "symbol";
        readonly inputs: readonly [];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "string";
        }];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "DOMAIN_SEPARATOR";
        readonly inputs: readonly [];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "bytes32";
        }];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "nonces";
        readonly inputs: readonly [{
            readonly name: "arg0";
            readonly type: "address";
        }];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "uint256";
        }];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "factory";
        readonly inputs: readonly [];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "address";
        }];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "lp_token";
        readonly inputs: readonly [];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "address";
        }];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "is_killed";
        readonly inputs: readonly [];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "bool";
        }];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "reward_count";
        readonly inputs: readonly [];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "uint256";
        }];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "reward_data";
        readonly inputs: readonly [{
            readonly name: "arg0";
            readonly type: "address";
        }];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "tuple";
            readonly components: readonly [{
                readonly name: "token";
                readonly type: "address";
            }, {
                readonly name: "distributor";
                readonly type: "address";
            }, {
                readonly name: "period_finish";
                readonly type: "uint256";
            }, {
                readonly name: "rate";
                readonly type: "uint256";
            }, {
                readonly name: "last_update";
                readonly type: "uint256";
            }, {
                readonly name: "integral";
                readonly type: "uint256";
            }];
        }];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "rewards_receiver";
        readonly inputs: readonly [{
            readonly name: "arg0";
            readonly type: "address";
        }];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "address";
        }];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "reward_integral_for";
        readonly inputs: readonly [{
            readonly name: "arg0";
            readonly type: "address";
        }, {
            readonly name: "arg1";
            readonly type: "address";
        }];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "uint256";
        }];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "working_balances";
        readonly inputs: readonly [{
            readonly name: "arg0";
            readonly type: "address";
        }];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "uint256";
        }];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "working_supply";
        readonly inputs: readonly [];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "uint256";
        }];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "integrate_inv_supply_of";
        readonly inputs: readonly [{
            readonly name: "arg0";
            readonly type: "address";
        }];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "uint256";
        }];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "integrate_checkpoint_of";
        readonly inputs: readonly [{
            readonly name: "arg0";
            readonly type: "address";
        }];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "uint256";
        }];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "integrate_fraction";
        readonly inputs: readonly [{
            readonly name: "arg0";
            readonly type: "address";
        }];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "uint256";
        }];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "period";
        readonly inputs: readonly [];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "int128";
        }];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "reward_tokens";
        readonly inputs: readonly [{
            readonly name: "arg0";
            readonly type: "uint256";
        }];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "address";
        }];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "period_timestamp";
        readonly inputs: readonly [{
            readonly name: "arg0";
            readonly type: "uint256";
        }];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "uint256";
        }];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "integrate_inv_supply";
        readonly inputs: readonly [{
            readonly name: "arg0";
            readonly type: "uint256";
        }];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "uint256";
        }];
    }];
    static createInterface(): LiquidityGaugeV5Interface;
    static connect(address: string, signerOrProvider: Signer | Provider): LiquidityGaugeV5;
}

declare class Multicall__factory {
    static readonly abi: readonly [{
        readonly constant: false;
        readonly inputs: readonly [{
            readonly components: readonly [{
                readonly name: "target";
                readonly type: "address";
            }, {
                readonly name: "callData";
                readonly type: "bytes";
            }];
            readonly name: "calls";
            readonly type: "tuple[]";
        }];
        readonly name: "aggregate";
        readonly outputs: readonly [{
            readonly name: "blockNumber";
            readonly type: "uint256";
        }, {
            readonly name: "returnData";
            readonly type: "bytes[]";
        }];
        readonly payable: false;
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }];
    static createInterface(): MulticallInterface;
    static connect(address: string, signerOrProvider: Signer | Provider): Multicall;
}

declare class Multicall3__factory {
    static readonly abi: readonly [{
        readonly inputs: readonly [{
            readonly components: readonly [{
                readonly internalType: "address";
                readonly name: "target";
                readonly type: "address";
            }, {
                readonly internalType: "bytes";
                readonly name: "callData";
                readonly type: "bytes";
            }];
            readonly internalType: "struct Multicall3.Call[]";
            readonly name: "calls";
            readonly type: "tuple[]";
        }];
        readonly name: "aggregate";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "blockNumber";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes[]";
            readonly name: "returnData";
            readonly type: "bytes[]";
        }];
        readonly stateMutability: "payable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly components: readonly [{
                readonly internalType: "address";
                readonly name: "target";
                readonly type: "address";
            }, {
                readonly internalType: "bool";
                readonly name: "allowFailure";
                readonly type: "bool";
            }, {
                readonly internalType: "bytes";
                readonly name: "callData";
                readonly type: "bytes";
            }];
            readonly internalType: "struct Multicall3.Call3[]";
            readonly name: "calls";
            readonly type: "tuple[]";
        }];
        readonly name: "aggregate3";
        readonly outputs: readonly [{
            readonly components: readonly [{
                readonly internalType: "bool";
                readonly name: "success";
                readonly type: "bool";
            }, {
                readonly internalType: "bytes";
                readonly name: "returnData";
                readonly type: "bytes";
            }];
            readonly internalType: "struct Multicall3.Result[]";
            readonly name: "returnData";
            readonly type: "tuple[]";
        }];
        readonly stateMutability: "payable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly components: readonly [{
                readonly internalType: "address";
                readonly name: "target";
                readonly type: "address";
            }, {
                readonly internalType: "bool";
                readonly name: "allowFailure";
                readonly type: "bool";
            }, {
                readonly internalType: "uint256";
                readonly name: "value";
                readonly type: "uint256";
            }, {
                readonly internalType: "bytes";
                readonly name: "callData";
                readonly type: "bytes";
            }];
            readonly internalType: "struct Multicall3.Call3Value[]";
            readonly name: "calls";
            readonly type: "tuple[]";
        }];
        readonly name: "aggregate3Value";
        readonly outputs: readonly [{
            readonly components: readonly [{
                readonly internalType: "bool";
                readonly name: "success";
                readonly type: "bool";
            }, {
                readonly internalType: "bytes";
                readonly name: "returnData";
                readonly type: "bytes";
            }];
            readonly internalType: "struct Multicall3.Result[]";
            readonly name: "returnData";
            readonly type: "tuple[]";
        }];
        readonly stateMutability: "payable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly components: readonly [{
                readonly internalType: "address";
                readonly name: "target";
                readonly type: "address";
            }, {
                readonly internalType: "bytes";
                readonly name: "callData";
                readonly type: "bytes";
            }];
            readonly internalType: "struct Multicall3.Call[]";
            readonly name: "calls";
            readonly type: "tuple[]";
        }];
        readonly name: "blockAndAggregate";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "blockNumber";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes32";
            readonly name: "blockHash";
            readonly type: "bytes32";
        }, {
            readonly components: readonly [{
                readonly internalType: "bool";
                readonly name: "success";
                readonly type: "bool";
            }, {
                readonly internalType: "bytes";
                readonly name: "returnData";
                readonly type: "bytes";
            }];
            readonly internalType: "struct Multicall3.Result[]";
            readonly name: "returnData";
            readonly type: "tuple[]";
        }];
        readonly stateMutability: "payable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getBasefee";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "basefee";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "blockNumber";
            readonly type: "uint256";
        }];
        readonly name: "getBlockHash";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "blockHash";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getBlockNumber";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "blockNumber";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getChainId";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "chainid";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getCurrentBlockCoinbase";
        readonly outputs: readonly [{
            readonly internalType: "address";
            readonly name: "coinbase";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getCurrentBlockDifficulty";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "difficulty";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getCurrentBlockGasLimit";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "gaslimit";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getCurrentBlockTimestamp";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "timestamp";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "addr";
            readonly type: "address";
        }];
        readonly name: "getEthBalance";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "balance";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getLastBlockHash";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "blockHash";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bool";
            readonly name: "requireSuccess";
            readonly type: "bool";
        }, {
            readonly components: readonly [{
                readonly internalType: "address";
                readonly name: "target";
                readonly type: "address";
            }, {
                readonly internalType: "bytes";
                readonly name: "callData";
                readonly type: "bytes";
            }];
            readonly internalType: "struct Multicall3.Call[]";
            readonly name: "calls";
            readonly type: "tuple[]";
        }];
        readonly name: "tryAggregate";
        readonly outputs: readonly [{
            readonly components: readonly [{
                readonly internalType: "bool";
                readonly name: "success";
                readonly type: "bool";
            }, {
                readonly internalType: "bytes";
                readonly name: "returnData";
                readonly type: "bytes";
            }];
            readonly internalType: "struct Multicall3.Result[]";
            readonly name: "returnData";
            readonly type: "tuple[]";
        }];
        readonly stateMutability: "payable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bool";
            readonly name: "requireSuccess";
            readonly type: "bool";
        }, {
            readonly components: readonly [{
                readonly internalType: "address";
                readonly name: "target";
                readonly type: "address";
            }, {
                readonly internalType: "bytes";
                readonly name: "callData";
                readonly type: "bytes";
            }];
            readonly internalType: "struct Multicall3.Call[]";
            readonly name: "calls";
            readonly type: "tuple[]";
        }];
        readonly name: "tryBlockAndAggregate";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "blockNumber";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes32";
            readonly name: "blockHash";
            readonly type: "bytes32";
        }, {
            readonly components: readonly [{
                readonly internalType: "bool";
                readonly name: "success";
                readonly type: "bool";
            }, {
                readonly internalType: "bytes";
                readonly name: "returnData";
                readonly type: "bytes";
            }];
            readonly internalType: "struct Multicall3.Result[]";
            readonly name: "returnData";
            readonly type: "tuple[]";
        }];
        readonly stateMutability: "payable";
        readonly type: "function";
    }];
    static createInterface(): Multicall3Interface;
    static connect(address: string, signerOrProvider: Signer | Provider): Multicall3;
}

declare class StablePool__factory {
    static readonly abi: readonly [{
        readonly inputs: readonly [{
            readonly internalType: "contract IVault";
            readonly name: "vault";
            readonly type: "address";
        }, {
            readonly internalType: "string";
            readonly name: "name";
            readonly type: "string";
        }, {
            readonly internalType: "string";
            readonly name: "symbol";
            readonly type: "string";
        }, {
            readonly internalType: "contract IERC20[]";
            readonly name: "tokens";
            readonly type: "address[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "amplificationParameter";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "swapFeePercentage";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "pauseWindowDuration";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "bufferPeriodDuration";
            readonly type: "uint256";
        }, {
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "constructor";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "startValue";
            readonly type: "uint256";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "endValue";
            readonly type: "uint256";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "startTime";
            readonly type: "uint256";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "endTime";
            readonly type: "uint256";
        }];
        readonly name: "AmpUpdateStarted";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "currentValue";
            readonly type: "uint256";
        }];
        readonly name: "AmpUpdateStopped";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }, {
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "value";
            readonly type: "uint256";
        }];
        readonly name: "Approval";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "bool";
            readonly name: "paused";
            readonly type: "bool";
        }];
        readonly name: "PausedStateChanged";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "swapFeePercentage";
            readonly type: "uint256";
        }];
        readonly name: "SwapFeePercentageChanged";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "from";
            readonly type: "address";
        }, {
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "to";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "value";
            readonly type: "uint256";
        }];
        readonly name: "Transfer";
        readonly type: "event";
    }, {
        readonly inputs: readonly [];
        readonly name: "DOMAIN_SEPARATOR";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }];
        readonly name: "allowance";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "approve";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "account";
            readonly type: "address";
        }];
        readonly name: "balanceOf";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "decimals";
        readonly outputs: readonly [{
            readonly internalType: "uint8";
            readonly name: "";
            readonly type: "uint8";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "decreaseAllowance";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes4";
            readonly name: "selector";
            readonly type: "bytes4";
        }];
        readonly name: "getActionId";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getAmplificationParameter";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "value";
            readonly type: "uint256";
        }, {
            readonly internalType: "bool";
            readonly name: "isUpdating";
            readonly type: "bool";
        }, {
            readonly internalType: "uint256";
            readonly name: "precision";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getAuthorizer";
        readonly outputs: readonly [{
            readonly internalType: "contract IAuthorizer";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getOwner";
        readonly outputs: readonly [{
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getPausedState";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "paused";
            readonly type: "bool";
        }, {
            readonly internalType: "uint256";
            readonly name: "pauseWindowEndTime";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "bufferPeriodEndTime";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getPoolId";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getRate";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getSwapFeePercentage";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getVault";
        readonly outputs: readonly [{
            readonly internalType: "contract IVault";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "addedValue";
            readonly type: "uint256";
        }];
        readonly name: "increaseAllowance";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "name";
        readonly outputs: readonly [{
            readonly internalType: "string";
            readonly name: "";
            readonly type: "string";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }];
        readonly name: "nonces";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "balances";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "lastChangeBlock";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "protocolSwapFeePercentage";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes";
            readonly name: "userData";
            readonly type: "bytes";
        }];
        readonly name: "onExitPool";
        readonly outputs: readonly [{
            readonly internalType: "uint256[]";
            readonly name: "";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "balances";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "lastChangeBlock";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "protocolSwapFeePercentage";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes";
            readonly name: "userData";
            readonly type: "bytes";
        }];
        readonly name: "onJoinPool";
        readonly outputs: readonly [{
            readonly internalType: "uint256[]";
            readonly name: "";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly components: readonly [{
                readonly internalType: "enum IVault.SwapKind";
                readonly name: "kind";
                readonly type: "uint8";
            }, {
                readonly internalType: "contract IERC20";
                readonly name: "tokenIn";
                readonly type: "address";
            }, {
                readonly internalType: "contract IERC20";
                readonly name: "tokenOut";
                readonly type: "address";
            }, {
                readonly internalType: "uint256";
                readonly name: "amount";
                readonly type: "uint256";
            }, {
                readonly internalType: "bytes32";
                readonly name: "poolId";
                readonly type: "bytes32";
            }, {
                readonly internalType: "uint256";
                readonly name: "lastChangeBlock";
                readonly type: "uint256";
            }, {
                readonly internalType: "address";
                readonly name: "from";
                readonly type: "address";
            }, {
                readonly internalType: "address";
                readonly name: "to";
                readonly type: "address";
            }, {
                readonly internalType: "bytes";
                readonly name: "userData";
                readonly type: "bytes";
            }];
            readonly internalType: "struct IPoolSwapStructs.SwapRequest";
            readonly name: "swapRequest";
            readonly type: "tuple";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "balances";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "indexIn";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "indexOut";
            readonly type: "uint256";
        }];
        readonly name: "onSwap";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly components: readonly [{
                readonly internalType: "enum IVault.SwapKind";
                readonly name: "kind";
                readonly type: "uint8";
            }, {
                readonly internalType: "contract IERC20";
                readonly name: "tokenIn";
                readonly type: "address";
            }, {
                readonly internalType: "contract IERC20";
                readonly name: "tokenOut";
                readonly type: "address";
            }, {
                readonly internalType: "uint256";
                readonly name: "amount";
                readonly type: "uint256";
            }, {
                readonly internalType: "bytes32";
                readonly name: "poolId";
                readonly type: "bytes32";
            }, {
                readonly internalType: "uint256";
                readonly name: "lastChangeBlock";
                readonly type: "uint256";
            }, {
                readonly internalType: "address";
                readonly name: "from";
                readonly type: "address";
            }, {
                readonly internalType: "address";
                readonly name: "to";
                readonly type: "address";
            }, {
                readonly internalType: "bytes";
                readonly name: "userData";
                readonly type: "bytes";
            }];
            readonly internalType: "struct IPoolSwapStructs.SwapRequest";
            readonly name: "request";
            readonly type: "tuple";
        }, {
            readonly internalType: "uint256";
            readonly name: "balanceTokenIn";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "balanceTokenOut";
            readonly type: "uint256";
        }];
        readonly name: "onSwap";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "value";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "deadline";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint8";
            readonly name: "v";
            readonly type: "uint8";
        }, {
            readonly internalType: "bytes32";
            readonly name: "r";
            readonly type: "bytes32";
        }, {
            readonly internalType: "bytes32";
            readonly name: "s";
            readonly type: "bytes32";
        }];
        readonly name: "permit";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "balances";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "lastChangeBlock";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "protocolSwapFeePercentage";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes";
            readonly name: "userData";
            readonly type: "bytes";
        }];
        readonly name: "queryExit";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "bptIn";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "amountsOut";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "balances";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "lastChangeBlock";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "protocolSwapFeePercentage";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes";
            readonly name: "userData";
            readonly type: "bytes";
        }];
        readonly name: "queryJoin";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "bptOut";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "amountsIn";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "contract IERC20";
            readonly name: "token";
            readonly type: "address";
        }, {
            readonly internalType: "bytes";
            readonly name: "poolConfig";
            readonly type: "bytes";
        }];
        readonly name: "setAssetManagerPoolConfig";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bool";
            readonly name: "paused";
            readonly type: "bool";
        }];
        readonly name: "setPaused";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "swapFeePercentage";
            readonly type: "uint256";
        }];
        readonly name: "setSwapFeePercentage";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "rawEndValue";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "endTime";
            readonly type: "uint256";
        }];
        readonly name: "startAmplificationParameterUpdate";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "stopAmplificationParameterUpdate";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "symbol";
        readonly outputs: readonly [{
            readonly internalType: "string";
            readonly name: "";
            readonly type: "string";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "totalSupply";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "transfer";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "transferFrom";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }];
    static createInterface(): StablePoolInterface;
    static connect(address: string, signerOrProvider: Signer | Provider): StablePool;
}

declare class StaticATokenRateProvider__factory {
    static readonly abi: readonly [{
        readonly inputs: readonly [{
            readonly internalType: "contract IStaticAToken";
            readonly name: "_waToken";
            readonly type: "address";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "constructor";
    }, {
        readonly inputs: readonly [];
        readonly name: "getRate";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "waToken";
        readonly outputs: readonly [{
            readonly internalType: "contract IStaticAToken";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }];
    static createInterface(): StaticATokenRateProviderInterface;
    static connect(address: string, signerOrProvider: Signer | Provider): StaticATokenRateProvider;
}

declare class Vault__factory {
    static readonly abi: readonly [{
        readonly inputs: readonly [{
            readonly internalType: "contract IAuthorizer";
            readonly name: "authorizer";
            readonly type: "address";
        }, {
            readonly internalType: "contract IWETH";
            readonly name: "weth";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "pauseWindowDuration";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "bufferPeriodDuration";
            readonly type: "uint256";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "constructor";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "contract IAuthorizer";
            readonly name: "newAuthorizer";
            readonly type: "address";
        }];
        readonly name: "AuthorizerChanged";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "contract IERC20";
            readonly name: "token";
            readonly type: "address";
        }, {
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "ExternalBalanceTransfer";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "contract IFlashLoanRecipient";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly indexed: true;
            readonly internalType: "contract IERC20";
            readonly name: "token";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "feeAmount";
            readonly type: "uint256";
        }];
        readonly name: "FlashLoan";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "user";
            readonly type: "address";
        }, {
            readonly indexed: true;
            readonly internalType: "contract IERC20";
            readonly name: "token";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly internalType: "int256";
            readonly name: "delta";
            readonly type: "int256";
        }];
        readonly name: "InternalBalanceChanged";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "bool";
            readonly name: "paused";
            readonly type: "bool";
        }];
        readonly name: "PausedStateChanged";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "liquidityProvider";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly internalType: "contract IERC20[]";
            readonly name: "tokens";
            readonly type: "address[]";
        }, {
            readonly indexed: false;
            readonly internalType: "int256[]";
            readonly name: "deltas";
            readonly type: "int256[]";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256[]";
            readonly name: "protocolFeeAmounts";
            readonly type: "uint256[]";
        }];
        readonly name: "PoolBalanceChanged";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "assetManager";
            readonly type: "address";
        }, {
            readonly indexed: true;
            readonly internalType: "contract IERC20";
            readonly name: "token";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly internalType: "int256";
            readonly name: "cashDelta";
            readonly type: "int256";
        }, {
            readonly indexed: false;
            readonly internalType: "int256";
            readonly name: "managedDelta";
            readonly type: "int256";
        }];
        readonly name: "PoolBalanceManaged";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "poolAddress";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly internalType: "enum IVault.PoolSpecialization";
            readonly name: "specialization";
            readonly type: "uint8";
        }];
        readonly name: "PoolRegistered";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "relayer";
            readonly type: "address";
        }, {
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly internalType: "bool";
            readonly name: "approved";
            readonly type: "bool";
        }];
        readonly name: "RelayerApprovalChanged";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly indexed: true;
            readonly internalType: "contract IERC20";
            readonly name: "tokenIn";
            readonly type: "address";
        }, {
            readonly indexed: true;
            readonly internalType: "contract IERC20";
            readonly name: "tokenOut";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "amountIn";
            readonly type: "uint256";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "amountOut";
            readonly type: "uint256";
        }];
        readonly name: "Swap";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly indexed: false;
            readonly internalType: "contract IERC20[]";
            readonly name: "tokens";
            readonly type: "address[]";
        }];
        readonly name: "TokensDeregistered";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly indexed: false;
            readonly internalType: "contract IERC20[]";
            readonly name: "tokens";
            readonly type: "address[]";
        }, {
            readonly indexed: false;
            readonly internalType: "address[]";
            readonly name: "assetManagers";
            readonly type: "address[]";
        }];
        readonly name: "TokensRegistered";
        readonly type: "event";
    }, {
        readonly inputs: readonly [];
        readonly name: "WETH";
        readonly outputs: readonly [{
            readonly internalType: "contract IWETH";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "enum IVault.SwapKind";
            readonly name: "kind";
            readonly type: "uint8";
        }, {
            readonly components: readonly [{
                readonly internalType: "bytes32";
                readonly name: "poolId";
                readonly type: "bytes32";
            }, {
                readonly internalType: "uint256";
                readonly name: "assetInIndex";
                readonly type: "uint256";
            }, {
                readonly internalType: "uint256";
                readonly name: "assetOutIndex";
                readonly type: "uint256";
            }, {
                readonly internalType: "uint256";
                readonly name: "amount";
                readonly type: "uint256";
            }, {
                readonly internalType: "bytes";
                readonly name: "userData";
                readonly type: "bytes";
            }];
            readonly internalType: "struct IVault.BatchSwapStep[]";
            readonly name: "swaps";
            readonly type: "tuple[]";
        }, {
            readonly internalType: "contract IAsset[]";
            readonly name: "assets";
            readonly type: "address[]";
        }, {
            readonly components: readonly [{
                readonly internalType: "address";
                readonly name: "sender";
                readonly type: "address";
            }, {
                readonly internalType: "bool";
                readonly name: "fromInternalBalance";
                readonly type: "bool";
            }, {
                readonly internalType: "address payable";
                readonly name: "recipient";
                readonly type: "address";
            }, {
                readonly internalType: "bool";
                readonly name: "toInternalBalance";
                readonly type: "bool";
            }];
            readonly internalType: "struct IVault.FundManagement";
            readonly name: "funds";
            readonly type: "tuple";
        }, {
            readonly internalType: "int256[]";
            readonly name: "limits";
            readonly type: "int256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "deadline";
            readonly type: "uint256";
        }];
        readonly name: "batchSwap";
        readonly outputs: readonly [{
            readonly internalType: "int256[]";
            readonly name: "assetDeltas";
            readonly type: "int256[]";
        }];
        readonly stateMutability: "payable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly internalType: "contract IERC20[]";
            readonly name: "tokens";
            readonly type: "address[]";
        }];
        readonly name: "deregisterTokens";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address payable";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly components: readonly [{
                readonly internalType: "contract IAsset[]";
                readonly name: "assets";
                readonly type: "address[]";
            }, {
                readonly internalType: "uint256[]";
                readonly name: "minAmountsOut";
                readonly type: "uint256[]";
            }, {
                readonly internalType: "bytes";
                readonly name: "userData";
                readonly type: "bytes";
            }, {
                readonly internalType: "bool";
                readonly name: "toInternalBalance";
                readonly type: "bool";
            }];
            readonly internalType: "struct IVault.ExitPoolRequest";
            readonly name: "request";
            readonly type: "tuple";
        }];
        readonly name: "exitPool";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "contract IFlashLoanRecipient";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "contract IERC20[]";
            readonly name: "tokens";
            readonly type: "address[]";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "amounts";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "bytes";
            readonly name: "userData";
            readonly type: "bytes";
        }];
        readonly name: "flashLoan";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes4";
            readonly name: "selector";
            readonly type: "bytes4";
        }];
        readonly name: "getActionId";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getAuthorizer";
        readonly outputs: readonly [{
            readonly internalType: "contract IAuthorizer";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getDomainSeparator";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "user";
            readonly type: "address";
        }, {
            readonly internalType: "contract IERC20[]";
            readonly name: "tokens";
            readonly type: "address[]";
        }];
        readonly name: "getInternalBalance";
        readonly outputs: readonly [{
            readonly internalType: "uint256[]";
            readonly name: "balances";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "user";
            readonly type: "address";
        }];
        readonly name: "getNextNonce";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getPausedState";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "paused";
            readonly type: "bool";
        }, {
            readonly internalType: "uint256";
            readonly name: "pauseWindowEndTime";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "bufferPeriodEndTime";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }];
        readonly name: "getPool";
        readonly outputs: readonly [{
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }, {
            readonly internalType: "enum IVault.PoolSpecialization";
            readonly name: "";
            readonly type: "uint8";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly internalType: "contract IERC20";
            readonly name: "token";
            readonly type: "address";
        }];
        readonly name: "getPoolTokenInfo";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "cash";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "managed";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "lastChangeBlock";
            readonly type: "uint256";
        }, {
            readonly internalType: "address";
            readonly name: "assetManager";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }];
        readonly name: "getPoolTokens";
        readonly outputs: readonly [{
            readonly internalType: "contract IERC20[]";
            readonly name: "tokens";
            readonly type: "address[]";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "balances";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "lastChangeBlock";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getProtocolFeesCollector";
        readonly outputs: readonly [{
            readonly internalType: "contract ProtocolFeesCollector";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "user";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "relayer";
            readonly type: "address";
        }];
        readonly name: "hasApprovedRelayer";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly components: readonly [{
                readonly internalType: "contract IAsset[]";
                readonly name: "assets";
                readonly type: "address[]";
            }, {
                readonly internalType: "uint256[]";
                readonly name: "maxAmountsIn";
                readonly type: "uint256[]";
            }, {
                readonly internalType: "bytes";
                readonly name: "userData";
                readonly type: "bytes";
            }, {
                readonly internalType: "bool";
                readonly name: "fromInternalBalance";
                readonly type: "bool";
            }];
            readonly internalType: "struct IVault.JoinPoolRequest";
            readonly name: "request";
            readonly type: "tuple";
        }];
        readonly name: "joinPool";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly components: readonly [{
                readonly internalType: "enum IVault.PoolBalanceOpKind";
                readonly name: "kind";
                readonly type: "uint8";
            }, {
                readonly internalType: "bytes32";
                readonly name: "poolId";
                readonly type: "bytes32";
            }, {
                readonly internalType: "contract IERC20";
                readonly name: "token";
                readonly type: "address";
            }, {
                readonly internalType: "uint256";
                readonly name: "amount";
                readonly type: "uint256";
            }];
            readonly internalType: "struct IVault.PoolBalanceOp[]";
            readonly name: "ops";
            readonly type: "tuple[]";
        }];
        readonly name: "managePoolBalance";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly components: readonly [{
                readonly internalType: "enum IVault.UserBalanceOpKind";
                readonly name: "kind";
                readonly type: "uint8";
            }, {
                readonly internalType: "contract IAsset";
                readonly name: "asset";
                readonly type: "address";
            }, {
                readonly internalType: "uint256";
                readonly name: "amount";
                readonly type: "uint256";
            }, {
                readonly internalType: "address";
                readonly name: "sender";
                readonly type: "address";
            }, {
                readonly internalType: "address payable";
                readonly name: "recipient";
                readonly type: "address";
            }];
            readonly internalType: "struct IVault.UserBalanceOp[]";
            readonly name: "ops";
            readonly type: "tuple[]";
        }];
        readonly name: "manageUserBalance";
        readonly outputs: readonly [];
        readonly stateMutability: "payable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "enum IVault.SwapKind";
            readonly name: "kind";
            readonly type: "uint8";
        }, {
            readonly components: readonly [{
                readonly internalType: "bytes32";
                readonly name: "poolId";
                readonly type: "bytes32";
            }, {
                readonly internalType: "uint256";
                readonly name: "assetInIndex";
                readonly type: "uint256";
            }, {
                readonly internalType: "uint256";
                readonly name: "assetOutIndex";
                readonly type: "uint256";
            }, {
                readonly internalType: "uint256";
                readonly name: "amount";
                readonly type: "uint256";
            }, {
                readonly internalType: "bytes";
                readonly name: "userData";
                readonly type: "bytes";
            }];
            readonly internalType: "struct IVault.BatchSwapStep[]";
            readonly name: "swaps";
            readonly type: "tuple[]";
        }, {
            readonly internalType: "contract IAsset[]";
            readonly name: "assets";
            readonly type: "address[]";
        }, {
            readonly components: readonly [{
                readonly internalType: "address";
                readonly name: "sender";
                readonly type: "address";
            }, {
                readonly internalType: "bool";
                readonly name: "fromInternalBalance";
                readonly type: "bool";
            }, {
                readonly internalType: "address payable";
                readonly name: "recipient";
                readonly type: "address";
            }, {
                readonly internalType: "bool";
                readonly name: "toInternalBalance";
                readonly type: "bool";
            }];
            readonly internalType: "struct IVault.FundManagement";
            readonly name: "funds";
            readonly type: "tuple";
        }];
        readonly name: "queryBatchSwap";
        readonly outputs: readonly [{
            readonly internalType: "int256[]";
            readonly name: "";
            readonly type: "int256[]";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "enum IVault.PoolSpecialization";
            readonly name: "specialization";
            readonly type: "uint8";
        }];
        readonly name: "registerPool";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly internalType: "contract IERC20[]";
            readonly name: "tokens";
            readonly type: "address[]";
        }, {
            readonly internalType: "address[]";
            readonly name: "assetManagers";
            readonly type: "address[]";
        }];
        readonly name: "registerTokens";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "contract IAuthorizer";
            readonly name: "newAuthorizer";
            readonly type: "address";
        }];
        readonly name: "setAuthorizer";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bool";
            readonly name: "paused";
            readonly type: "bool";
        }];
        readonly name: "setPaused";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "relayer";
            readonly type: "address";
        }, {
            readonly internalType: "bool";
            readonly name: "approved";
            readonly type: "bool";
        }];
        readonly name: "setRelayerApproval";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly components: readonly [{
                readonly internalType: "bytes32";
                readonly name: "poolId";
                readonly type: "bytes32";
            }, {
                readonly internalType: "enum IVault.SwapKind";
                readonly name: "kind";
                readonly type: "uint8";
            }, {
                readonly internalType: "contract IAsset";
                readonly name: "assetIn";
                readonly type: "address";
            }, {
                readonly internalType: "contract IAsset";
                readonly name: "assetOut";
                readonly type: "address";
            }, {
                readonly internalType: "uint256";
                readonly name: "amount";
                readonly type: "uint256";
            }, {
                readonly internalType: "bytes";
                readonly name: "userData";
                readonly type: "bytes";
            }];
            readonly internalType: "struct IVault.SingleSwap";
            readonly name: "singleSwap";
            readonly type: "tuple";
        }, {
            readonly components: readonly [{
                readonly internalType: "address";
                readonly name: "sender";
                readonly type: "address";
            }, {
                readonly internalType: "bool";
                readonly name: "fromInternalBalance";
                readonly type: "bool";
            }, {
                readonly internalType: "address payable";
                readonly name: "recipient";
                readonly type: "address";
            }, {
                readonly internalType: "bool";
                readonly name: "toInternalBalance";
                readonly type: "bool";
            }];
            readonly internalType: "struct IVault.FundManagement";
            readonly name: "funds";
            readonly type: "tuple";
        }, {
            readonly internalType: "uint256";
            readonly name: "limit";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "deadline";
            readonly type: "uint256";
        }];
        readonly name: "swap";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "amountCalculated";
            readonly type: "uint256";
        }];
        readonly stateMutability: "payable";
        readonly type: "function";
    }, {
        readonly stateMutability: "payable";
        readonly type: "receive";
    }];
    static createInterface(): VaultInterface;
    static connect(address: string, signerOrProvider: Signer | Provider): Vault;
}

declare class WeightedPool__factory {
    static readonly abi: readonly [{
        readonly inputs: readonly [{
            readonly components: readonly [{
                readonly internalType: "string";
                readonly name: "name";
                readonly type: "string";
            }, {
                readonly internalType: "string";
                readonly name: "symbol";
                readonly type: "string";
            }, {
                readonly internalType: "contract IERC20[]";
                readonly name: "tokens";
                readonly type: "address[]";
            }, {
                readonly internalType: "uint256[]";
                readonly name: "normalizedWeights";
                readonly type: "uint256[]";
            }, {
                readonly internalType: "contract IRateProvider[]";
                readonly name: "rateProviders";
                readonly type: "address[]";
            }, {
                readonly internalType: "address[]";
                readonly name: "assetManagers";
                readonly type: "address[]";
            }, {
                readonly internalType: "uint256";
                readonly name: "swapFeePercentage";
                readonly type: "uint256";
            }];
            readonly internalType: "struct WeightedPool.NewPoolParams";
            readonly name: "params";
            readonly type: "tuple";
        }, {
            readonly internalType: "contract IVault";
            readonly name: "vault";
            readonly type: "address";
        }, {
            readonly internalType: "contract IProtocolFeePercentagesProvider";
            readonly name: "protocolFeeProvider";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "pauseWindowDuration";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "bufferPeriodDuration";
            readonly type: "uint256";
        }, {
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }, {
            readonly internalType: "string";
            readonly name: "version";
            readonly type: "string";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "constructor";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }, {
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "value";
            readonly type: "uint256";
        }];
        readonly name: "Approval";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "bool";
            readonly name: "paused";
            readonly type: "bool";
        }];
        readonly name: "PausedStateChanged";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "uint256";
            readonly name: "feeType";
            readonly type: "uint256";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "protocolFeePercentage";
            readonly type: "uint256";
        }];
        readonly name: "ProtocolFeePercentageCacheUpdated";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "bool";
            readonly name: "enabled";
            readonly type: "bool";
        }];
        readonly name: "RecoveryModeStateChanged";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "swapFeePercentage";
            readonly type: "uint256";
        }];
        readonly name: "SwapFeePercentageChanged";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "from";
            readonly type: "address";
        }, {
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "to";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "value";
            readonly type: "uint256";
        }];
        readonly name: "Transfer";
        readonly type: "event";
    }, {
        readonly inputs: readonly [];
        readonly name: "DELEGATE_PROTOCOL_SWAP_FEES_SENTINEL";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "DOMAIN_SEPARATOR";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }];
        readonly name: "allowance";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "approve";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "account";
            readonly type: "address";
        }];
        readonly name: "balanceOf";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "decimals";
        readonly outputs: readonly [{
            readonly internalType: "uint8";
            readonly name: "";
            readonly type: "uint8";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "decreaseAllowance";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "disableRecoveryMode";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "enableRecoveryMode";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getATHRateProduct";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes4";
            readonly name: "selector";
            readonly type: "bytes4";
        }];
        readonly name: "getActionId";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getActualSupply";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getAuthorizer";
        readonly outputs: readonly [{
            readonly internalType: "contract IAuthorizer";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getDomainSeparator";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getInvariant";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getLastPostJoinExitInvariant";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "account";
            readonly type: "address";
        }];
        readonly name: "getNextNonce";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getNormalizedWeights";
        readonly outputs: readonly [{
            readonly internalType: "uint256[]";
            readonly name: "";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getOwner";
        readonly outputs: readonly [{
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getPausedState";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "paused";
            readonly type: "bool";
        }, {
            readonly internalType: "uint256";
            readonly name: "pauseWindowEndTime";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "bufferPeriodEndTime";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getPoolId";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "feeType";
            readonly type: "uint256";
        }];
        readonly name: "getProtocolFeePercentageCache";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getProtocolFeesCollector";
        readonly outputs: readonly [{
            readonly internalType: "contract IProtocolFeesCollector";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getProtocolSwapFeeDelegation";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getRateProviders";
        readonly outputs: readonly [{
            readonly internalType: "contract IRateProvider[]";
            readonly name: "";
            readonly type: "address[]";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getScalingFactors";
        readonly outputs: readonly [{
            readonly internalType: "uint256[]";
            readonly name: "";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getSwapFeePercentage";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getVault";
        readonly outputs: readonly [{
            readonly internalType: "contract IVault";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "inRecoveryMode";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "addedValue";
            readonly type: "uint256";
        }];
        readonly name: "increaseAllowance";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "name";
        readonly outputs: readonly [{
            readonly internalType: "string";
            readonly name: "";
            readonly type: "string";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }];
        readonly name: "nonces";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "balances";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "lastChangeBlock";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "protocolSwapFeePercentage";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes";
            readonly name: "userData";
            readonly type: "bytes";
        }];
        readonly name: "onExitPool";
        readonly outputs: readonly [{
            readonly internalType: "uint256[]";
            readonly name: "";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "balances";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "lastChangeBlock";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "protocolSwapFeePercentage";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes";
            readonly name: "userData";
            readonly type: "bytes";
        }];
        readonly name: "onJoinPool";
        readonly outputs: readonly [{
            readonly internalType: "uint256[]";
            readonly name: "";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly components: readonly [{
                readonly internalType: "enum IVault.SwapKind";
                readonly name: "kind";
                readonly type: "uint8";
            }, {
                readonly internalType: "contract IERC20";
                readonly name: "tokenIn";
                readonly type: "address";
            }, {
                readonly internalType: "contract IERC20";
                readonly name: "tokenOut";
                readonly type: "address";
            }, {
                readonly internalType: "uint256";
                readonly name: "amount";
                readonly type: "uint256";
            }, {
                readonly internalType: "bytes32";
                readonly name: "poolId";
                readonly type: "bytes32";
            }, {
                readonly internalType: "uint256";
                readonly name: "lastChangeBlock";
                readonly type: "uint256";
            }, {
                readonly internalType: "address";
                readonly name: "from";
                readonly type: "address";
            }, {
                readonly internalType: "address";
                readonly name: "to";
                readonly type: "address";
            }, {
                readonly internalType: "bytes";
                readonly name: "userData";
                readonly type: "bytes";
            }];
            readonly internalType: "struct IPoolSwapStructs.SwapRequest";
            readonly name: "request";
            readonly type: "tuple";
        }, {
            readonly internalType: "uint256";
            readonly name: "balanceTokenIn";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "balanceTokenOut";
            readonly type: "uint256";
        }];
        readonly name: "onSwap";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "pause";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "value";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "deadline";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint8";
            readonly name: "v";
            readonly type: "uint8";
        }, {
            readonly internalType: "bytes32";
            readonly name: "r";
            readonly type: "bytes32";
        }, {
            readonly internalType: "bytes32";
            readonly name: "s";
            readonly type: "bytes32";
        }];
        readonly name: "permit";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "balances";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "lastChangeBlock";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "protocolSwapFeePercentage";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes";
            readonly name: "userData";
            readonly type: "bytes";
        }];
        readonly name: "queryExit";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "bptIn";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "amountsOut";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "balances";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "lastChangeBlock";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "protocolSwapFeePercentage";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes";
            readonly name: "userData";
            readonly type: "bytes";
        }];
        readonly name: "queryJoin";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "bptOut";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "amountsIn";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "contract IERC20";
            readonly name: "token";
            readonly type: "address";
        }, {
            readonly internalType: "bytes";
            readonly name: "poolConfig";
            readonly type: "bytes";
        }];
        readonly name: "setAssetManagerPoolConfig";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "swapFeePercentage";
            readonly type: "uint256";
        }];
        readonly name: "setSwapFeePercentage";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "symbol";
        readonly outputs: readonly [{
            readonly internalType: "string";
            readonly name: "";
            readonly type: "string";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "totalSupply";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "transfer";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "transferFrom";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "unpause";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "updateProtocolFeePercentageCache";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "version";
        readonly outputs: readonly [{
            readonly internalType: "string";
            readonly name: "";
            readonly type: "string";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }];
    static createInterface(): WeightedPoolInterface;
    static connect(address: string, signerOrProvider: Signer | Provider): WeightedPool;
}

declare class WeightedPoolFactory__factory {
    static readonly abi: readonly [{
        readonly inputs: readonly [{
            readonly internalType: "contract IVault";
            readonly name: "vault";
            readonly type: "address";
        }, {
            readonly internalType: "contract IProtocolFeePercentagesProvider";
            readonly name: "protocolFeeProvider";
            readonly type: "address";
        }, {
            readonly internalType: "string";
            readonly name: "factoryVersion";
            readonly type: "string";
        }, {
            readonly internalType: "string";
            readonly name: "poolVersion";
            readonly type: "string";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "constructor";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [];
        readonly name: "FactoryDisabled";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "pool";
            readonly type: "address";
        }];
        readonly name: "PoolCreated";
        readonly type: "event";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "string";
            readonly name: "name";
            readonly type: "string";
        }, {
            readonly internalType: "string";
            readonly name: "symbol";
            readonly type: "string";
        }, {
            readonly internalType: "contract IERC20[]";
            readonly name: "tokens";
            readonly type: "address[]";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "normalizedWeights";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "contract IRateProvider[]";
            readonly name: "rateProviders";
            readonly type: "address[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "swapFeePercentage";
            readonly type: "uint256";
        }, {
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }, {
            readonly internalType: "bytes32";
            readonly name: "salt";
            readonly type: "bytes32";
        }];
        readonly name: "create";
        readonly outputs: readonly [{
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "disable";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes4";
            readonly name: "selector";
            readonly type: "bytes4";
        }];
        readonly name: "getActionId";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getAuthorizer";
        readonly outputs: readonly [{
            readonly internalType: "contract IAuthorizer";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getCreationCode";
        readonly outputs: readonly [{
            readonly internalType: "bytes";
            readonly name: "";
            readonly type: "bytes";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getCreationCodeContracts";
        readonly outputs: readonly [{
            readonly internalType: "address";
            readonly name: "contractA";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "contractB";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getPauseConfiguration";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "pauseWindowDuration";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "bufferPeriodDuration";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getPoolVersion";
        readonly outputs: readonly [{
            readonly internalType: "string";
            readonly name: "";
            readonly type: "string";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getProtocolFeePercentagesProvider";
        readonly outputs: readonly [{
            readonly internalType: "contract IProtocolFeePercentagesProvider";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getVault";
        readonly outputs: readonly [{
            readonly internalType: "contract IVault";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "isDisabled";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "pool";
            readonly type: "address";
        }];
        readonly name: "isPoolFromFactory";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "version";
        readonly outputs: readonly [{
            readonly internalType: "string";
            readonly name: "";
            readonly type: "string";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }];
    static createInterface(): WeightedPoolFactoryInterface;
    static connect(address: string, signerOrProvider: Signer | Provider): WeightedPoolFactory;
}

declare class YearnLinearPool__factory {
    static readonly abi: readonly [{
        readonly inputs: readonly [{
            readonly components: readonly [{
                readonly internalType: "contract IVault";
                readonly name: "vault";
                readonly type: "address";
            }, {
                readonly internalType: "string";
                readonly name: "name";
                readonly type: "string";
            }, {
                readonly internalType: "string";
                readonly name: "symbol";
                readonly type: "string";
            }, {
                readonly internalType: "contract IERC20";
                readonly name: "mainToken";
                readonly type: "address";
            }, {
                readonly internalType: "contract IERC20";
                readonly name: "wrappedToken";
                readonly type: "address";
            }, {
                readonly internalType: "address";
                readonly name: "assetManager";
                readonly type: "address";
            }, {
                readonly internalType: "uint256";
                readonly name: "upperTarget";
                readonly type: "uint256";
            }, {
                readonly internalType: "uint256";
                readonly name: "swapFeePercentage";
                readonly type: "uint256";
            }, {
                readonly internalType: "uint256";
                readonly name: "pauseWindowDuration";
                readonly type: "uint256";
            }, {
                readonly internalType: "uint256";
                readonly name: "bufferPeriodDuration";
                readonly type: "uint256";
            }, {
                readonly internalType: "address";
                readonly name: "owner";
                readonly type: "address";
            }, {
                readonly internalType: "string";
                readonly name: "version";
                readonly type: "string";
            }];
            readonly internalType: "struct YearnLinearPool.ConstructorArgs";
            readonly name: "args";
            readonly type: "tuple";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "constructor";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }, {
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "value";
            readonly type: "uint256";
        }];
        readonly name: "Approval";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "bool";
            readonly name: "paused";
            readonly type: "bool";
        }];
        readonly name: "PausedStateChanged";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "bool";
            readonly name: "enabled";
            readonly type: "bool";
        }];
        readonly name: "RecoveryModeStateChanged";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "swapFeePercentage";
            readonly type: "uint256";
        }];
        readonly name: "SwapFeePercentageChanged";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "contract IERC20";
            readonly name: "token";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "lowerTarget";
            readonly type: "uint256";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "upperTarget";
            readonly type: "uint256";
        }];
        readonly name: "TargetsSet";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "from";
            readonly type: "address";
        }, {
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "to";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "value";
            readonly type: "uint256";
        }];
        readonly name: "Transfer";
        readonly type: "event";
    }, {
        readonly inputs: readonly [];
        readonly name: "DOMAIN_SEPARATOR";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }];
        readonly name: "allowance";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "approve";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "account";
            readonly type: "address";
        }];
        readonly name: "balanceOf";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "decimals";
        readonly outputs: readonly [{
            readonly internalType: "uint8";
            readonly name: "";
            readonly type: "uint8";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "decreaseAllowance";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "disableRecoveryMode";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "enableRecoveryMode";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes4";
            readonly name: "selector";
            readonly type: "bytes4";
        }];
        readonly name: "getActionId";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getAuthorizer";
        readonly outputs: readonly [{
            readonly internalType: "contract IAuthorizer";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getBptIndex";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "pure";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getDomainSeparator";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getMainIndex";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getMainToken";
        readonly outputs: readonly [{
            readonly internalType: "contract IERC20";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "account";
            readonly type: "address";
        }];
        readonly name: "getNextNonce";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getOwner";
        readonly outputs: readonly [{
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getPausedState";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "paused";
            readonly type: "bool";
        }, {
            readonly internalType: "uint256";
            readonly name: "pauseWindowEndTime";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "bufferPeriodEndTime";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getPoolId";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getProtocolFeesCollector";
        readonly outputs: readonly [{
            readonly internalType: "contract IProtocolFeesCollector";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getRate";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getScalingFactors";
        readonly outputs: readonly [{
            readonly internalType: "uint256[]";
            readonly name: "";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getSwapFeePercentage";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getTargets";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "lowerTarget";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "upperTarget";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getVault";
        readonly outputs: readonly [{
            readonly internalType: "contract IVault";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getVirtualSupply";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getWrappedIndex";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getWrappedToken";
        readonly outputs: readonly [{
            readonly internalType: "contract IERC20";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getWrappedTokenRate";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "inRecoveryMode";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "addedValue";
            readonly type: "uint256";
        }];
        readonly name: "increaseAllowance";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "initialize";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "name";
        readonly outputs: readonly [{
            readonly internalType: "string";
            readonly name: "";
            readonly type: "string";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }];
        readonly name: "nonces";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "balances";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes";
            readonly name: "userData";
            readonly type: "bytes";
        }];
        readonly name: "onExitPool";
        readonly outputs: readonly [{
            readonly internalType: "uint256[]";
            readonly name: "amountsOut";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "dueProtocolFees";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "balances";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes";
            readonly name: "userData";
            readonly type: "bytes";
        }];
        readonly name: "onJoinPool";
        readonly outputs: readonly [{
            readonly internalType: "uint256[]";
            readonly name: "amountsIn";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "dueProtocolFees";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly components: readonly [{
                readonly internalType: "enum IVault.SwapKind";
                readonly name: "kind";
                readonly type: "uint8";
            }, {
                readonly internalType: "contract IERC20";
                readonly name: "tokenIn";
                readonly type: "address";
            }, {
                readonly internalType: "contract IERC20";
                readonly name: "tokenOut";
                readonly type: "address";
            }, {
                readonly internalType: "uint256";
                readonly name: "amount";
                readonly type: "uint256";
            }, {
                readonly internalType: "bytes32";
                readonly name: "poolId";
                readonly type: "bytes32";
            }, {
                readonly internalType: "uint256";
                readonly name: "lastChangeBlock";
                readonly type: "uint256";
            }, {
                readonly internalType: "address";
                readonly name: "from";
                readonly type: "address";
            }, {
                readonly internalType: "address";
                readonly name: "to";
                readonly type: "address";
            }, {
                readonly internalType: "bytes";
                readonly name: "userData";
                readonly type: "bytes";
            }];
            readonly internalType: "struct IPoolSwapStructs.SwapRequest";
            readonly name: "request";
            readonly type: "tuple";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "balances";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "indexIn";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "indexOut";
            readonly type: "uint256";
        }];
        readonly name: "onSwap";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly components: readonly [{
                readonly internalType: "enum IVault.SwapKind";
                readonly name: "kind";
                readonly type: "uint8";
            }, {
                readonly internalType: "contract IERC20";
                readonly name: "tokenIn";
                readonly type: "address";
            }, {
                readonly internalType: "contract IERC20";
                readonly name: "tokenOut";
                readonly type: "address";
            }, {
                readonly internalType: "uint256";
                readonly name: "amount";
                readonly type: "uint256";
            }, {
                readonly internalType: "bytes32";
                readonly name: "poolId";
                readonly type: "bytes32";
            }, {
                readonly internalType: "uint256";
                readonly name: "lastChangeBlock";
                readonly type: "uint256";
            }, {
                readonly internalType: "address";
                readonly name: "from";
                readonly type: "address";
            }, {
                readonly internalType: "address";
                readonly name: "to";
                readonly type: "address";
            }, {
                readonly internalType: "bytes";
                readonly name: "userData";
                readonly type: "bytes";
            }];
            readonly internalType: "struct IPoolSwapStructs.SwapRequest";
            readonly name: "request";
            readonly type: "tuple";
        }, {
            readonly internalType: "uint256";
            readonly name: "balanceTokenIn";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "balanceTokenOut";
            readonly type: "uint256";
        }];
        readonly name: "onSwap";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "pause";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "value";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "deadline";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint8";
            readonly name: "v";
            readonly type: "uint8";
        }, {
            readonly internalType: "bytes32";
            readonly name: "r";
            readonly type: "bytes32";
        }, {
            readonly internalType: "bytes32";
            readonly name: "s";
            readonly type: "bytes32";
        }];
        readonly name: "permit";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "balances";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes";
            readonly name: "userData";
            readonly type: "bytes";
        }];
        readonly name: "queryExit";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "bptIn";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "amountsOut";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "balances";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes";
            readonly name: "userData";
            readonly type: "bytes";
        }];
        readonly name: "queryJoin";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "bptOut";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "amountsIn";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "swapFeePercentage";
            readonly type: "uint256";
        }];
        readonly name: "setSwapFeePercentage";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "newLowerTarget";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "newUpperTarget";
            readonly type: "uint256";
        }];
        readonly name: "setTargets";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "symbol";
        readonly outputs: readonly [{
            readonly internalType: "string";
            readonly name: "";
            readonly type: "string";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "totalSupply";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "transfer";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "transferFrom";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "unpause";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "version";
        readonly outputs: readonly [{
            readonly internalType: "string";
            readonly name: "";
            readonly type: "string";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }];
    static createInterface(): YearnLinearPoolInterface;
    static connect(address: string, signerOrProvider: Signer | Provider): YearnLinearPool;
}

declare class YearnLinearPoolFactory__factory {
    static readonly abi: readonly [{
        readonly inputs: readonly [{
            readonly internalType: "contract IVault";
            readonly name: "vault";
            readonly type: "address";
        }, {
            readonly internalType: "contract IProtocolFeePercentagesProvider";
            readonly name: "protocolFeeProvider";
            readonly type: "address";
        }, {
            readonly internalType: "contract IBalancerQueries";
            readonly name: "queries";
            readonly type: "address";
        }, {
            readonly internalType: "string";
            readonly name: "factoryVersion";
            readonly type: "string";
        }, {
            readonly internalType: "string";
            readonly name: "poolVersion";
            readonly type: "string";
        }, {
            readonly internalType: "uint256";
            readonly name: "initialPauseWindowDuration";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "bufferPeriodDuration";
            readonly type: "uint256";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "constructor";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [];
        readonly name: "FactoryDisabled";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "pool";
            readonly type: "address";
        }];
        readonly name: "PoolCreated";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "pool";
            readonly type: "address";
        }, {
            readonly indexed: true;
            readonly internalType: "uint256";
            readonly name: "protocolId";
            readonly type: "uint256";
        }];
        readonly name: "YearnLinearPoolCreated";
        readonly type: "event";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "string";
            readonly name: "name";
            readonly type: "string";
        }, {
            readonly internalType: "string";
            readonly name: "symbol";
            readonly type: "string";
        }, {
            readonly internalType: "contract IERC20";
            readonly name: "mainToken";
            readonly type: "address";
        }, {
            readonly internalType: "contract IERC20";
            readonly name: "wrappedToken";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "upperTarget";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "swapFeePercentage";
            readonly type: "uint256";
        }, {
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "protocolId";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes32";
            readonly name: "salt";
            readonly type: "bytes32";
        }];
        readonly name: "create";
        readonly outputs: readonly [{
            readonly internalType: "contract LinearPool";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "disable";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes4";
            readonly name: "selector";
            readonly type: "bytes4";
        }];
        readonly name: "getActionId";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getAuthorizer";
        readonly outputs: readonly [{
            readonly internalType: "contract IAuthorizer";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getCreationCode";
        readonly outputs: readonly [{
            readonly internalType: "bytes";
            readonly name: "";
            readonly type: "bytes";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getCreationCodeContracts";
        readonly outputs: readonly [{
            readonly internalType: "address";
            readonly name: "contractA";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "contractB";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getLastCreatedPool";
        readonly outputs: readonly [{
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getPauseConfiguration";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "pauseWindowDuration";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "bufferPeriodDuration";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getPoolVersion";
        readonly outputs: readonly [{
            readonly internalType: "string";
            readonly name: "";
            readonly type: "string";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getProtocolFeePercentagesProvider";
        readonly outputs: readonly [{
            readonly internalType: "contract IProtocolFeePercentagesProvider";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getVault";
        readonly outputs: readonly [{
            readonly internalType: "contract IVault";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "isDisabled";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "pool";
            readonly type: "address";
        }];
        readonly name: "isPoolFromFactory";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "version";
        readonly outputs: readonly [{
            readonly internalType: "string";
            readonly name: "";
            readonly type: "string";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }];
    static createInterface(): YearnLinearPoolFactoryInterface;
    static connect(address: string, signerOrProvider: Signer | Provider): YearnLinearPoolFactory;
}

declare class GyroEV2__factory {
    static readonly abi: readonly [{
        readonly inputs: readonly [{
            readonly components: readonly [{
                readonly components: readonly [{
                    readonly internalType: "contract IVault";
                    readonly name: "vault";
                    readonly type: "address";
                }, {
                    readonly internalType: "string";
                    readonly name: "name";
                    readonly type: "string";
                }, {
                    readonly internalType: "string";
                    readonly name: "symbol";
                    readonly type: "string";
                }, {
                    readonly internalType: "contract IERC20";
                    readonly name: "token0";
                    readonly type: "address";
                }, {
                    readonly internalType: "contract IERC20";
                    readonly name: "token1";
                    readonly type: "address";
                }, {
                    readonly internalType: "uint256";
                    readonly name: "swapFeePercentage";
                    readonly type: "uint256";
                }, {
                    readonly internalType: "uint256";
                    readonly name: "pauseWindowDuration";
                    readonly type: "uint256";
                }, {
                    readonly internalType: "uint256";
                    readonly name: "bufferPeriodDuration";
                    readonly type: "uint256";
                }, {
                    readonly internalType: "bool";
                    readonly name: "oracleEnabled";
                    readonly type: "bool";
                }, {
                    readonly internalType: "address";
                    readonly name: "owner";
                    readonly type: "address";
                }];
                readonly internalType: "struct ExtensibleWeightedPool2Tokens.NewPoolParams";
                readonly name: "baseParams";
                readonly type: "tuple";
            }, {
                readonly components: readonly [{
                    readonly internalType: "int256";
                    readonly name: "alpha";
                    readonly type: "int256";
                }, {
                    readonly internalType: "int256";
                    readonly name: "beta";
                    readonly type: "int256";
                }, {
                    readonly internalType: "int256";
                    readonly name: "c";
                    readonly type: "int256";
                }, {
                    readonly internalType: "int256";
                    readonly name: "s";
                    readonly type: "int256";
                }, {
                    readonly internalType: "int256";
                    readonly name: "lambda";
                    readonly type: "int256";
                }];
                readonly internalType: "struct GyroECLPMath.Params";
                readonly name: "eclpParams";
                readonly type: "tuple";
            }, {
                readonly components: readonly [{
                    readonly components: readonly [{
                        readonly internalType: "int256";
                        readonly name: "x";
                        readonly type: "int256";
                    }, {
                        readonly internalType: "int256";
                        readonly name: "y";
                        readonly type: "int256";
                    }];
                    readonly internalType: "struct GyroECLPMath.Vector2";
                    readonly name: "tauAlpha";
                    readonly type: "tuple";
                }, {
                    readonly components: readonly [{
                        readonly internalType: "int256";
                        readonly name: "x";
                        readonly type: "int256";
                    }, {
                        readonly internalType: "int256";
                        readonly name: "y";
                        readonly type: "int256";
                    }];
                    readonly internalType: "struct GyroECLPMath.Vector2";
                    readonly name: "tauBeta";
                    readonly type: "tuple";
                }, {
                    readonly internalType: "int256";
                    readonly name: "u";
                    readonly type: "int256";
                }, {
                    readonly internalType: "int256";
                    readonly name: "v";
                    readonly type: "int256";
                }, {
                    readonly internalType: "int256";
                    readonly name: "w";
                    readonly type: "int256";
                }, {
                    readonly internalType: "int256";
                    readonly name: "z";
                    readonly type: "int256";
                }, {
                    readonly internalType: "int256";
                    readonly name: "dSq";
                    readonly type: "int256";
                }];
                readonly internalType: "struct GyroECLPMath.DerivedParams";
                readonly name: "derivedEclpParams";
                readonly type: "tuple";
            }, {
                readonly internalType: "address";
                readonly name: "rateProvider0";
                readonly type: "address";
            }, {
                readonly internalType: "address";
                readonly name: "rateProvider1";
                readonly type: "address";
            }, {
                readonly internalType: "address";
                readonly name: "capManager";
                readonly type: "address";
            }, {
                readonly components: readonly [{
                    readonly internalType: "bool";
                    readonly name: "capEnabled";
                    readonly type: "bool";
                }, {
                    readonly internalType: "uint120";
                    readonly name: "perAddressCap";
                    readonly type: "uint120";
                }, {
                    readonly internalType: "uint128";
                    readonly name: "globalCap";
                    readonly type: "uint128";
                }];
                readonly internalType: "struct ICappedLiquidity.CapParams";
                readonly name: "capParams";
                readonly type: "tuple";
            }, {
                readonly internalType: "address";
                readonly name: "pauseManager";
                readonly type: "address";
            }];
            readonly internalType: "struct GyroECLPPool.GyroParams";
            readonly name: "params";
            readonly type: "tuple";
        }, {
            readonly internalType: "address";
            readonly name: "configAddress";
            readonly type: "address";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "constructor";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }, {
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "value";
            readonly type: "uint256";
        }];
        readonly name: "Approval";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "address";
            readonly name: "capManager";
            readonly type: "address";
        }];
        readonly name: "CapManagerUpdated";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly components: readonly [{
                readonly internalType: "bool";
                readonly name: "capEnabled";
                readonly type: "bool";
            }, {
                readonly internalType: "uint120";
                readonly name: "perAddressCap";
                readonly type: "uint120";
            }, {
                readonly internalType: "uint128";
                readonly name: "globalCap";
                readonly type: "uint128";
            }];
            readonly indexed: false;
            readonly internalType: "struct ICappedLiquidity.CapParams";
            readonly name: "params";
            readonly type: "tuple";
        }];
        readonly name: "CapParamsUpdated";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "bool";
            readonly name: "derivedParamsValidated";
            readonly type: "bool";
        }];
        readonly name: "ECLPDerivedParamsValidated";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "bool";
            readonly name: "paramsValidated";
            readonly type: "bool";
        }];
        readonly name: "ECLPParamsValidated";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "invariantAfterJoin";
            readonly type: "uint256";
        }];
        readonly name: "InvariantAterInitializeJoin";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "oldInvariant";
            readonly type: "uint256";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "newInvariant";
            readonly type: "uint256";
        }];
        readonly name: "InvariantOldAndNew";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "bool";
            readonly name: "enabled";
            readonly type: "bool";
        }];
        readonly name: "OracleEnabledChanged";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "oracleUpdatedIndex";
            readonly type: "uint256";
        }];
        readonly name: "OracleIndexUpdated";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "address";
            readonly name: "oldPauseManager";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly internalType: "address";
            readonly name: "newPauseManager";
            readonly type: "address";
        }];
        readonly name: "PauseManagerChanged";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [];
        readonly name: "PausedLocally";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "bool";
            readonly name: "paused";
            readonly type: "bool";
        }];
        readonly name: "PausedStateChanged";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "swapFeePercentage";
            readonly type: "uint256";
        }];
        readonly name: "SwapFeePercentageChanged";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: false;
            readonly internalType: "uint256[]";
            readonly name: "balances";
            readonly type: "uint256[]";
        }, {
            readonly components: readonly [{
                readonly internalType: "int256";
                readonly name: "x";
                readonly type: "int256";
            }, {
                readonly internalType: "int256";
                readonly name: "y";
                readonly type: "int256";
            }];
            readonly indexed: false;
            readonly internalType: "struct GyroECLPMath.Vector2";
            readonly name: "invariant";
            readonly type: "tuple";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "SwapParams";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "from";
            readonly type: "address";
        }, {
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "to";
            readonly type: "address";
        }, {
            readonly indexed: false;
            readonly internalType: "uint256";
            readonly name: "value";
            readonly type: "uint256";
        }];
        readonly name: "Transfer";
        readonly type: "event";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [];
        readonly name: "UnpausedLocally";
        readonly type: "event";
    }, {
        readonly inputs: readonly [];
        readonly name: "DOMAIN_SEPARATOR";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "_dSq";
        readonly outputs: readonly [{
            readonly internalType: "int256";
            readonly name: "";
            readonly type: "int256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "_paramsAlpha";
        readonly outputs: readonly [{
            readonly internalType: "int256";
            readonly name: "";
            readonly type: "int256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "_paramsBeta";
        readonly outputs: readonly [{
            readonly internalType: "int256";
            readonly name: "";
            readonly type: "int256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "_paramsC";
        readonly outputs: readonly [{
            readonly internalType: "int256";
            readonly name: "";
            readonly type: "int256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "_paramsLambda";
        readonly outputs: readonly [{
            readonly internalType: "int256";
            readonly name: "";
            readonly type: "int256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "_paramsS";
        readonly outputs: readonly [{
            readonly internalType: "int256";
            readonly name: "";
            readonly type: "int256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "_tauAlphaX";
        readonly outputs: readonly [{
            readonly internalType: "int256";
            readonly name: "";
            readonly type: "int256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "_tauAlphaY";
        readonly outputs: readonly [{
            readonly internalType: "int256";
            readonly name: "";
            readonly type: "int256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "_tauBetaX";
        readonly outputs: readonly [{
            readonly internalType: "int256";
            readonly name: "";
            readonly type: "int256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "_tauBetaY";
        readonly outputs: readonly [{
            readonly internalType: "int256";
            readonly name: "";
            readonly type: "int256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "_u";
        readonly outputs: readonly [{
            readonly internalType: "int256";
            readonly name: "";
            readonly type: "int256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "_v";
        readonly outputs: readonly [{
            readonly internalType: "int256";
            readonly name: "";
            readonly type: "int256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "_w";
        readonly outputs: readonly [{
            readonly internalType: "int256";
            readonly name: "";
            readonly type: "int256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "_z";
        readonly outputs: readonly [{
            readonly internalType: "int256";
            readonly name: "";
            readonly type: "int256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }];
        readonly name: "allowance";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "approve";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "account";
            readonly type: "address";
        }];
        readonly name: "balanceOf";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "capManager";
        readonly outputs: readonly [{
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "capParams";
        readonly outputs: readonly [{
            readonly components: readonly [{
                readonly internalType: "bool";
                readonly name: "capEnabled";
                readonly type: "bool";
            }, {
                readonly internalType: "uint120";
                readonly name: "perAddressCap";
                readonly type: "uint120";
            }, {
                readonly internalType: "uint128";
                readonly name: "globalCap";
                readonly type: "uint128";
            }];
            readonly internalType: "struct ICappedLiquidity.CapParams";
            readonly name: "";
            readonly type: "tuple";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "_pauseManager";
            readonly type: "address";
        }];
        readonly name: "changePauseManager";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "decimals";
        readonly outputs: readonly [{
            readonly internalType: "uint8";
            readonly name: "";
            readonly type: "uint8";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "decreaseAllowance";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "startIndex";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "endIndex";
            readonly type: "uint256";
        }];
        readonly name: "dirtyUninitializedOracleSamples";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "enableOracle";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes4";
            readonly name: "selector";
            readonly type: "bytes4";
        }];
        readonly name: "getActionId";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getAuthorizer";
        readonly outputs: readonly [{
            readonly internalType: "contract IAuthorizer";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getECLPParams";
        readonly outputs: readonly [{
            readonly components: readonly [{
                readonly internalType: "int256";
                readonly name: "alpha";
                readonly type: "int256";
            }, {
                readonly internalType: "int256";
                readonly name: "beta";
                readonly type: "int256";
            }, {
                readonly internalType: "int256";
                readonly name: "c";
                readonly type: "int256";
            }, {
                readonly internalType: "int256";
                readonly name: "s";
                readonly type: "int256";
            }, {
                readonly internalType: "int256";
                readonly name: "lambda";
                readonly type: "int256";
            }];
            readonly internalType: "struct GyroECLPMath.Params";
            readonly name: "params";
            readonly type: "tuple";
        }, {
            readonly components: readonly [{
                readonly components: readonly [{
                    readonly internalType: "int256";
                    readonly name: "x";
                    readonly type: "int256";
                }, {
                    readonly internalType: "int256";
                    readonly name: "y";
                    readonly type: "int256";
                }];
                readonly internalType: "struct GyroECLPMath.Vector2";
                readonly name: "tauAlpha";
                readonly type: "tuple";
            }, {
                readonly components: readonly [{
                    readonly internalType: "int256";
                    readonly name: "x";
                    readonly type: "int256";
                }, {
                    readonly internalType: "int256";
                    readonly name: "y";
                    readonly type: "int256";
                }];
                readonly internalType: "struct GyroECLPMath.Vector2";
                readonly name: "tauBeta";
                readonly type: "tuple";
            }, {
                readonly internalType: "int256";
                readonly name: "u";
                readonly type: "int256";
            }, {
                readonly internalType: "int256";
                readonly name: "v";
                readonly type: "int256";
            }, {
                readonly internalType: "int256";
                readonly name: "w";
                readonly type: "int256";
            }, {
                readonly internalType: "int256";
                readonly name: "z";
                readonly type: "int256";
            }, {
                readonly internalType: "int256";
                readonly name: "dSq";
                readonly type: "int256";
            }];
            readonly internalType: "struct GyroECLPMath.DerivedParams";
            readonly name: "d";
            readonly type: "tuple";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getInvariant";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getLargestSafeQueryWindow";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "pure";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getLastInvariant";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "enum IPriceOracle.Variable";
            readonly name: "variable";
            readonly type: "uint8";
        }];
        readonly name: "getLatest";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getMiscData";
        readonly outputs: readonly [{
            readonly internalType: "int256";
            readonly name: "logInvariant";
            readonly type: "int256";
        }, {
            readonly internalType: "int256";
            readonly name: "logTotalSupply";
            readonly type: "int256";
        }, {
            readonly internalType: "uint256";
            readonly name: "oracleSampleCreationTimestamp";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "oracleIndex";
            readonly type: "uint256";
        }, {
            readonly internalType: "bool";
            readonly name: "oracleEnabled";
            readonly type: "bool";
        }, {
            readonly internalType: "uint256";
            readonly name: "swapFeePercentage";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getNormalizedWeights";
        readonly outputs: readonly [{
            readonly internalType: "uint256[]";
            readonly name: "";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getOwner";
        readonly outputs: readonly [{
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly components: readonly [{
                readonly internalType: "enum IPriceOracle.Variable";
                readonly name: "variable";
                readonly type: "uint8";
            }, {
                readonly internalType: "uint256";
                readonly name: "ago";
                readonly type: "uint256";
            }];
            readonly internalType: "struct IPriceOracle.OracleAccumulatorQuery[]";
            readonly name: "queries";
            readonly type: "tuple[]";
        }];
        readonly name: "getPastAccumulators";
        readonly outputs: readonly [{
            readonly internalType: "int256[]";
            readonly name: "results";
            readonly type: "int256[]";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getPausedState";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "paused";
            readonly type: "bool";
        }, {
            readonly internalType: "uint256";
            readonly name: "pauseWindowEndTime";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "bufferPeriodEndTime";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getPoolId";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getPrice";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "spotPrice";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getRate";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "index";
            readonly type: "uint256";
        }];
        readonly name: "getSample";
        readonly outputs: readonly [{
            readonly internalType: "int256";
            readonly name: "logPairPrice";
            readonly type: "int256";
        }, {
            readonly internalType: "int256";
            readonly name: "accLogPairPrice";
            readonly type: "int256";
        }, {
            readonly internalType: "int256";
            readonly name: "logBptPrice";
            readonly type: "int256";
        }, {
            readonly internalType: "int256";
            readonly name: "accLogBptPrice";
            readonly type: "int256";
        }, {
            readonly internalType: "int256";
            readonly name: "logInvariant";
            readonly type: "int256";
        }, {
            readonly internalType: "int256";
            readonly name: "accLogInvariant";
            readonly type: "int256";
        }, {
            readonly internalType: "uint256";
            readonly name: "timestamp";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getSwapFeePercentage";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly components: readonly [{
                readonly internalType: "enum IPriceOracle.Variable";
                readonly name: "variable";
                readonly type: "uint8";
            }, {
                readonly internalType: "uint256";
                readonly name: "secs";
                readonly type: "uint256";
            }, {
                readonly internalType: "uint256";
                readonly name: "ago";
                readonly type: "uint256";
            }];
            readonly internalType: "struct IPriceOracle.OracleAverageQuery[]";
            readonly name: "queries";
            readonly type: "tuple[]";
        }];
        readonly name: "getTimeWeightedAverage";
        readonly outputs: readonly [{
            readonly internalType: "uint256[]";
            readonly name: "results";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getTokenRates";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "rate0";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "rate1";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getTotalSamples";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "pure";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getVault";
        readonly outputs: readonly [{
            readonly internalType: "contract IVault";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "gyroConfig";
        readonly outputs: readonly [{
            readonly internalType: "contract IGyroConfig";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "addedValue";
            readonly type: "uint256";
        }];
        readonly name: "increaseAllowance";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "name";
        readonly outputs: readonly [{
            readonly internalType: "string";
            readonly name: "";
            readonly type: "string";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }];
        readonly name: "nonces";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "balances";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "lastChangeBlock";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "protocolSwapFeePercentage";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes";
            readonly name: "userData";
            readonly type: "bytes";
        }];
        readonly name: "onExitPool";
        readonly outputs: readonly [{
            readonly internalType: "uint256[]";
            readonly name: "";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "balances";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "lastChangeBlock";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "protocolSwapFeePercentage";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes";
            readonly name: "userData";
            readonly type: "bytes";
        }];
        readonly name: "onJoinPool";
        readonly outputs: readonly [{
            readonly internalType: "uint256[]";
            readonly name: "amountsIn";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "dueProtocolFeeAmounts";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly components: readonly [{
                readonly internalType: "enum IVault.SwapKind";
                readonly name: "kind";
                readonly type: "uint8";
            }, {
                readonly internalType: "contract IERC20";
                readonly name: "tokenIn";
                readonly type: "address";
            }, {
                readonly internalType: "contract IERC20";
                readonly name: "tokenOut";
                readonly type: "address";
            }, {
                readonly internalType: "uint256";
                readonly name: "amount";
                readonly type: "uint256";
            }, {
                readonly internalType: "bytes32";
                readonly name: "poolId";
                readonly type: "bytes32";
            }, {
                readonly internalType: "uint256";
                readonly name: "lastChangeBlock";
                readonly type: "uint256";
            }, {
                readonly internalType: "address";
                readonly name: "from";
                readonly type: "address";
            }, {
                readonly internalType: "address";
                readonly name: "to";
                readonly type: "address";
            }, {
                readonly internalType: "bytes";
                readonly name: "userData";
                readonly type: "bytes";
            }];
            readonly internalType: "struct IPoolSwapStructs.SwapRequest";
            readonly name: "request";
            readonly type: "tuple";
        }, {
            readonly internalType: "uint256";
            readonly name: "balanceTokenIn";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "balanceTokenOut";
            readonly type: "uint256";
        }];
        readonly name: "onSwap";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "pause";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "pauseManager";
        readonly outputs: readonly [{
            readonly internalType: "address";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "owner";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "spender";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "value";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "deadline";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint8";
            readonly name: "v";
            readonly type: "uint8";
        }, {
            readonly internalType: "bytes32";
            readonly name: "r";
            readonly type: "bytes32";
        }, {
            readonly internalType: "bytes32";
            readonly name: "s";
            readonly type: "bytes32";
        }];
        readonly name: "permit";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "balances";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "lastChangeBlock";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "protocolSwapFeePercentage";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes";
            readonly name: "userData";
            readonly type: "bytes";
        }];
        readonly name: "queryExit";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "bptIn";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "amountsOut";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "poolId";
            readonly type: "bytes32";
        }, {
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "balances";
            readonly type: "uint256[]";
        }, {
            readonly internalType: "uint256";
            readonly name: "lastChangeBlock";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "protocolSwapFeePercentage";
            readonly type: "uint256";
        }, {
            readonly internalType: "bytes";
            readonly name: "userData";
            readonly type: "bytes";
        }];
        readonly name: "queryJoin";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "bptOut";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256[]";
            readonly name: "amountsIn";
            readonly type: "uint256[]";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "rateProvider0";
        readonly outputs: readonly [{
            readonly internalType: "contract IRateProvider";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "rateProvider1";
        readonly outputs: readonly [{
            readonly internalType: "contract IRateProvider";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "_capManager";
            readonly type: "address";
        }];
        readonly name: "setCapManager";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly components: readonly [{
                readonly internalType: "bool";
                readonly name: "capEnabled";
                readonly type: "bool";
            }, {
                readonly internalType: "uint120";
                readonly name: "perAddressCap";
                readonly type: "uint120";
            }, {
                readonly internalType: "uint128";
                readonly name: "globalCap";
                readonly type: "uint128";
            }];
            readonly internalType: "struct ICappedLiquidity.CapParams";
            readonly name: "params";
            readonly type: "tuple";
        }];
        readonly name: "setCapParams";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bool";
            readonly name: "paused";
            readonly type: "bool";
        }];
        readonly name: "setPaused";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "swapFeePercentage";
            readonly type: "uint256";
        }];
        readonly name: "setSwapFeePercentage";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "symbol";
        readonly outputs: readonly [{
            readonly internalType: "string";
            readonly name: "";
            readonly type: "string";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "totalSupply";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "transfer";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "sender";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly internalType: "uint256";
            readonly name: "amount";
            readonly type: "uint256";
        }];
        readonly name: "transferFrom";
        readonly outputs: readonly [{
            readonly internalType: "bool";
            readonly name: "";
            readonly type: "bool";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "unpause";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }];
    static createInterface(): GyroEV2Interface;
    static connect(address: string, signerOrProvider: Signer | Provider): GyroEV2;
}

declare class VeBal__factory {
    static readonly abi: readonly [{
        readonly name: "Deposit";
        readonly inputs: readonly [{
            readonly name: "provider";
            readonly type: "address";
            readonly indexed: true;
        }, {
            readonly name: "value";
            readonly type: "uint256";
            readonly indexed: false;
        }, {
            readonly name: "locktime";
            readonly type: "uint256";
            readonly indexed: true;
        }, {
            readonly name: "type";
            readonly type: "int128";
            readonly indexed: false;
        }, {
            readonly name: "ts";
            readonly type: "uint256";
            readonly indexed: false;
        }];
        readonly anonymous: false;
        readonly type: "event";
    }, {
        readonly name: "Withdraw";
        readonly inputs: readonly [{
            readonly name: "provider";
            readonly type: "address";
            readonly indexed: true;
        }, {
            readonly name: "value";
            readonly type: "uint256";
            readonly indexed: false;
        }, {
            readonly name: "ts";
            readonly type: "uint256";
            readonly indexed: false;
        }];
        readonly anonymous: false;
        readonly type: "event";
    }, {
        readonly name: "Supply";
        readonly inputs: readonly [{
            readonly name: "prevSupply";
            readonly type: "uint256";
            readonly indexed: false;
        }, {
            readonly name: "supply";
            readonly type: "uint256";
            readonly indexed: false;
        }];
        readonly anonymous: false;
        readonly type: "event";
    }, {
        readonly stateMutability: "nonpayable";
        readonly type: "constructor";
        readonly inputs: readonly [{
            readonly name: "token_addr";
            readonly type: "address";
        }, {
            readonly name: "_name";
            readonly type: "string";
        }, {
            readonly name: "_symbol";
            readonly type: "string";
        }, {
            readonly name: "_authorizer_adaptor";
            readonly type: "address";
        }];
        readonly outputs: readonly [];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "token";
        readonly inputs: readonly [];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "address";
        }];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "name";
        readonly inputs: readonly [];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "string";
        }];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "symbol";
        readonly inputs: readonly [];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "string";
        }];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "decimals";
        readonly inputs: readonly [];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "uint256";
        }];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "admin";
        readonly inputs: readonly [];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "address";
        }];
    }, {
        readonly stateMutability: "nonpayable";
        readonly type: "function";
        readonly name: "commit_smart_wallet_checker";
        readonly inputs: readonly [{
            readonly name: "addr";
            readonly type: "address";
        }];
        readonly outputs: readonly [];
    }, {
        readonly stateMutability: "nonpayable";
        readonly type: "function";
        readonly name: "apply_smart_wallet_checker";
        readonly inputs: readonly [];
        readonly outputs: readonly [];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "get_last_user_slope";
        readonly inputs: readonly [{
            readonly name: "addr";
            readonly type: "address";
        }];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "int128";
        }];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "user_point_history__ts";
        readonly inputs: readonly [{
            readonly name: "_addr";
            readonly type: "address";
        }, {
            readonly name: "_idx";
            readonly type: "uint256";
        }];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "uint256";
        }];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "locked__end";
        readonly inputs: readonly [{
            readonly name: "_addr";
            readonly type: "address";
        }];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "uint256";
        }];
    }, {
        readonly stateMutability: "nonpayable";
        readonly type: "function";
        readonly name: "checkpoint";
        readonly inputs: readonly [];
        readonly outputs: readonly [];
    }, {
        readonly stateMutability: "nonpayable";
        readonly type: "function";
        readonly name: "deposit_for";
        readonly inputs: readonly [{
            readonly name: "_addr";
            readonly type: "address";
        }, {
            readonly name: "_value";
            readonly type: "uint256";
        }];
        readonly outputs: readonly [];
    }, {
        readonly stateMutability: "nonpayable";
        readonly type: "function";
        readonly name: "create_lock";
        readonly inputs: readonly [{
            readonly name: "_value";
            readonly type: "uint256";
        }, {
            readonly name: "_unlock_time";
            readonly type: "uint256";
        }];
        readonly outputs: readonly [];
    }, {
        readonly stateMutability: "nonpayable";
        readonly type: "function";
        readonly name: "increase_amount";
        readonly inputs: readonly [{
            readonly name: "_value";
            readonly type: "uint256";
        }];
        readonly outputs: readonly [];
    }, {
        readonly stateMutability: "nonpayable";
        readonly type: "function";
        readonly name: "increase_unlock_time";
        readonly inputs: readonly [{
            readonly name: "_unlock_time";
            readonly type: "uint256";
        }];
        readonly outputs: readonly [];
    }, {
        readonly stateMutability: "nonpayable";
        readonly type: "function";
        readonly name: "withdraw";
        readonly inputs: readonly [];
        readonly outputs: readonly [];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "balanceOf";
        readonly inputs: readonly [{
            readonly name: "addr";
            readonly type: "address";
        }];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "uint256";
        }];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "balanceOf";
        readonly inputs: readonly [{
            readonly name: "addr";
            readonly type: "address";
        }, {
            readonly name: "_t";
            readonly type: "uint256";
        }];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "uint256";
        }];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "balanceOfAt";
        readonly inputs: readonly [{
            readonly name: "addr";
            readonly type: "address";
        }, {
            readonly name: "_block";
            readonly type: "uint256";
        }];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "uint256";
        }];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "totalSupply";
        readonly inputs: readonly [];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "uint256";
        }];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "totalSupply";
        readonly inputs: readonly [{
            readonly name: "t";
            readonly type: "uint256";
        }];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "uint256";
        }];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "totalSupplyAt";
        readonly inputs: readonly [{
            readonly name: "_block";
            readonly type: "uint256";
        }];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "uint256";
        }];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "supply";
        readonly inputs: readonly [];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "uint256";
        }];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "locked";
        readonly inputs: readonly [{
            readonly name: "arg0";
            readonly type: "address";
        }];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "tuple";
            readonly components: readonly [{
                readonly name: "amount";
                readonly type: "int128";
            }, {
                readonly name: "end";
                readonly type: "uint256";
            }];
        }];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "epoch";
        readonly inputs: readonly [];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "uint256";
        }];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "point_history";
        readonly inputs: readonly [{
            readonly name: "arg0";
            readonly type: "uint256";
        }];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "tuple";
            readonly components: readonly [{
                readonly name: "bias";
                readonly type: "int128";
            }, {
                readonly name: "slope";
                readonly type: "int128";
            }, {
                readonly name: "ts";
                readonly type: "uint256";
            }, {
                readonly name: "blk";
                readonly type: "uint256";
            }];
        }];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "user_point_history";
        readonly inputs: readonly [{
            readonly name: "arg0";
            readonly type: "address";
        }, {
            readonly name: "arg1";
            readonly type: "uint256";
        }];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "tuple";
            readonly components: readonly [{
                readonly name: "bias";
                readonly type: "int128";
            }, {
                readonly name: "slope";
                readonly type: "int128";
            }, {
                readonly name: "ts";
                readonly type: "uint256";
            }, {
                readonly name: "blk";
                readonly type: "uint256";
            }];
        }];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "user_point_epoch";
        readonly inputs: readonly [{
            readonly name: "arg0";
            readonly type: "address";
        }];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "uint256";
        }];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "slope_changes";
        readonly inputs: readonly [{
            readonly name: "arg0";
            readonly type: "uint256";
        }];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "int128";
        }];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "future_smart_wallet_checker";
        readonly inputs: readonly [];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "address";
        }];
    }, {
        readonly stateMutability: "view";
        readonly type: "function";
        readonly name: "smart_wallet_checker";
        readonly inputs: readonly [];
        readonly outputs: readonly [{
            readonly name: "";
            readonly type: "address";
        }];
    }];
    static createInterface(): VeBalInterface;
    static connect(address: string, signerOrProvider: Signer | Provider): VeBal$1;
}

declare class VeDelegationProxy__factory {
    static readonly abi: readonly [{
        readonly inputs: readonly [{
            readonly internalType: "contract IVault";
            readonly name: "vault";
            readonly type: "address";
        }, {
            readonly internalType: "contract IERC20";
            readonly name: "votingEscrow";
            readonly type: "address";
        }, {
            readonly internalType: "contract IVeDelegation";
            readonly name: "delegation";
            readonly type: "address";
        }];
        readonly stateMutability: "nonpayable";
        readonly type: "constructor";
    }, {
        readonly anonymous: false;
        readonly inputs: readonly [{
            readonly indexed: true;
            readonly internalType: "address";
            readonly name: "newImplementation";
            readonly type: "address";
        }];
        readonly name: "DelegationImplementationUpdated";
        readonly type: "event";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "user";
            readonly type: "address";
        }];
        readonly name: "adjustedBalanceOf";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "address";
            readonly name: "user";
            readonly type: "address";
        }];
        readonly name: "adjusted_balance_of";
        readonly outputs: readonly [{
            readonly internalType: "uint256";
            readonly name: "";
            readonly type: "uint256";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "bytes4";
            readonly name: "selector";
            readonly type: "bytes4";
        }];
        readonly name: "getActionId";
        readonly outputs: readonly [{
            readonly internalType: "bytes32";
            readonly name: "";
            readonly type: "bytes32";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getAuthorizer";
        readonly outputs: readonly [{
            readonly internalType: "contract IAuthorizer";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getDelegationImplementation";
        readonly outputs: readonly [{
            readonly internalType: "contract IVeDelegation";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getVault";
        readonly outputs: readonly [{
            readonly internalType: "contract IVault";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "getVotingEscrow";
        readonly outputs: readonly [{
            readonly internalType: "contract IERC20";
            readonly name: "";
            readonly type: "address";
        }];
        readonly stateMutability: "view";
        readonly type: "function";
    }, {
        readonly inputs: readonly [];
        readonly name: "killDelegation";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }, {
        readonly inputs: readonly [{
            readonly internalType: "contract IVeDelegation";
            readonly name: "delegation";
            readonly type: "address";
        }];
        readonly name: "setDelegation";
        readonly outputs: readonly [];
        readonly stateMutability: "nonpayable";
        readonly type: "function";
    }];
    static createInterface(): VeDelegationProxyInterface;
    static connect(address: string, signerOrProvider: Signer | Provider): VeDelegationProxy;
}

type index_AaveLinearPool__factory = AaveLinearPool__factory;
declare const index_AaveLinearPool__factory: typeof AaveLinearPool__factory;
type index_AaveLinearPoolFactory__factory = AaveLinearPoolFactory__factory;
declare const index_AaveLinearPoolFactory__factory: typeof AaveLinearPoolFactory__factory;
type index_AaveWrapping__factory = AaveWrapping__factory;
declare const index_AaveWrapping__factory: typeof AaveWrapping__factory;
type index_Authoriser__factory = Authoriser__factory;
declare const index_Authoriser__factory: typeof Authoriser__factory;
type index_BalancerHelpers__factory = BalancerHelpers__factory;
declare const index_BalancerHelpers__factory: typeof BalancerHelpers__factory;
type index_BalancerMinter__factory = BalancerMinter__factory;
declare const index_BalancerMinter__factory: typeof BalancerMinter__factory;
type index_BalancerPoolDataQueries__factory = BalancerPoolDataQueries__factory;
declare const index_BalancerPoolDataQueries__factory: typeof BalancerPoolDataQueries__factory;
type index_BalancerRelayer__factory = BalancerRelayer__factory;
declare const index_BalancerRelayer__factory: typeof BalancerRelayer__factory;
type index_BatchRelayerLibrary__factory = BatchRelayerLibrary__factory;
declare const index_BatchRelayerLibrary__factory: typeof BatchRelayerLibrary__factory;
type index_ComposableStablePool__factory = ComposableStablePool__factory;
declare const index_ComposableStablePool__factory: typeof ComposableStablePool__factory;
type index_ComposableStablePoolFactory__factory = ComposableStablePoolFactory__factory;
declare const index_ComposableStablePoolFactory__factory: typeof ComposableStablePoolFactory__factory;
type index_ConvergentCurvePool__factory = ConvergentCurvePool__factory;
declare const index_ConvergentCurvePool__factory: typeof ConvergentCurvePool__factory;
type index_ERC20__factory = ERC20__factory;
declare const index_ERC20__factory: typeof ERC20__factory;
type index_ERC4626LinearPool__factory = ERC4626LinearPool__factory;
declare const index_ERC4626LinearPool__factory: typeof ERC4626LinearPool__factory;
type index_ERC4626LinearPoolFactory__factory = ERC4626LinearPoolFactory__factory;
declare const index_ERC4626LinearPoolFactory__factory: typeof ERC4626LinearPoolFactory__factory;
type index_EulerLinearPool__factory = EulerLinearPool__factory;
declare const index_EulerLinearPool__factory: typeof EulerLinearPool__factory;
type index_EulerLinearPoolFactory__factory = EulerLinearPoolFactory__factory;
declare const index_EulerLinearPoolFactory__factory: typeof EulerLinearPoolFactory__factory;
type index_FXPool__factory = FXPool__factory;
declare const index_FXPool__factory: typeof FXPool__factory;
type index_GaugeClaimHelper__factory = GaugeClaimHelper__factory;
declare const index_GaugeClaimHelper__factory: typeof GaugeClaimHelper__factory;
type index_GearboxLinearPool__factory = GearboxLinearPool__factory;
declare const index_GearboxLinearPool__factory: typeof GearboxLinearPool__factory;
type index_GearboxLinearPoolFactory__factory = GearboxLinearPoolFactory__factory;
declare const index_GearboxLinearPoolFactory__factory: typeof GearboxLinearPoolFactory__factory;
type index_GyroConfig__factory = GyroConfig__factory;
declare const index_GyroConfig__factory: typeof GyroConfig__factory;
type index_LidoRelayer__factory = LidoRelayer__factory;
declare const index_LidoRelayer__factory: typeof LidoRelayer__factory;
type index_LinearPool__factory = LinearPool__factory;
declare const index_LinearPool__factory: typeof LinearPool__factory;
type index_LiquidityGaugeV5__factory = LiquidityGaugeV5__factory;
declare const index_LiquidityGaugeV5__factory: typeof LiquidityGaugeV5__factory;
type index_Multicall__factory = Multicall__factory;
declare const index_Multicall__factory: typeof Multicall__factory;
type index_Multicall3__factory = Multicall3__factory;
declare const index_Multicall3__factory: typeof Multicall3__factory;
type index_StablePool__factory = StablePool__factory;
declare const index_StablePool__factory: typeof StablePool__factory;
type index_StaticATokenRateProvider__factory = StaticATokenRateProvider__factory;
declare const index_StaticATokenRateProvider__factory: typeof StaticATokenRateProvider__factory;
type index_Vault__factory = Vault__factory;
declare const index_Vault__factory: typeof Vault__factory;
type index_WeightedPool__factory = WeightedPool__factory;
declare const index_WeightedPool__factory: typeof WeightedPool__factory;
type index_WeightedPoolFactory__factory = WeightedPoolFactory__factory;
declare const index_WeightedPoolFactory__factory: typeof WeightedPoolFactory__factory;
type index_YearnLinearPool__factory = YearnLinearPool__factory;
declare const index_YearnLinearPool__factory: typeof YearnLinearPool__factory;
type index_YearnLinearPoolFactory__factory = YearnLinearPoolFactory__factory;
declare const index_YearnLinearPoolFactory__factory: typeof YearnLinearPoolFactory__factory;
type index_GyroEV2__factory = GyroEV2__factory;
declare const index_GyroEV2__factory: typeof GyroEV2__factory;
type index_VeBal__factory = VeBal__factory;
declare const index_VeBal__factory: typeof VeBal__factory;
type index_VeDelegationProxy__factory = VeDelegationProxy__factory;
declare const index_VeDelegationProxy__factory: typeof VeDelegationProxy__factory;
declare namespace index {
  export {
    index_AaveLinearPool__factory as AaveLinearPool__factory,
    index_AaveLinearPoolFactory__factory as AaveLinearPoolFactory__factory,
    index_AaveWrapping__factory as AaveWrapping__factory,
    index_Authoriser__factory as Authoriser__factory,
    index_BalancerHelpers__factory as BalancerHelpers__factory,
    index_BalancerMinter__factory as BalancerMinter__factory,
    index_BalancerPoolDataQueries__factory as BalancerPoolDataQueries__factory,
    index_BalancerRelayer__factory as BalancerRelayer__factory,
    index_BatchRelayerLibrary__factory as BatchRelayerLibrary__factory,
    index_ComposableStablePool__factory as ComposableStablePool__factory,
    index_ComposableStablePoolFactory__factory as ComposableStablePoolFactory__factory,
    index_ConvergentCurvePool__factory as ConvergentCurvePool__factory,
    index_ERC20__factory as ERC20__factory,
    index_ERC4626LinearPool__factory as ERC4626LinearPool__factory,
    index_ERC4626LinearPoolFactory__factory as ERC4626LinearPoolFactory__factory,
    index_EulerLinearPool__factory as EulerLinearPool__factory,
    index_EulerLinearPoolFactory__factory as EulerLinearPoolFactory__factory,
    index_FXPool__factory as FXPool__factory,
    index_GaugeClaimHelper__factory as GaugeClaimHelper__factory,
    index_GearboxLinearPool__factory as GearboxLinearPool__factory,
    index_GearboxLinearPoolFactory__factory as GearboxLinearPoolFactory__factory,
    index_GyroConfig__factory as GyroConfig__factory,
    index_LidoRelayer__factory as LidoRelayer__factory,
    index_LinearPool__factory as LinearPool__factory,
    index_LiquidityGaugeV5__factory as LiquidityGaugeV5__factory,
    index_Multicall__factory as Multicall__factory,
    index_Multicall3__factory as Multicall3__factory,
    index_StablePool__factory as StablePool__factory,
    index_StaticATokenRateProvider__factory as StaticATokenRateProvider__factory,
    index_Vault__factory as Vault__factory,
    index_WeightedPool__factory as WeightedPool__factory,
    index_WeightedPoolFactory__factory as WeightedPoolFactory__factory,
    index_YearnLinearPool__factory as YearnLinearPool__factory,
    index_YearnLinearPoolFactory__factory as YearnLinearPoolFactory__factory,
    index_GyroEV2__factory as GyroEV2__factory,
    index_VeBal__factory as VeBal__factory,
    index_VeDelegationProxy__factory as VeDelegationProxy__factory,
  };
}

declare class GaugeControllerMulticallRepository {
    private multicall;
    private gaugeControllerAddress;
    private gaugeControllerCheckpointerAddress?;
    constructor(multicall: Multicall, gaugeControllerAddress: string, gaugeControllerCheckpointerAddress?: string | undefined);
    getRelativeWeights(gaugeAddresses: string[], timestamp?: number): Promise<{
        [gaugeAddress: string]: number;
    }>;
}

interface RewardData {
    token: string;
    distributor: string;
    period_finish: BigNumber;
    rate: BigNumber;
    last_update: BigNumber;
    integral: BigNumber;
    decimals?: number;
}
/**
 * A lot of code to get liquidity gauge state via RPC multicall.
 * TODO: reseach helper contracts or extend subgraph
 */
declare class LiquidityGaugesMulticallRepository {
    private multicall;
    private chainId;
    constructor(multicall: Multicall, chainId: Network);
    getTotalSupplies(gaugeAddresses: string[]): Promise<{
        [gaugeAddress: string]: number;
    }>;
    getWorkingSupplies(gaugeAddresses: string[]): Promise<{
        [gaugeAddress: string]: number;
    }>;
    getInflationRates(gaugeAddresses: string[]): Promise<{
        [gaugeAddress: string]: number;
    }>;
    getRewardCounts(gaugeAddresses: string[]): Promise<{
        [gaugeAddress: string]: number;
    }>;
    getRewardTokens(gaugeAddresses: string[], passingRewardCounts?: {
        [gaugeAddress: string]: number;
    }): Promise<{
        [gaugeAddress: string]: string[];
    }>;
    getRewardData(gaugeAddresses: string[], passingRewardTokens?: {
        [gaugeAddress: string]: string[];
    }): Promise<{
        [gaugeAddress: string]: {
            [rewardTokenAddress: string]: RewardData;
        };
    }>;
}

type Maybe$1<T> = T | null;
type InputMaybe$1<T> = Maybe$1<T>;
type Exact$1<T extends {
    [key: string]: unknown;
}> = {
    [K in keyof T]: T[K];
};
/** All built-in and custom scalars, mapped to their actual values */
type Scalars$1 = {
    ID: string;
    String: string;
    Boolean: boolean;
    Int: number;
    Float: number;
    BigDecimal: string;
    BigInt: string;
    Bytes: string;
    Int8: any;
};
type AmpUpdate_Filter = {
    /** Filter for the block changed event. */
    _change_block?: InputMaybe$1<BlockChangedFilter$1>;
    and?: InputMaybe$1<Array<InputMaybe$1<AmpUpdate_Filter>>>;
    endAmp?: InputMaybe$1<Scalars$1['BigInt']>;
    endAmp_gt?: InputMaybe$1<Scalars$1['BigInt']>;
    endAmp_gte?: InputMaybe$1<Scalars$1['BigInt']>;
    endAmp_in?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
    endAmp_lt?: InputMaybe$1<Scalars$1['BigInt']>;
    endAmp_lte?: InputMaybe$1<Scalars$1['BigInt']>;
    endAmp_not?: InputMaybe$1<Scalars$1['BigInt']>;
    endAmp_not_in?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
    endTimestamp?: InputMaybe$1<Scalars$1['BigInt']>;
    endTimestamp_gt?: InputMaybe$1<Scalars$1['BigInt']>;
    endTimestamp_gte?: InputMaybe$1<Scalars$1['BigInt']>;
    endTimestamp_in?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
    endTimestamp_lt?: InputMaybe$1<Scalars$1['BigInt']>;
    endTimestamp_lte?: InputMaybe$1<Scalars$1['BigInt']>;
    endTimestamp_not?: InputMaybe$1<Scalars$1['BigInt']>;
    endTimestamp_not_in?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
    id?: InputMaybe$1<Scalars$1['ID']>;
    id_gt?: InputMaybe$1<Scalars$1['ID']>;
    id_gte?: InputMaybe$1<Scalars$1['ID']>;
    id_in?: InputMaybe$1<Array<Scalars$1['ID']>>;
    id_lt?: InputMaybe$1<Scalars$1['ID']>;
    id_lte?: InputMaybe$1<Scalars$1['ID']>;
    id_not?: InputMaybe$1<Scalars$1['ID']>;
    id_not_in?: InputMaybe$1<Array<Scalars$1['ID']>>;
    or?: InputMaybe$1<Array<InputMaybe$1<AmpUpdate_Filter>>>;
    poolId?: InputMaybe$1<Scalars$1['String']>;
    poolId_?: InputMaybe$1<Pool_Filter$1>;
    poolId_contains?: InputMaybe$1<Scalars$1['String']>;
    poolId_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolId_ends_with?: InputMaybe$1<Scalars$1['String']>;
    poolId_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolId_gt?: InputMaybe$1<Scalars$1['String']>;
    poolId_gte?: InputMaybe$1<Scalars$1['String']>;
    poolId_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    poolId_lt?: InputMaybe$1<Scalars$1['String']>;
    poolId_lte?: InputMaybe$1<Scalars$1['String']>;
    poolId_not?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_contains?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_ends_with?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    poolId_not_starts_with?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolId_starts_with?: InputMaybe$1<Scalars$1['String']>;
    poolId_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    scheduledTimestamp?: InputMaybe$1<Scalars$1['Int']>;
    scheduledTimestamp_gt?: InputMaybe$1<Scalars$1['Int']>;
    scheduledTimestamp_gte?: InputMaybe$1<Scalars$1['Int']>;
    scheduledTimestamp_in?: InputMaybe$1<Array<Scalars$1['Int']>>;
    scheduledTimestamp_lt?: InputMaybe$1<Scalars$1['Int']>;
    scheduledTimestamp_lte?: InputMaybe$1<Scalars$1['Int']>;
    scheduledTimestamp_not?: InputMaybe$1<Scalars$1['Int']>;
    scheduledTimestamp_not_in?: InputMaybe$1<Array<Scalars$1['Int']>>;
    startAmp?: InputMaybe$1<Scalars$1['BigInt']>;
    startAmp_gt?: InputMaybe$1<Scalars$1['BigInt']>;
    startAmp_gte?: InputMaybe$1<Scalars$1['BigInt']>;
    startAmp_in?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
    startAmp_lt?: InputMaybe$1<Scalars$1['BigInt']>;
    startAmp_lte?: InputMaybe$1<Scalars$1['BigInt']>;
    startAmp_not?: InputMaybe$1<Scalars$1['BigInt']>;
    startAmp_not_in?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
    startTimestamp?: InputMaybe$1<Scalars$1['BigInt']>;
    startTimestamp_gt?: InputMaybe$1<Scalars$1['BigInt']>;
    startTimestamp_gte?: InputMaybe$1<Scalars$1['BigInt']>;
    startTimestamp_in?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
    startTimestamp_lt?: InputMaybe$1<Scalars$1['BigInt']>;
    startTimestamp_lte?: InputMaybe$1<Scalars$1['BigInt']>;
    startTimestamp_not?: InputMaybe$1<Scalars$1['BigInt']>;
    startTimestamp_not_in?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
};
type Balancer_Filter = {
    /** Filter for the block changed event. */
    _change_block?: InputMaybe$1<BlockChangedFilter$1>;
    and?: InputMaybe$1<Array<InputMaybe$1<Balancer_Filter>>>;
    id?: InputMaybe$1<Scalars$1['ID']>;
    id_gt?: InputMaybe$1<Scalars$1['ID']>;
    id_gte?: InputMaybe$1<Scalars$1['ID']>;
    id_in?: InputMaybe$1<Array<Scalars$1['ID']>>;
    id_lt?: InputMaybe$1<Scalars$1['ID']>;
    id_lte?: InputMaybe$1<Scalars$1['ID']>;
    id_not?: InputMaybe$1<Scalars$1['ID']>;
    id_not_in?: InputMaybe$1<Array<Scalars$1['ID']>>;
    or?: InputMaybe$1<Array<InputMaybe$1<Balancer_Filter>>>;
    poolCount?: InputMaybe$1<Scalars$1['Int']>;
    poolCount_gt?: InputMaybe$1<Scalars$1['Int']>;
    poolCount_gte?: InputMaybe$1<Scalars$1['Int']>;
    poolCount_in?: InputMaybe$1<Array<Scalars$1['Int']>>;
    poolCount_lt?: InputMaybe$1<Scalars$1['Int']>;
    poolCount_lte?: InputMaybe$1<Scalars$1['Int']>;
    poolCount_not?: InputMaybe$1<Scalars$1['Int']>;
    poolCount_not_in?: InputMaybe$1<Array<Scalars$1['Int']>>;
    pools_?: InputMaybe$1<Pool_Filter$1>;
    protocolFeesCollector?: InputMaybe$1<Scalars$1['Bytes']>;
    protocolFeesCollector_contains?: InputMaybe$1<Scalars$1['Bytes']>;
    protocolFeesCollector_gt?: InputMaybe$1<Scalars$1['Bytes']>;
    protocolFeesCollector_gte?: InputMaybe$1<Scalars$1['Bytes']>;
    protocolFeesCollector_in?: InputMaybe$1<Array<Scalars$1['Bytes']>>;
    protocolFeesCollector_lt?: InputMaybe$1<Scalars$1['Bytes']>;
    protocolFeesCollector_lte?: InputMaybe$1<Scalars$1['Bytes']>;
    protocolFeesCollector_not?: InputMaybe$1<Scalars$1['Bytes']>;
    protocolFeesCollector_not_contains?: InputMaybe$1<Scalars$1['Bytes']>;
    protocolFeesCollector_not_in?: InputMaybe$1<Array<Scalars$1['Bytes']>>;
    totalLiquidity?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalLiquidity_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalLiquidity_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalLiquidity_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    totalLiquidity_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalLiquidity_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalLiquidity_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalLiquidity_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    totalProtocolFee?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalProtocolFee_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalProtocolFee_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalProtocolFee_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    totalProtocolFee_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalProtocolFee_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalProtocolFee_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalProtocolFee_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    totalSwapCount?: InputMaybe$1<Scalars$1['BigInt']>;
    totalSwapCount_gt?: InputMaybe$1<Scalars$1['BigInt']>;
    totalSwapCount_gte?: InputMaybe$1<Scalars$1['BigInt']>;
    totalSwapCount_in?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
    totalSwapCount_lt?: InputMaybe$1<Scalars$1['BigInt']>;
    totalSwapCount_lte?: InputMaybe$1<Scalars$1['BigInt']>;
    totalSwapCount_not?: InputMaybe$1<Scalars$1['BigInt']>;
    totalSwapCount_not_in?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
    totalSwapFee?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalSwapFee_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalSwapFee_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalSwapFee_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    totalSwapFee_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalSwapFee_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalSwapFee_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalSwapFee_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    totalSwapVolume?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalSwapVolume_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalSwapVolume_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalSwapVolume_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    totalSwapVolume_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalSwapVolume_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalSwapVolume_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalSwapVolume_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
};
declare enum Balancer_OrderBy {
    Id = "id",
    PoolCount = "poolCount",
    Pools = "pools",
    ProtocolFeesCollector = "protocolFeesCollector",
    TotalLiquidity = "totalLiquidity",
    TotalProtocolFee = "totalProtocolFee",
    TotalSwapCount = "totalSwapCount",
    TotalSwapFee = "totalSwapFee",
    TotalSwapVolume = "totalSwapVolume"
}
type BlockChangedFilter$1 = {
    number_gte: Scalars$1['Int'];
};
type Block_Height$1 = {
    hash?: InputMaybe$1<Scalars$1['Bytes']>;
    number?: InputMaybe$1<Scalars$1['Int']>;
    number_gte?: InputMaybe$1<Scalars$1['Int']>;
};
type CircuitBreaker_Filter = {
    /** Filter for the block changed event. */
    _change_block?: InputMaybe$1<BlockChangedFilter$1>;
    and?: InputMaybe$1<Array<InputMaybe$1<CircuitBreaker_Filter>>>;
    bptPrice?: InputMaybe$1<Scalars$1['BigDecimal']>;
    bptPrice_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    bptPrice_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    bptPrice_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    bptPrice_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    bptPrice_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    bptPrice_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    bptPrice_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    id?: InputMaybe$1<Scalars$1['ID']>;
    id_gt?: InputMaybe$1<Scalars$1['ID']>;
    id_gte?: InputMaybe$1<Scalars$1['ID']>;
    id_in?: InputMaybe$1<Array<Scalars$1['ID']>>;
    id_lt?: InputMaybe$1<Scalars$1['ID']>;
    id_lte?: InputMaybe$1<Scalars$1['ID']>;
    id_not?: InputMaybe$1<Scalars$1['ID']>;
    id_not_in?: InputMaybe$1<Array<Scalars$1['ID']>>;
    lowerBoundPercentage?: InputMaybe$1<Scalars$1['BigDecimal']>;
    lowerBoundPercentage_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    lowerBoundPercentage_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    lowerBoundPercentage_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    lowerBoundPercentage_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    lowerBoundPercentage_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    lowerBoundPercentage_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    lowerBoundPercentage_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    or?: InputMaybe$1<Array<InputMaybe$1<CircuitBreaker_Filter>>>;
    pool?: InputMaybe$1<Scalars$1['String']>;
    pool_?: InputMaybe$1<Pool_Filter$1>;
    pool_contains?: InputMaybe$1<Scalars$1['String']>;
    pool_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    pool_ends_with?: InputMaybe$1<Scalars$1['String']>;
    pool_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    pool_gt?: InputMaybe$1<Scalars$1['String']>;
    pool_gte?: InputMaybe$1<Scalars$1['String']>;
    pool_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    pool_lt?: InputMaybe$1<Scalars$1['String']>;
    pool_lte?: InputMaybe$1<Scalars$1['String']>;
    pool_not?: InputMaybe$1<Scalars$1['String']>;
    pool_not_contains?: InputMaybe$1<Scalars$1['String']>;
    pool_not_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    pool_not_ends_with?: InputMaybe$1<Scalars$1['String']>;
    pool_not_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    pool_not_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    pool_not_starts_with?: InputMaybe$1<Scalars$1['String']>;
    pool_not_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    pool_starts_with?: InputMaybe$1<Scalars$1['String']>;
    pool_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    token?: InputMaybe$1<Scalars$1['String']>;
    token_?: InputMaybe$1<PoolToken_Filter>;
    token_contains?: InputMaybe$1<Scalars$1['String']>;
    token_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    token_ends_with?: InputMaybe$1<Scalars$1['String']>;
    token_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    token_gt?: InputMaybe$1<Scalars$1['String']>;
    token_gte?: InputMaybe$1<Scalars$1['String']>;
    token_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    token_lt?: InputMaybe$1<Scalars$1['String']>;
    token_lte?: InputMaybe$1<Scalars$1['String']>;
    token_not?: InputMaybe$1<Scalars$1['String']>;
    token_not_contains?: InputMaybe$1<Scalars$1['String']>;
    token_not_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    token_not_ends_with?: InputMaybe$1<Scalars$1['String']>;
    token_not_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    token_not_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    token_not_starts_with?: InputMaybe$1<Scalars$1['String']>;
    token_not_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    token_starts_with?: InputMaybe$1<Scalars$1['String']>;
    token_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    upperBoundPercentage?: InputMaybe$1<Scalars$1['BigDecimal']>;
    upperBoundPercentage_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    upperBoundPercentage_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    upperBoundPercentage_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    upperBoundPercentage_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    upperBoundPercentage_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    upperBoundPercentage_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    upperBoundPercentage_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
};
type GradualWeightUpdate_Filter = {
    /** Filter for the block changed event. */
    _change_block?: InputMaybe$1<BlockChangedFilter$1>;
    and?: InputMaybe$1<Array<InputMaybe$1<GradualWeightUpdate_Filter>>>;
    endTimestamp?: InputMaybe$1<Scalars$1['BigInt']>;
    endTimestamp_gt?: InputMaybe$1<Scalars$1['BigInt']>;
    endTimestamp_gte?: InputMaybe$1<Scalars$1['BigInt']>;
    endTimestamp_in?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
    endTimestamp_lt?: InputMaybe$1<Scalars$1['BigInt']>;
    endTimestamp_lte?: InputMaybe$1<Scalars$1['BigInt']>;
    endTimestamp_not?: InputMaybe$1<Scalars$1['BigInt']>;
    endTimestamp_not_in?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
    endWeights?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
    endWeights_contains?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
    endWeights_contains_nocase?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
    endWeights_not?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
    endWeights_not_contains?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
    endWeights_not_contains_nocase?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
    id?: InputMaybe$1<Scalars$1['ID']>;
    id_gt?: InputMaybe$1<Scalars$1['ID']>;
    id_gte?: InputMaybe$1<Scalars$1['ID']>;
    id_in?: InputMaybe$1<Array<Scalars$1['ID']>>;
    id_lt?: InputMaybe$1<Scalars$1['ID']>;
    id_lte?: InputMaybe$1<Scalars$1['ID']>;
    id_not?: InputMaybe$1<Scalars$1['ID']>;
    id_not_in?: InputMaybe$1<Array<Scalars$1['ID']>>;
    or?: InputMaybe$1<Array<InputMaybe$1<GradualWeightUpdate_Filter>>>;
    poolId?: InputMaybe$1<Scalars$1['String']>;
    poolId_?: InputMaybe$1<Pool_Filter$1>;
    poolId_contains?: InputMaybe$1<Scalars$1['String']>;
    poolId_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolId_ends_with?: InputMaybe$1<Scalars$1['String']>;
    poolId_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolId_gt?: InputMaybe$1<Scalars$1['String']>;
    poolId_gte?: InputMaybe$1<Scalars$1['String']>;
    poolId_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    poolId_lt?: InputMaybe$1<Scalars$1['String']>;
    poolId_lte?: InputMaybe$1<Scalars$1['String']>;
    poolId_not?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_contains?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_ends_with?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    poolId_not_starts_with?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolId_starts_with?: InputMaybe$1<Scalars$1['String']>;
    poolId_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    scheduledTimestamp?: InputMaybe$1<Scalars$1['Int']>;
    scheduledTimestamp_gt?: InputMaybe$1<Scalars$1['Int']>;
    scheduledTimestamp_gte?: InputMaybe$1<Scalars$1['Int']>;
    scheduledTimestamp_in?: InputMaybe$1<Array<Scalars$1['Int']>>;
    scheduledTimestamp_lt?: InputMaybe$1<Scalars$1['Int']>;
    scheduledTimestamp_lte?: InputMaybe$1<Scalars$1['Int']>;
    scheduledTimestamp_not?: InputMaybe$1<Scalars$1['Int']>;
    scheduledTimestamp_not_in?: InputMaybe$1<Array<Scalars$1['Int']>>;
    startTimestamp?: InputMaybe$1<Scalars$1['BigInt']>;
    startTimestamp_gt?: InputMaybe$1<Scalars$1['BigInt']>;
    startTimestamp_gte?: InputMaybe$1<Scalars$1['BigInt']>;
    startTimestamp_in?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
    startTimestamp_lt?: InputMaybe$1<Scalars$1['BigInt']>;
    startTimestamp_lte?: InputMaybe$1<Scalars$1['BigInt']>;
    startTimestamp_not?: InputMaybe$1<Scalars$1['BigInt']>;
    startTimestamp_not_in?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
    startWeights?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
    startWeights_contains?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
    startWeights_contains_nocase?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
    startWeights_not?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
    startWeights_not_contains?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
    startWeights_not_contains_nocase?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
};
declare enum InvestType {
    Exit = "Exit",
    Join = "Join"
}
type JoinExit_Filter = {
    /** Filter for the block changed event. */
    _change_block?: InputMaybe$1<BlockChangedFilter$1>;
    amounts?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    amounts_contains?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    amounts_contains_nocase?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    amounts_not?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    amounts_not_contains?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    amounts_not_contains_nocase?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    and?: InputMaybe$1<Array<InputMaybe$1<JoinExit_Filter>>>;
    id?: InputMaybe$1<Scalars$1['ID']>;
    id_gt?: InputMaybe$1<Scalars$1['ID']>;
    id_gte?: InputMaybe$1<Scalars$1['ID']>;
    id_in?: InputMaybe$1<Array<Scalars$1['ID']>>;
    id_lt?: InputMaybe$1<Scalars$1['ID']>;
    id_lte?: InputMaybe$1<Scalars$1['ID']>;
    id_not?: InputMaybe$1<Scalars$1['ID']>;
    id_not_in?: InputMaybe$1<Array<Scalars$1['ID']>>;
    or?: InputMaybe$1<Array<InputMaybe$1<JoinExit_Filter>>>;
    pool?: InputMaybe$1<Scalars$1['String']>;
    pool_?: InputMaybe$1<Pool_Filter$1>;
    pool_contains?: InputMaybe$1<Scalars$1['String']>;
    pool_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    pool_ends_with?: InputMaybe$1<Scalars$1['String']>;
    pool_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    pool_gt?: InputMaybe$1<Scalars$1['String']>;
    pool_gte?: InputMaybe$1<Scalars$1['String']>;
    pool_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    pool_lt?: InputMaybe$1<Scalars$1['String']>;
    pool_lte?: InputMaybe$1<Scalars$1['String']>;
    pool_not?: InputMaybe$1<Scalars$1['String']>;
    pool_not_contains?: InputMaybe$1<Scalars$1['String']>;
    pool_not_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    pool_not_ends_with?: InputMaybe$1<Scalars$1['String']>;
    pool_not_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    pool_not_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    pool_not_starts_with?: InputMaybe$1<Scalars$1['String']>;
    pool_not_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    pool_starts_with?: InputMaybe$1<Scalars$1['String']>;
    pool_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    sender?: InputMaybe$1<Scalars$1['Bytes']>;
    sender_contains?: InputMaybe$1<Scalars$1['Bytes']>;
    sender_gt?: InputMaybe$1<Scalars$1['Bytes']>;
    sender_gte?: InputMaybe$1<Scalars$1['Bytes']>;
    sender_in?: InputMaybe$1<Array<Scalars$1['Bytes']>>;
    sender_lt?: InputMaybe$1<Scalars$1['Bytes']>;
    sender_lte?: InputMaybe$1<Scalars$1['Bytes']>;
    sender_not?: InputMaybe$1<Scalars$1['Bytes']>;
    sender_not_contains?: InputMaybe$1<Scalars$1['Bytes']>;
    sender_not_in?: InputMaybe$1<Array<Scalars$1['Bytes']>>;
    timestamp?: InputMaybe$1<Scalars$1['Int']>;
    timestamp_gt?: InputMaybe$1<Scalars$1['Int']>;
    timestamp_gte?: InputMaybe$1<Scalars$1['Int']>;
    timestamp_in?: InputMaybe$1<Array<Scalars$1['Int']>>;
    timestamp_lt?: InputMaybe$1<Scalars$1['Int']>;
    timestamp_lte?: InputMaybe$1<Scalars$1['Int']>;
    timestamp_not?: InputMaybe$1<Scalars$1['Int']>;
    timestamp_not_in?: InputMaybe$1<Array<Scalars$1['Int']>>;
    tx?: InputMaybe$1<Scalars$1['Bytes']>;
    tx_contains?: InputMaybe$1<Scalars$1['Bytes']>;
    tx_gt?: InputMaybe$1<Scalars$1['Bytes']>;
    tx_gte?: InputMaybe$1<Scalars$1['Bytes']>;
    tx_in?: InputMaybe$1<Array<Scalars$1['Bytes']>>;
    tx_lt?: InputMaybe$1<Scalars$1['Bytes']>;
    tx_lte?: InputMaybe$1<Scalars$1['Bytes']>;
    tx_not?: InputMaybe$1<Scalars$1['Bytes']>;
    tx_not_contains?: InputMaybe$1<Scalars$1['Bytes']>;
    tx_not_in?: InputMaybe$1<Array<Scalars$1['Bytes']>>;
    type?: InputMaybe$1<InvestType>;
    type_in?: InputMaybe$1<Array<InvestType>>;
    type_not?: InputMaybe$1<InvestType>;
    type_not_in?: InputMaybe$1<Array<InvestType>>;
    user?: InputMaybe$1<Scalars$1['String']>;
    user_?: InputMaybe$1<User_Filter$1>;
    user_contains?: InputMaybe$1<Scalars$1['String']>;
    user_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    user_ends_with?: InputMaybe$1<Scalars$1['String']>;
    user_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    user_gt?: InputMaybe$1<Scalars$1['String']>;
    user_gte?: InputMaybe$1<Scalars$1['String']>;
    user_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    user_lt?: InputMaybe$1<Scalars$1['String']>;
    user_lte?: InputMaybe$1<Scalars$1['String']>;
    user_not?: InputMaybe$1<Scalars$1['String']>;
    user_not_contains?: InputMaybe$1<Scalars$1['String']>;
    user_not_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    user_not_ends_with?: InputMaybe$1<Scalars$1['String']>;
    user_not_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    user_not_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    user_not_starts_with?: InputMaybe$1<Scalars$1['String']>;
    user_not_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    user_starts_with?: InputMaybe$1<Scalars$1['String']>;
    user_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    valueUSD?: InputMaybe$1<Scalars$1['BigDecimal']>;
    valueUSD_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    valueUSD_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    valueUSD_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    valueUSD_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    valueUSD_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    valueUSD_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    valueUSD_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
};
declare enum JoinExit_OrderBy {
    Amounts = "amounts",
    Id = "id",
    Pool = "pool",
    PoolAddress = "pool__address",
    PoolAlpha = "pool__alpha",
    PoolAmp = "pool__amp",
    PoolBaseToken = "pool__baseToken",
    PoolBeta = "pool__beta",
    PoolC = "pool__c",
    PoolCreateTime = "pool__createTime",
    PoolDSq = "pool__dSq",
    PoolDelta = "pool__delta",
    PoolEpsilon = "pool__epsilon",
    PoolExpiryTime = "pool__expiryTime",
    PoolFactory = "pool__factory",
    PoolHoldersCount = "pool__holdersCount",
    PoolId = "pool__id",
    PoolIsInRecoveryMode = "pool__isInRecoveryMode",
    PoolIsPaused = "pool__isPaused",
    PoolJoinExitEnabled = "pool__joinExitEnabled",
    PoolLambda = "pool__lambda",
    PoolLastJoinExitAmp = "pool__lastJoinExitAmp",
    PoolLastPostJoinExitInvariant = "pool__lastPostJoinExitInvariant",
    PoolLowerTarget = "pool__lowerTarget",
    PoolMainIndex = "pool__mainIndex",
    PoolManagementAumFee = "pool__managementAumFee",
    PoolManagementFee = "pool__managementFee",
    PoolMustAllowlistLPs = "pool__mustAllowlistLPs",
    PoolName = "pool__name",
    PoolOracleEnabled = "pool__oracleEnabled",
    PoolOwner = "pool__owner",
    PoolPoolType = "pool__poolType",
    PoolPoolTypeVersion = "pool__poolTypeVersion",
    PoolPrincipalToken = "pool__principalToken",
    PoolProtocolAumFeeCache = "pool__protocolAumFeeCache",
    PoolProtocolId = "pool__protocolId",
    PoolProtocolSwapFeeCache = "pool__protocolSwapFeeCache",
    PoolProtocolYieldFeeCache = "pool__protocolYieldFeeCache",
    PoolRoot3Alpha = "pool__root3Alpha",
    PoolS = "pool__s",
    PoolSqrtAlpha = "pool__sqrtAlpha",
    PoolSqrtBeta = "pool__sqrtBeta",
    PoolStrategyType = "pool__strategyType",
    PoolSwapEnabled = "pool__swapEnabled",
    PoolSwapEnabledCurationSignal = "pool__swapEnabledCurationSignal",
    PoolSwapEnabledInternal = "pool__swapEnabledInternal",
    PoolSwapFee = "pool__swapFee",
    PoolSwapsCount = "pool__swapsCount",
    PoolSymbol = "pool__symbol",
    PoolTauAlphaX = "pool__tauAlphaX",
    PoolTauAlphaY = "pool__tauAlphaY",
    PoolTauBetaX = "pool__tauBetaX",
    PoolTauBetaY = "pool__tauBetaY",
    PoolTotalAumFeeCollectedInBpt = "pool__totalAumFeeCollectedInBPT",
    PoolTotalLiquidity = "pool__totalLiquidity",
    PoolTotalLiquiditySansBpt = "pool__totalLiquiditySansBPT",
    PoolTotalProtocolFee = "pool__totalProtocolFee",
    PoolTotalProtocolFeePaidInBpt = "pool__totalProtocolFeePaidInBPT",
    PoolTotalShares = "pool__totalShares",
    PoolTotalSwapFee = "pool__totalSwapFee",
    PoolTotalSwapVolume = "pool__totalSwapVolume",
    PoolTotalWeight = "pool__totalWeight",
    PoolTx = "pool__tx",
    PoolU = "pool__u",
    PoolUnitSeconds = "pool__unitSeconds",
    PoolUpperTarget = "pool__upperTarget",
    PoolV = "pool__v",
    PoolW = "pool__w",
    PoolWrappedIndex = "pool__wrappedIndex",
    PoolZ = "pool__z",
    Sender = "sender",
    Timestamp = "timestamp",
    Tx = "tx",
    Type = "type",
    User = "user",
    UserId = "user__id",
    ValueUsd = "valueUSD"
}
type LatestPrice_Filter = {
    /** Filter for the block changed event. */
    _change_block?: InputMaybe$1<BlockChangedFilter$1>;
    and?: InputMaybe$1<Array<InputMaybe$1<LatestPrice_Filter>>>;
    asset?: InputMaybe$1<Scalars$1['Bytes']>;
    asset_contains?: InputMaybe$1<Scalars$1['Bytes']>;
    asset_gt?: InputMaybe$1<Scalars$1['Bytes']>;
    asset_gte?: InputMaybe$1<Scalars$1['Bytes']>;
    asset_in?: InputMaybe$1<Array<Scalars$1['Bytes']>>;
    asset_lt?: InputMaybe$1<Scalars$1['Bytes']>;
    asset_lte?: InputMaybe$1<Scalars$1['Bytes']>;
    asset_not?: InputMaybe$1<Scalars$1['Bytes']>;
    asset_not_contains?: InputMaybe$1<Scalars$1['Bytes']>;
    asset_not_in?: InputMaybe$1<Array<Scalars$1['Bytes']>>;
    block?: InputMaybe$1<Scalars$1['BigInt']>;
    block_gt?: InputMaybe$1<Scalars$1['BigInt']>;
    block_gte?: InputMaybe$1<Scalars$1['BigInt']>;
    block_in?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
    block_lt?: InputMaybe$1<Scalars$1['BigInt']>;
    block_lte?: InputMaybe$1<Scalars$1['BigInt']>;
    block_not?: InputMaybe$1<Scalars$1['BigInt']>;
    block_not_in?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
    id?: InputMaybe$1<Scalars$1['ID']>;
    id_gt?: InputMaybe$1<Scalars$1['ID']>;
    id_gte?: InputMaybe$1<Scalars$1['ID']>;
    id_in?: InputMaybe$1<Array<Scalars$1['ID']>>;
    id_lt?: InputMaybe$1<Scalars$1['ID']>;
    id_lte?: InputMaybe$1<Scalars$1['ID']>;
    id_not?: InputMaybe$1<Scalars$1['ID']>;
    id_not_in?: InputMaybe$1<Array<Scalars$1['ID']>>;
    or?: InputMaybe$1<Array<InputMaybe$1<LatestPrice_Filter>>>;
    poolId?: InputMaybe$1<Scalars$1['String']>;
    poolId_?: InputMaybe$1<Pool_Filter$1>;
    poolId_contains?: InputMaybe$1<Scalars$1['String']>;
    poolId_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolId_ends_with?: InputMaybe$1<Scalars$1['String']>;
    poolId_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolId_gt?: InputMaybe$1<Scalars$1['String']>;
    poolId_gte?: InputMaybe$1<Scalars$1['String']>;
    poolId_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    poolId_lt?: InputMaybe$1<Scalars$1['String']>;
    poolId_lte?: InputMaybe$1<Scalars$1['String']>;
    poolId_not?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_contains?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_ends_with?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    poolId_not_starts_with?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolId_starts_with?: InputMaybe$1<Scalars$1['String']>;
    poolId_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    price?: InputMaybe$1<Scalars$1['BigDecimal']>;
    price_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    price_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    price_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    price_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    price_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    price_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    price_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    pricingAsset?: InputMaybe$1<Scalars$1['Bytes']>;
    pricingAsset_contains?: InputMaybe$1<Scalars$1['Bytes']>;
    pricingAsset_gt?: InputMaybe$1<Scalars$1['Bytes']>;
    pricingAsset_gte?: InputMaybe$1<Scalars$1['Bytes']>;
    pricingAsset_in?: InputMaybe$1<Array<Scalars$1['Bytes']>>;
    pricingAsset_lt?: InputMaybe$1<Scalars$1['Bytes']>;
    pricingAsset_lte?: InputMaybe$1<Scalars$1['Bytes']>;
    pricingAsset_not?: InputMaybe$1<Scalars$1['Bytes']>;
    pricingAsset_not_contains?: InputMaybe$1<Scalars$1['Bytes']>;
    pricingAsset_not_in?: InputMaybe$1<Array<Scalars$1['Bytes']>>;
};
declare enum LatestPrice_OrderBy {
    Asset = "asset",
    Block = "block",
    Id = "id",
    PoolId = "poolId",
    PoolIdAddress = "poolId__address",
    PoolIdAlpha = "poolId__alpha",
    PoolIdAmp = "poolId__amp",
    PoolIdBaseToken = "poolId__baseToken",
    PoolIdBeta = "poolId__beta",
    PoolIdC = "poolId__c",
    PoolIdCreateTime = "poolId__createTime",
    PoolIdDSq = "poolId__dSq",
    PoolIdDelta = "poolId__delta",
    PoolIdEpsilon = "poolId__epsilon",
    PoolIdExpiryTime = "poolId__expiryTime",
    PoolIdFactory = "poolId__factory",
    PoolIdHoldersCount = "poolId__holdersCount",
    PoolIdId = "poolId__id",
    PoolIdIsInRecoveryMode = "poolId__isInRecoveryMode",
    PoolIdIsPaused = "poolId__isPaused",
    PoolIdJoinExitEnabled = "poolId__joinExitEnabled",
    PoolIdLambda = "poolId__lambda",
    PoolIdLastJoinExitAmp = "poolId__lastJoinExitAmp",
    PoolIdLastPostJoinExitInvariant = "poolId__lastPostJoinExitInvariant",
    PoolIdLowerTarget = "poolId__lowerTarget",
    PoolIdMainIndex = "poolId__mainIndex",
    PoolIdManagementAumFee = "poolId__managementAumFee",
    PoolIdManagementFee = "poolId__managementFee",
    PoolIdMustAllowlistLPs = "poolId__mustAllowlistLPs",
    PoolIdName = "poolId__name",
    PoolIdOracleEnabled = "poolId__oracleEnabled",
    PoolIdOwner = "poolId__owner",
    PoolIdPoolType = "poolId__poolType",
    PoolIdPoolTypeVersion = "poolId__poolTypeVersion",
    PoolIdPrincipalToken = "poolId__principalToken",
    PoolIdProtocolAumFeeCache = "poolId__protocolAumFeeCache",
    PoolIdProtocolId = "poolId__protocolId",
    PoolIdProtocolSwapFeeCache = "poolId__protocolSwapFeeCache",
    PoolIdProtocolYieldFeeCache = "poolId__protocolYieldFeeCache",
    PoolIdRoot3Alpha = "poolId__root3Alpha",
    PoolIdS = "poolId__s",
    PoolIdSqrtAlpha = "poolId__sqrtAlpha",
    PoolIdSqrtBeta = "poolId__sqrtBeta",
    PoolIdStrategyType = "poolId__strategyType",
    PoolIdSwapEnabled = "poolId__swapEnabled",
    PoolIdSwapEnabledCurationSignal = "poolId__swapEnabledCurationSignal",
    PoolIdSwapEnabledInternal = "poolId__swapEnabledInternal",
    PoolIdSwapFee = "poolId__swapFee",
    PoolIdSwapsCount = "poolId__swapsCount",
    PoolIdSymbol = "poolId__symbol",
    PoolIdTauAlphaX = "poolId__tauAlphaX",
    PoolIdTauAlphaY = "poolId__tauAlphaY",
    PoolIdTauBetaX = "poolId__tauBetaX",
    PoolIdTauBetaY = "poolId__tauBetaY",
    PoolIdTotalAumFeeCollectedInBpt = "poolId__totalAumFeeCollectedInBPT",
    PoolIdTotalLiquidity = "poolId__totalLiquidity",
    PoolIdTotalLiquiditySansBpt = "poolId__totalLiquiditySansBPT",
    PoolIdTotalProtocolFee = "poolId__totalProtocolFee",
    PoolIdTotalProtocolFeePaidInBpt = "poolId__totalProtocolFeePaidInBPT",
    PoolIdTotalShares = "poolId__totalShares",
    PoolIdTotalSwapFee = "poolId__totalSwapFee",
    PoolIdTotalSwapVolume = "poolId__totalSwapVolume",
    PoolIdTotalWeight = "poolId__totalWeight",
    PoolIdTx = "poolId__tx",
    PoolIdU = "poolId__u",
    PoolIdUnitSeconds = "poolId__unitSeconds",
    PoolIdUpperTarget = "poolId__upperTarget",
    PoolIdV = "poolId__v",
    PoolIdW = "poolId__w",
    PoolIdWrappedIndex = "poolId__wrappedIndex",
    PoolIdZ = "poolId__z",
    Price = "price",
    PricingAsset = "pricingAsset"
}
type ManagementOperation_Filter = {
    /** Filter for the block changed event. */
    _change_block?: InputMaybe$1<BlockChangedFilter$1>;
    and?: InputMaybe$1<Array<InputMaybe$1<ManagementOperation_Filter>>>;
    cashDelta?: InputMaybe$1<Scalars$1['BigDecimal']>;
    cashDelta_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    cashDelta_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    cashDelta_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    cashDelta_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    cashDelta_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    cashDelta_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    cashDelta_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    id?: InputMaybe$1<Scalars$1['ID']>;
    id_gt?: InputMaybe$1<Scalars$1['ID']>;
    id_gte?: InputMaybe$1<Scalars$1['ID']>;
    id_in?: InputMaybe$1<Array<Scalars$1['ID']>>;
    id_lt?: InputMaybe$1<Scalars$1['ID']>;
    id_lte?: InputMaybe$1<Scalars$1['ID']>;
    id_not?: InputMaybe$1<Scalars$1['ID']>;
    id_not_in?: InputMaybe$1<Array<Scalars$1['ID']>>;
    managedDelta?: InputMaybe$1<Scalars$1['BigDecimal']>;
    managedDelta_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    managedDelta_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    managedDelta_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    managedDelta_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    managedDelta_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    managedDelta_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    managedDelta_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    or?: InputMaybe$1<Array<InputMaybe$1<ManagementOperation_Filter>>>;
    poolTokenId?: InputMaybe$1<Scalars$1['String']>;
    poolTokenId_?: InputMaybe$1<PoolToken_Filter>;
    poolTokenId_contains?: InputMaybe$1<Scalars$1['String']>;
    poolTokenId_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolTokenId_ends_with?: InputMaybe$1<Scalars$1['String']>;
    poolTokenId_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolTokenId_gt?: InputMaybe$1<Scalars$1['String']>;
    poolTokenId_gte?: InputMaybe$1<Scalars$1['String']>;
    poolTokenId_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    poolTokenId_lt?: InputMaybe$1<Scalars$1['String']>;
    poolTokenId_lte?: InputMaybe$1<Scalars$1['String']>;
    poolTokenId_not?: InputMaybe$1<Scalars$1['String']>;
    poolTokenId_not_contains?: InputMaybe$1<Scalars$1['String']>;
    poolTokenId_not_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolTokenId_not_ends_with?: InputMaybe$1<Scalars$1['String']>;
    poolTokenId_not_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolTokenId_not_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    poolTokenId_not_starts_with?: InputMaybe$1<Scalars$1['String']>;
    poolTokenId_not_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolTokenId_starts_with?: InputMaybe$1<Scalars$1['String']>;
    poolTokenId_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    timestamp?: InputMaybe$1<Scalars$1['Int']>;
    timestamp_gt?: InputMaybe$1<Scalars$1['Int']>;
    timestamp_gte?: InputMaybe$1<Scalars$1['Int']>;
    timestamp_in?: InputMaybe$1<Array<Scalars$1['Int']>>;
    timestamp_lt?: InputMaybe$1<Scalars$1['Int']>;
    timestamp_lte?: InputMaybe$1<Scalars$1['Int']>;
    timestamp_not?: InputMaybe$1<Scalars$1['Int']>;
    timestamp_not_in?: InputMaybe$1<Array<Scalars$1['Int']>>;
    type?: InputMaybe$1<OperationType>;
    type_in?: InputMaybe$1<Array<OperationType>>;
    type_not?: InputMaybe$1<OperationType>;
    type_not_in?: InputMaybe$1<Array<OperationType>>;
};
declare enum OperationType {
    Deposit = "Deposit",
    Update = "Update",
    Withdraw = "Withdraw"
}
/** Defines the order direction, either ascending or descending */
declare enum OrderDirection$1 {
    Asc = "asc",
    Desc = "desc"
}
type PoolHistoricalLiquidity_Filter = {
    /** Filter for the block changed event. */
    _change_block?: InputMaybe$1<BlockChangedFilter$1>;
    and?: InputMaybe$1<Array<InputMaybe$1<PoolHistoricalLiquidity_Filter>>>;
    block?: InputMaybe$1<Scalars$1['BigInt']>;
    block_gt?: InputMaybe$1<Scalars$1['BigInt']>;
    block_gte?: InputMaybe$1<Scalars$1['BigInt']>;
    block_in?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
    block_lt?: InputMaybe$1<Scalars$1['BigInt']>;
    block_lte?: InputMaybe$1<Scalars$1['BigInt']>;
    block_not?: InputMaybe$1<Scalars$1['BigInt']>;
    block_not_in?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
    id?: InputMaybe$1<Scalars$1['ID']>;
    id_gt?: InputMaybe$1<Scalars$1['ID']>;
    id_gte?: InputMaybe$1<Scalars$1['ID']>;
    id_in?: InputMaybe$1<Array<Scalars$1['ID']>>;
    id_lt?: InputMaybe$1<Scalars$1['ID']>;
    id_lte?: InputMaybe$1<Scalars$1['ID']>;
    id_not?: InputMaybe$1<Scalars$1['ID']>;
    id_not_in?: InputMaybe$1<Array<Scalars$1['ID']>>;
    or?: InputMaybe$1<Array<InputMaybe$1<PoolHistoricalLiquidity_Filter>>>;
    poolId?: InputMaybe$1<Scalars$1['String']>;
    poolId_?: InputMaybe$1<Pool_Filter$1>;
    poolId_contains?: InputMaybe$1<Scalars$1['String']>;
    poolId_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolId_ends_with?: InputMaybe$1<Scalars$1['String']>;
    poolId_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolId_gt?: InputMaybe$1<Scalars$1['String']>;
    poolId_gte?: InputMaybe$1<Scalars$1['String']>;
    poolId_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    poolId_lt?: InputMaybe$1<Scalars$1['String']>;
    poolId_lte?: InputMaybe$1<Scalars$1['String']>;
    poolId_not?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_contains?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_ends_with?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    poolId_not_starts_with?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolId_starts_with?: InputMaybe$1<Scalars$1['String']>;
    poolId_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolLiquidity?: InputMaybe$1<Scalars$1['BigDecimal']>;
    poolLiquidity_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    poolLiquidity_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    poolLiquidity_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    poolLiquidity_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    poolLiquidity_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    poolLiquidity_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    poolLiquidity_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    poolShareValue?: InputMaybe$1<Scalars$1['BigDecimal']>;
    poolShareValue_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    poolShareValue_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    poolShareValue_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    poolShareValue_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    poolShareValue_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    poolShareValue_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    poolShareValue_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    poolTotalShares?: InputMaybe$1<Scalars$1['BigDecimal']>;
    poolTotalShares_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    poolTotalShares_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    poolTotalShares_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    poolTotalShares_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    poolTotalShares_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    poolTotalShares_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    poolTotalShares_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    pricingAsset?: InputMaybe$1<Scalars$1['Bytes']>;
    pricingAsset_contains?: InputMaybe$1<Scalars$1['Bytes']>;
    pricingAsset_gt?: InputMaybe$1<Scalars$1['Bytes']>;
    pricingAsset_gte?: InputMaybe$1<Scalars$1['Bytes']>;
    pricingAsset_in?: InputMaybe$1<Array<Scalars$1['Bytes']>>;
    pricingAsset_lt?: InputMaybe$1<Scalars$1['Bytes']>;
    pricingAsset_lte?: InputMaybe$1<Scalars$1['Bytes']>;
    pricingAsset_not?: InputMaybe$1<Scalars$1['Bytes']>;
    pricingAsset_not_contains?: InputMaybe$1<Scalars$1['Bytes']>;
    pricingAsset_not_in?: InputMaybe$1<Array<Scalars$1['Bytes']>>;
};
declare enum PoolHistoricalLiquidity_OrderBy {
    Block = "block",
    Id = "id",
    PoolId = "poolId",
    PoolIdAddress = "poolId__address",
    PoolIdAlpha = "poolId__alpha",
    PoolIdAmp = "poolId__amp",
    PoolIdBaseToken = "poolId__baseToken",
    PoolIdBeta = "poolId__beta",
    PoolIdC = "poolId__c",
    PoolIdCreateTime = "poolId__createTime",
    PoolIdDSq = "poolId__dSq",
    PoolIdDelta = "poolId__delta",
    PoolIdEpsilon = "poolId__epsilon",
    PoolIdExpiryTime = "poolId__expiryTime",
    PoolIdFactory = "poolId__factory",
    PoolIdHoldersCount = "poolId__holdersCount",
    PoolIdId = "poolId__id",
    PoolIdIsInRecoveryMode = "poolId__isInRecoveryMode",
    PoolIdIsPaused = "poolId__isPaused",
    PoolIdJoinExitEnabled = "poolId__joinExitEnabled",
    PoolIdLambda = "poolId__lambda",
    PoolIdLastJoinExitAmp = "poolId__lastJoinExitAmp",
    PoolIdLastPostJoinExitInvariant = "poolId__lastPostJoinExitInvariant",
    PoolIdLowerTarget = "poolId__lowerTarget",
    PoolIdMainIndex = "poolId__mainIndex",
    PoolIdManagementAumFee = "poolId__managementAumFee",
    PoolIdManagementFee = "poolId__managementFee",
    PoolIdMustAllowlistLPs = "poolId__mustAllowlistLPs",
    PoolIdName = "poolId__name",
    PoolIdOracleEnabled = "poolId__oracleEnabled",
    PoolIdOwner = "poolId__owner",
    PoolIdPoolType = "poolId__poolType",
    PoolIdPoolTypeVersion = "poolId__poolTypeVersion",
    PoolIdPrincipalToken = "poolId__principalToken",
    PoolIdProtocolAumFeeCache = "poolId__protocolAumFeeCache",
    PoolIdProtocolId = "poolId__protocolId",
    PoolIdProtocolSwapFeeCache = "poolId__protocolSwapFeeCache",
    PoolIdProtocolYieldFeeCache = "poolId__protocolYieldFeeCache",
    PoolIdRoot3Alpha = "poolId__root3Alpha",
    PoolIdS = "poolId__s",
    PoolIdSqrtAlpha = "poolId__sqrtAlpha",
    PoolIdSqrtBeta = "poolId__sqrtBeta",
    PoolIdStrategyType = "poolId__strategyType",
    PoolIdSwapEnabled = "poolId__swapEnabled",
    PoolIdSwapEnabledCurationSignal = "poolId__swapEnabledCurationSignal",
    PoolIdSwapEnabledInternal = "poolId__swapEnabledInternal",
    PoolIdSwapFee = "poolId__swapFee",
    PoolIdSwapsCount = "poolId__swapsCount",
    PoolIdSymbol = "poolId__symbol",
    PoolIdTauAlphaX = "poolId__tauAlphaX",
    PoolIdTauAlphaY = "poolId__tauAlphaY",
    PoolIdTauBetaX = "poolId__tauBetaX",
    PoolIdTauBetaY = "poolId__tauBetaY",
    PoolIdTotalAumFeeCollectedInBpt = "poolId__totalAumFeeCollectedInBPT",
    PoolIdTotalLiquidity = "poolId__totalLiquidity",
    PoolIdTotalLiquiditySansBpt = "poolId__totalLiquiditySansBPT",
    PoolIdTotalProtocolFee = "poolId__totalProtocolFee",
    PoolIdTotalProtocolFeePaidInBpt = "poolId__totalProtocolFeePaidInBPT",
    PoolIdTotalShares = "poolId__totalShares",
    PoolIdTotalSwapFee = "poolId__totalSwapFee",
    PoolIdTotalSwapVolume = "poolId__totalSwapVolume",
    PoolIdTotalWeight = "poolId__totalWeight",
    PoolIdTx = "poolId__tx",
    PoolIdU = "poolId__u",
    PoolIdUnitSeconds = "poolId__unitSeconds",
    PoolIdUpperTarget = "poolId__upperTarget",
    PoolIdV = "poolId__v",
    PoolIdW = "poolId__w",
    PoolIdWrappedIndex = "poolId__wrappedIndex",
    PoolIdZ = "poolId__z",
    PoolLiquidity = "poolLiquidity",
    PoolShareValue = "poolShareValue",
    PoolTotalShares = "poolTotalShares",
    PricingAsset = "pricingAsset"
}
type PoolShare_Filter = {
    /** Filter for the block changed event. */
    _change_block?: InputMaybe$1<BlockChangedFilter$1>;
    and?: InputMaybe$1<Array<InputMaybe$1<PoolShare_Filter>>>;
    balance?: InputMaybe$1<Scalars$1['BigDecimal']>;
    balance_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    balance_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    balance_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    balance_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    balance_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    balance_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    balance_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    id?: InputMaybe$1<Scalars$1['ID']>;
    id_gt?: InputMaybe$1<Scalars$1['ID']>;
    id_gte?: InputMaybe$1<Scalars$1['ID']>;
    id_in?: InputMaybe$1<Array<Scalars$1['ID']>>;
    id_lt?: InputMaybe$1<Scalars$1['ID']>;
    id_lte?: InputMaybe$1<Scalars$1['ID']>;
    id_not?: InputMaybe$1<Scalars$1['ID']>;
    id_not_in?: InputMaybe$1<Array<Scalars$1['ID']>>;
    or?: InputMaybe$1<Array<InputMaybe$1<PoolShare_Filter>>>;
    poolId?: InputMaybe$1<Scalars$1['String']>;
    poolId_?: InputMaybe$1<Pool_Filter$1>;
    poolId_contains?: InputMaybe$1<Scalars$1['String']>;
    poolId_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolId_ends_with?: InputMaybe$1<Scalars$1['String']>;
    poolId_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolId_gt?: InputMaybe$1<Scalars$1['String']>;
    poolId_gte?: InputMaybe$1<Scalars$1['String']>;
    poolId_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    poolId_lt?: InputMaybe$1<Scalars$1['String']>;
    poolId_lte?: InputMaybe$1<Scalars$1['String']>;
    poolId_not?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_contains?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_ends_with?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    poolId_not_starts_with?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolId_starts_with?: InputMaybe$1<Scalars$1['String']>;
    poolId_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    userAddress?: InputMaybe$1<Scalars$1['String']>;
    userAddress_?: InputMaybe$1<User_Filter$1>;
    userAddress_contains?: InputMaybe$1<Scalars$1['String']>;
    userAddress_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    userAddress_ends_with?: InputMaybe$1<Scalars$1['String']>;
    userAddress_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    userAddress_gt?: InputMaybe$1<Scalars$1['String']>;
    userAddress_gte?: InputMaybe$1<Scalars$1['String']>;
    userAddress_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    userAddress_lt?: InputMaybe$1<Scalars$1['String']>;
    userAddress_lte?: InputMaybe$1<Scalars$1['String']>;
    userAddress_not?: InputMaybe$1<Scalars$1['String']>;
    userAddress_not_contains?: InputMaybe$1<Scalars$1['String']>;
    userAddress_not_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    userAddress_not_ends_with?: InputMaybe$1<Scalars$1['String']>;
    userAddress_not_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    userAddress_not_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    userAddress_not_starts_with?: InputMaybe$1<Scalars$1['String']>;
    userAddress_not_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    userAddress_starts_with?: InputMaybe$1<Scalars$1['String']>;
    userAddress_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
};
declare enum PoolShare_OrderBy {
    Balance = "balance",
    Id = "id",
    PoolId = "poolId",
    PoolIdAddress = "poolId__address",
    PoolIdAlpha = "poolId__alpha",
    PoolIdAmp = "poolId__amp",
    PoolIdBaseToken = "poolId__baseToken",
    PoolIdBeta = "poolId__beta",
    PoolIdC = "poolId__c",
    PoolIdCreateTime = "poolId__createTime",
    PoolIdDSq = "poolId__dSq",
    PoolIdDelta = "poolId__delta",
    PoolIdEpsilon = "poolId__epsilon",
    PoolIdExpiryTime = "poolId__expiryTime",
    PoolIdFactory = "poolId__factory",
    PoolIdHoldersCount = "poolId__holdersCount",
    PoolIdId = "poolId__id",
    PoolIdIsInRecoveryMode = "poolId__isInRecoveryMode",
    PoolIdIsPaused = "poolId__isPaused",
    PoolIdJoinExitEnabled = "poolId__joinExitEnabled",
    PoolIdLambda = "poolId__lambda",
    PoolIdLastJoinExitAmp = "poolId__lastJoinExitAmp",
    PoolIdLastPostJoinExitInvariant = "poolId__lastPostJoinExitInvariant",
    PoolIdLowerTarget = "poolId__lowerTarget",
    PoolIdMainIndex = "poolId__mainIndex",
    PoolIdManagementAumFee = "poolId__managementAumFee",
    PoolIdManagementFee = "poolId__managementFee",
    PoolIdMustAllowlistLPs = "poolId__mustAllowlistLPs",
    PoolIdName = "poolId__name",
    PoolIdOracleEnabled = "poolId__oracleEnabled",
    PoolIdOwner = "poolId__owner",
    PoolIdPoolType = "poolId__poolType",
    PoolIdPoolTypeVersion = "poolId__poolTypeVersion",
    PoolIdPrincipalToken = "poolId__principalToken",
    PoolIdProtocolAumFeeCache = "poolId__protocolAumFeeCache",
    PoolIdProtocolId = "poolId__protocolId",
    PoolIdProtocolSwapFeeCache = "poolId__protocolSwapFeeCache",
    PoolIdProtocolYieldFeeCache = "poolId__protocolYieldFeeCache",
    PoolIdRoot3Alpha = "poolId__root3Alpha",
    PoolIdS = "poolId__s",
    PoolIdSqrtAlpha = "poolId__sqrtAlpha",
    PoolIdSqrtBeta = "poolId__sqrtBeta",
    PoolIdStrategyType = "poolId__strategyType",
    PoolIdSwapEnabled = "poolId__swapEnabled",
    PoolIdSwapEnabledCurationSignal = "poolId__swapEnabledCurationSignal",
    PoolIdSwapEnabledInternal = "poolId__swapEnabledInternal",
    PoolIdSwapFee = "poolId__swapFee",
    PoolIdSwapsCount = "poolId__swapsCount",
    PoolIdSymbol = "poolId__symbol",
    PoolIdTauAlphaX = "poolId__tauAlphaX",
    PoolIdTauAlphaY = "poolId__tauAlphaY",
    PoolIdTauBetaX = "poolId__tauBetaX",
    PoolIdTauBetaY = "poolId__tauBetaY",
    PoolIdTotalAumFeeCollectedInBpt = "poolId__totalAumFeeCollectedInBPT",
    PoolIdTotalLiquidity = "poolId__totalLiquidity",
    PoolIdTotalLiquiditySansBpt = "poolId__totalLiquiditySansBPT",
    PoolIdTotalProtocolFee = "poolId__totalProtocolFee",
    PoolIdTotalProtocolFeePaidInBpt = "poolId__totalProtocolFeePaidInBPT",
    PoolIdTotalShares = "poolId__totalShares",
    PoolIdTotalSwapFee = "poolId__totalSwapFee",
    PoolIdTotalSwapVolume = "poolId__totalSwapVolume",
    PoolIdTotalWeight = "poolId__totalWeight",
    PoolIdTx = "poolId__tx",
    PoolIdU = "poolId__u",
    PoolIdUnitSeconds = "poolId__unitSeconds",
    PoolIdUpperTarget = "poolId__upperTarget",
    PoolIdV = "poolId__v",
    PoolIdW = "poolId__w",
    PoolIdWrappedIndex = "poolId__wrappedIndex",
    PoolIdZ = "poolId__z",
    UserAddress = "userAddress",
    UserAddressId = "userAddress__id"
}
type PoolSnapshot_Filter = {
    /** Filter for the block changed event. */
    _change_block?: InputMaybe$1<BlockChangedFilter$1>;
    amounts?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    amounts_contains?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    amounts_contains_nocase?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    amounts_not?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    amounts_not_contains?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    amounts_not_contains_nocase?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    and?: InputMaybe$1<Array<InputMaybe$1<PoolSnapshot_Filter>>>;
    holdersCount?: InputMaybe$1<Scalars$1['BigInt']>;
    holdersCount_gt?: InputMaybe$1<Scalars$1['BigInt']>;
    holdersCount_gte?: InputMaybe$1<Scalars$1['BigInt']>;
    holdersCount_in?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
    holdersCount_lt?: InputMaybe$1<Scalars$1['BigInt']>;
    holdersCount_lte?: InputMaybe$1<Scalars$1['BigInt']>;
    holdersCount_not?: InputMaybe$1<Scalars$1['BigInt']>;
    holdersCount_not_in?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
    id?: InputMaybe$1<Scalars$1['ID']>;
    id_gt?: InputMaybe$1<Scalars$1['ID']>;
    id_gte?: InputMaybe$1<Scalars$1['ID']>;
    id_in?: InputMaybe$1<Array<Scalars$1['ID']>>;
    id_lt?: InputMaybe$1<Scalars$1['ID']>;
    id_lte?: InputMaybe$1<Scalars$1['ID']>;
    id_not?: InputMaybe$1<Scalars$1['ID']>;
    id_not_in?: InputMaybe$1<Array<Scalars$1['ID']>>;
    liquidity?: InputMaybe$1<Scalars$1['BigDecimal']>;
    liquidity_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    liquidity_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    liquidity_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    liquidity_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    liquidity_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    liquidity_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    liquidity_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    or?: InputMaybe$1<Array<InputMaybe$1<PoolSnapshot_Filter>>>;
    pool?: InputMaybe$1<Scalars$1['String']>;
    pool_?: InputMaybe$1<Pool_Filter$1>;
    pool_contains?: InputMaybe$1<Scalars$1['String']>;
    pool_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    pool_ends_with?: InputMaybe$1<Scalars$1['String']>;
    pool_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    pool_gt?: InputMaybe$1<Scalars$1['String']>;
    pool_gte?: InputMaybe$1<Scalars$1['String']>;
    pool_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    pool_lt?: InputMaybe$1<Scalars$1['String']>;
    pool_lte?: InputMaybe$1<Scalars$1['String']>;
    pool_not?: InputMaybe$1<Scalars$1['String']>;
    pool_not_contains?: InputMaybe$1<Scalars$1['String']>;
    pool_not_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    pool_not_ends_with?: InputMaybe$1<Scalars$1['String']>;
    pool_not_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    pool_not_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    pool_not_starts_with?: InputMaybe$1<Scalars$1['String']>;
    pool_not_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    pool_starts_with?: InputMaybe$1<Scalars$1['String']>;
    pool_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    protocolFee?: InputMaybe$1<Scalars$1['BigDecimal']>;
    protocolFee_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    protocolFee_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    protocolFee_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    protocolFee_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    protocolFee_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    protocolFee_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    protocolFee_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    swapFees?: InputMaybe$1<Scalars$1['BigDecimal']>;
    swapFees_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    swapFees_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    swapFees_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    swapFees_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    swapFees_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    swapFees_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    swapFees_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    swapVolume?: InputMaybe$1<Scalars$1['BigDecimal']>;
    swapVolume_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    swapVolume_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    swapVolume_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    swapVolume_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    swapVolume_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    swapVolume_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    swapVolume_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    swapsCount?: InputMaybe$1<Scalars$1['BigInt']>;
    swapsCount_gt?: InputMaybe$1<Scalars$1['BigInt']>;
    swapsCount_gte?: InputMaybe$1<Scalars$1['BigInt']>;
    swapsCount_in?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
    swapsCount_lt?: InputMaybe$1<Scalars$1['BigInt']>;
    swapsCount_lte?: InputMaybe$1<Scalars$1['BigInt']>;
    swapsCount_not?: InputMaybe$1<Scalars$1['BigInt']>;
    swapsCount_not_in?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
    timestamp?: InputMaybe$1<Scalars$1['Int']>;
    timestamp_gt?: InputMaybe$1<Scalars$1['Int']>;
    timestamp_gte?: InputMaybe$1<Scalars$1['Int']>;
    timestamp_in?: InputMaybe$1<Array<Scalars$1['Int']>>;
    timestamp_lt?: InputMaybe$1<Scalars$1['Int']>;
    timestamp_lte?: InputMaybe$1<Scalars$1['Int']>;
    timestamp_not?: InputMaybe$1<Scalars$1['Int']>;
    timestamp_not_in?: InputMaybe$1<Array<Scalars$1['Int']>>;
    totalShares?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalShares_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalShares_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalShares_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    totalShares_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalShares_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalShares_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalShares_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
};
declare enum PoolSnapshot_OrderBy {
    Amounts = "amounts",
    HoldersCount = "holdersCount",
    Id = "id",
    Liquidity = "liquidity",
    Pool = "pool",
    PoolAddress = "pool__address",
    PoolAlpha = "pool__alpha",
    PoolAmp = "pool__amp",
    PoolBaseToken = "pool__baseToken",
    PoolBeta = "pool__beta",
    PoolC = "pool__c",
    PoolCreateTime = "pool__createTime",
    PoolDSq = "pool__dSq",
    PoolDelta = "pool__delta",
    PoolEpsilon = "pool__epsilon",
    PoolExpiryTime = "pool__expiryTime",
    PoolFactory = "pool__factory",
    PoolHoldersCount = "pool__holdersCount",
    PoolId = "pool__id",
    PoolIsInRecoveryMode = "pool__isInRecoveryMode",
    PoolIsPaused = "pool__isPaused",
    PoolJoinExitEnabled = "pool__joinExitEnabled",
    PoolLambda = "pool__lambda",
    PoolLastJoinExitAmp = "pool__lastJoinExitAmp",
    PoolLastPostJoinExitInvariant = "pool__lastPostJoinExitInvariant",
    PoolLowerTarget = "pool__lowerTarget",
    PoolMainIndex = "pool__mainIndex",
    PoolManagementAumFee = "pool__managementAumFee",
    PoolManagementFee = "pool__managementFee",
    PoolMustAllowlistLPs = "pool__mustAllowlistLPs",
    PoolName = "pool__name",
    PoolOracleEnabled = "pool__oracleEnabled",
    PoolOwner = "pool__owner",
    PoolPoolType = "pool__poolType",
    PoolPoolTypeVersion = "pool__poolTypeVersion",
    PoolPrincipalToken = "pool__principalToken",
    PoolProtocolAumFeeCache = "pool__protocolAumFeeCache",
    PoolProtocolId = "pool__protocolId",
    PoolProtocolSwapFeeCache = "pool__protocolSwapFeeCache",
    PoolProtocolYieldFeeCache = "pool__protocolYieldFeeCache",
    PoolRoot3Alpha = "pool__root3Alpha",
    PoolS = "pool__s",
    PoolSqrtAlpha = "pool__sqrtAlpha",
    PoolSqrtBeta = "pool__sqrtBeta",
    PoolStrategyType = "pool__strategyType",
    PoolSwapEnabled = "pool__swapEnabled",
    PoolSwapEnabledCurationSignal = "pool__swapEnabledCurationSignal",
    PoolSwapEnabledInternal = "pool__swapEnabledInternal",
    PoolSwapFee = "pool__swapFee",
    PoolSwapsCount = "pool__swapsCount",
    PoolSymbol = "pool__symbol",
    PoolTauAlphaX = "pool__tauAlphaX",
    PoolTauAlphaY = "pool__tauAlphaY",
    PoolTauBetaX = "pool__tauBetaX",
    PoolTauBetaY = "pool__tauBetaY",
    PoolTotalAumFeeCollectedInBpt = "pool__totalAumFeeCollectedInBPT",
    PoolTotalLiquidity = "pool__totalLiquidity",
    PoolTotalLiquiditySansBpt = "pool__totalLiquiditySansBPT",
    PoolTotalProtocolFee = "pool__totalProtocolFee",
    PoolTotalProtocolFeePaidInBpt = "pool__totalProtocolFeePaidInBPT",
    PoolTotalShares = "pool__totalShares",
    PoolTotalSwapFee = "pool__totalSwapFee",
    PoolTotalSwapVolume = "pool__totalSwapVolume",
    PoolTotalWeight = "pool__totalWeight",
    PoolTx = "pool__tx",
    PoolU = "pool__u",
    PoolUnitSeconds = "pool__unitSeconds",
    PoolUpperTarget = "pool__upperTarget",
    PoolV = "pool__v",
    PoolW = "pool__w",
    PoolWrappedIndex = "pool__wrappedIndex",
    PoolZ = "pool__z",
    ProtocolFee = "protocolFee",
    SwapFees = "swapFees",
    SwapVolume = "swapVolume",
    SwapsCount = "swapsCount",
    Timestamp = "timestamp",
    TotalShares = "totalShares"
}
type PoolToken_Filter = {
    /** Filter for the block changed event. */
    _change_block?: InputMaybe$1<BlockChangedFilter$1>;
    address?: InputMaybe$1<Scalars$1['String']>;
    address_contains?: InputMaybe$1<Scalars$1['String']>;
    address_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    address_ends_with?: InputMaybe$1<Scalars$1['String']>;
    address_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    address_gt?: InputMaybe$1<Scalars$1['String']>;
    address_gte?: InputMaybe$1<Scalars$1['String']>;
    address_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    address_lt?: InputMaybe$1<Scalars$1['String']>;
    address_lte?: InputMaybe$1<Scalars$1['String']>;
    address_not?: InputMaybe$1<Scalars$1['String']>;
    address_not_contains?: InputMaybe$1<Scalars$1['String']>;
    address_not_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    address_not_ends_with?: InputMaybe$1<Scalars$1['String']>;
    address_not_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    address_not_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    address_not_starts_with?: InputMaybe$1<Scalars$1['String']>;
    address_not_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    address_starts_with?: InputMaybe$1<Scalars$1['String']>;
    address_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    and?: InputMaybe$1<Array<InputMaybe$1<PoolToken_Filter>>>;
    assetManager?: InputMaybe$1<Scalars$1['Bytes']>;
    assetManager_contains?: InputMaybe$1<Scalars$1['Bytes']>;
    assetManager_gt?: InputMaybe$1<Scalars$1['Bytes']>;
    assetManager_gte?: InputMaybe$1<Scalars$1['Bytes']>;
    assetManager_in?: InputMaybe$1<Array<Scalars$1['Bytes']>>;
    assetManager_lt?: InputMaybe$1<Scalars$1['Bytes']>;
    assetManager_lte?: InputMaybe$1<Scalars$1['Bytes']>;
    assetManager_not?: InputMaybe$1<Scalars$1['Bytes']>;
    assetManager_not_contains?: InputMaybe$1<Scalars$1['Bytes']>;
    assetManager_not_in?: InputMaybe$1<Array<Scalars$1['Bytes']>>;
    balance?: InputMaybe$1<Scalars$1['BigDecimal']>;
    balance_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    balance_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    balance_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    balance_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    balance_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    balance_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    balance_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    cashBalance?: InputMaybe$1<Scalars$1['BigDecimal']>;
    cashBalance_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    cashBalance_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    cashBalance_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    cashBalance_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    cashBalance_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    cashBalance_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    cashBalance_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    circuitBreaker?: InputMaybe$1<Scalars$1['String']>;
    circuitBreaker_?: InputMaybe$1<CircuitBreaker_Filter>;
    circuitBreaker_contains?: InputMaybe$1<Scalars$1['String']>;
    circuitBreaker_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    circuitBreaker_ends_with?: InputMaybe$1<Scalars$1['String']>;
    circuitBreaker_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    circuitBreaker_gt?: InputMaybe$1<Scalars$1['String']>;
    circuitBreaker_gte?: InputMaybe$1<Scalars$1['String']>;
    circuitBreaker_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    circuitBreaker_lt?: InputMaybe$1<Scalars$1['String']>;
    circuitBreaker_lte?: InputMaybe$1<Scalars$1['String']>;
    circuitBreaker_not?: InputMaybe$1<Scalars$1['String']>;
    circuitBreaker_not_contains?: InputMaybe$1<Scalars$1['String']>;
    circuitBreaker_not_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    circuitBreaker_not_ends_with?: InputMaybe$1<Scalars$1['String']>;
    circuitBreaker_not_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    circuitBreaker_not_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    circuitBreaker_not_starts_with?: InputMaybe$1<Scalars$1['String']>;
    circuitBreaker_not_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    circuitBreaker_starts_with?: InputMaybe$1<Scalars$1['String']>;
    circuitBreaker_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    decimals?: InputMaybe$1<Scalars$1['Int']>;
    decimals_gt?: InputMaybe$1<Scalars$1['Int']>;
    decimals_gte?: InputMaybe$1<Scalars$1['Int']>;
    decimals_in?: InputMaybe$1<Array<Scalars$1['Int']>>;
    decimals_lt?: InputMaybe$1<Scalars$1['Int']>;
    decimals_lte?: InputMaybe$1<Scalars$1['Int']>;
    decimals_not?: InputMaybe$1<Scalars$1['Int']>;
    decimals_not_in?: InputMaybe$1<Array<Scalars$1['Int']>>;
    id?: InputMaybe$1<Scalars$1['ID']>;
    id_gt?: InputMaybe$1<Scalars$1['ID']>;
    id_gte?: InputMaybe$1<Scalars$1['ID']>;
    id_in?: InputMaybe$1<Array<Scalars$1['ID']>>;
    id_lt?: InputMaybe$1<Scalars$1['ID']>;
    id_lte?: InputMaybe$1<Scalars$1['ID']>;
    id_not?: InputMaybe$1<Scalars$1['ID']>;
    id_not_in?: InputMaybe$1<Array<Scalars$1['ID']>>;
    index?: InputMaybe$1<Scalars$1['Int']>;
    index_gt?: InputMaybe$1<Scalars$1['Int']>;
    index_gte?: InputMaybe$1<Scalars$1['Int']>;
    index_in?: InputMaybe$1<Array<Scalars$1['Int']>>;
    index_lt?: InputMaybe$1<Scalars$1['Int']>;
    index_lte?: InputMaybe$1<Scalars$1['Int']>;
    index_not?: InputMaybe$1<Scalars$1['Int']>;
    index_not_in?: InputMaybe$1<Array<Scalars$1['Int']>>;
    isExemptFromYieldProtocolFee?: InputMaybe$1<Scalars$1['Boolean']>;
    isExemptFromYieldProtocolFee_in?: InputMaybe$1<Array<Scalars$1['Boolean']>>;
    isExemptFromYieldProtocolFee_not?: InputMaybe$1<Scalars$1['Boolean']>;
    isExemptFromYieldProtocolFee_not_in?: InputMaybe$1<Array<Scalars$1['Boolean']>>;
    managedBalance?: InputMaybe$1<Scalars$1['BigDecimal']>;
    managedBalance_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    managedBalance_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    managedBalance_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    managedBalance_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    managedBalance_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    managedBalance_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    managedBalance_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    managements_?: InputMaybe$1<ManagementOperation_Filter>;
    name?: InputMaybe$1<Scalars$1['String']>;
    name_contains?: InputMaybe$1<Scalars$1['String']>;
    name_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    name_ends_with?: InputMaybe$1<Scalars$1['String']>;
    name_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    name_gt?: InputMaybe$1<Scalars$1['String']>;
    name_gte?: InputMaybe$1<Scalars$1['String']>;
    name_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    name_lt?: InputMaybe$1<Scalars$1['String']>;
    name_lte?: InputMaybe$1<Scalars$1['String']>;
    name_not?: InputMaybe$1<Scalars$1['String']>;
    name_not_contains?: InputMaybe$1<Scalars$1['String']>;
    name_not_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    name_not_ends_with?: InputMaybe$1<Scalars$1['String']>;
    name_not_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    name_not_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    name_not_starts_with?: InputMaybe$1<Scalars$1['String']>;
    name_not_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    name_starts_with?: InputMaybe$1<Scalars$1['String']>;
    name_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    oldPriceRate?: InputMaybe$1<Scalars$1['BigDecimal']>;
    oldPriceRate_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    oldPriceRate_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    oldPriceRate_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    oldPriceRate_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    oldPriceRate_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    oldPriceRate_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    oldPriceRate_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    or?: InputMaybe$1<Array<InputMaybe$1<PoolToken_Filter>>>;
    paidProtocolFees?: InputMaybe$1<Scalars$1['BigDecimal']>;
    paidProtocolFees_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    paidProtocolFees_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    paidProtocolFees_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    paidProtocolFees_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    paidProtocolFees_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    paidProtocolFees_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    paidProtocolFees_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    poolId?: InputMaybe$1<Scalars$1['String']>;
    poolId_?: InputMaybe$1<Pool_Filter$1>;
    poolId_contains?: InputMaybe$1<Scalars$1['String']>;
    poolId_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolId_ends_with?: InputMaybe$1<Scalars$1['String']>;
    poolId_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolId_gt?: InputMaybe$1<Scalars$1['String']>;
    poolId_gte?: InputMaybe$1<Scalars$1['String']>;
    poolId_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    poolId_lt?: InputMaybe$1<Scalars$1['String']>;
    poolId_lte?: InputMaybe$1<Scalars$1['String']>;
    poolId_not?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_contains?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_ends_with?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    poolId_not_starts_with?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolId_starts_with?: InputMaybe$1<Scalars$1['String']>;
    poolId_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    priceRate?: InputMaybe$1<Scalars$1['BigDecimal']>;
    priceRate_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    priceRate_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    priceRate_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    priceRate_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    priceRate_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    priceRate_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    priceRate_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    symbol?: InputMaybe$1<Scalars$1['String']>;
    symbol_contains?: InputMaybe$1<Scalars$1['String']>;
    symbol_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    symbol_ends_with?: InputMaybe$1<Scalars$1['String']>;
    symbol_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    symbol_gt?: InputMaybe$1<Scalars$1['String']>;
    symbol_gte?: InputMaybe$1<Scalars$1['String']>;
    symbol_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    symbol_lt?: InputMaybe$1<Scalars$1['String']>;
    symbol_lte?: InputMaybe$1<Scalars$1['String']>;
    symbol_not?: InputMaybe$1<Scalars$1['String']>;
    symbol_not_contains?: InputMaybe$1<Scalars$1['String']>;
    symbol_not_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    symbol_not_ends_with?: InputMaybe$1<Scalars$1['String']>;
    symbol_not_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    symbol_not_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    symbol_not_starts_with?: InputMaybe$1<Scalars$1['String']>;
    symbol_not_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    symbol_starts_with?: InputMaybe$1<Scalars$1['String']>;
    symbol_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    token?: InputMaybe$1<Scalars$1['String']>;
    token_?: InputMaybe$1<Token_Filter>;
    token_contains?: InputMaybe$1<Scalars$1['String']>;
    token_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    token_ends_with?: InputMaybe$1<Scalars$1['String']>;
    token_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    token_gt?: InputMaybe$1<Scalars$1['String']>;
    token_gte?: InputMaybe$1<Scalars$1['String']>;
    token_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    token_lt?: InputMaybe$1<Scalars$1['String']>;
    token_lte?: InputMaybe$1<Scalars$1['String']>;
    token_not?: InputMaybe$1<Scalars$1['String']>;
    token_not_contains?: InputMaybe$1<Scalars$1['String']>;
    token_not_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    token_not_ends_with?: InputMaybe$1<Scalars$1['String']>;
    token_not_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    token_not_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    token_not_starts_with?: InputMaybe$1<Scalars$1['String']>;
    token_not_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    token_starts_with?: InputMaybe$1<Scalars$1['String']>;
    token_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    weight?: InputMaybe$1<Scalars$1['BigDecimal']>;
    weight_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    weight_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    weight_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    weight_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    weight_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    weight_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    weight_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
};
type Pool_Filter$1 = {
    /** Filter for the block changed event. */
    _change_block?: InputMaybe$1<BlockChangedFilter$1>;
    address?: InputMaybe$1<Scalars$1['Bytes']>;
    address_contains?: InputMaybe$1<Scalars$1['Bytes']>;
    address_gt?: InputMaybe$1<Scalars$1['Bytes']>;
    address_gte?: InputMaybe$1<Scalars$1['Bytes']>;
    address_in?: InputMaybe$1<Array<Scalars$1['Bytes']>>;
    address_lt?: InputMaybe$1<Scalars$1['Bytes']>;
    address_lte?: InputMaybe$1<Scalars$1['Bytes']>;
    address_not?: InputMaybe$1<Scalars$1['Bytes']>;
    address_not_contains?: InputMaybe$1<Scalars$1['Bytes']>;
    address_not_in?: InputMaybe$1<Array<Scalars$1['Bytes']>>;
    alpha?: InputMaybe$1<Scalars$1['BigDecimal']>;
    alpha_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    alpha_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    alpha_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    alpha_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    alpha_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    alpha_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    alpha_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    amp?: InputMaybe$1<Scalars$1['BigInt']>;
    ampUpdates_?: InputMaybe$1<AmpUpdate_Filter>;
    amp_gt?: InputMaybe$1<Scalars$1['BigInt']>;
    amp_gte?: InputMaybe$1<Scalars$1['BigInt']>;
    amp_in?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
    amp_lt?: InputMaybe$1<Scalars$1['BigInt']>;
    amp_lte?: InputMaybe$1<Scalars$1['BigInt']>;
    amp_not?: InputMaybe$1<Scalars$1['BigInt']>;
    amp_not_in?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
    and?: InputMaybe$1<Array<InputMaybe$1<Pool_Filter$1>>>;
    baseToken?: InputMaybe$1<Scalars$1['Bytes']>;
    baseToken_contains?: InputMaybe$1<Scalars$1['Bytes']>;
    baseToken_gt?: InputMaybe$1<Scalars$1['Bytes']>;
    baseToken_gte?: InputMaybe$1<Scalars$1['Bytes']>;
    baseToken_in?: InputMaybe$1<Array<Scalars$1['Bytes']>>;
    baseToken_lt?: InputMaybe$1<Scalars$1['Bytes']>;
    baseToken_lte?: InputMaybe$1<Scalars$1['Bytes']>;
    baseToken_not?: InputMaybe$1<Scalars$1['Bytes']>;
    baseToken_not_contains?: InputMaybe$1<Scalars$1['Bytes']>;
    baseToken_not_in?: InputMaybe$1<Array<Scalars$1['Bytes']>>;
    beta?: InputMaybe$1<Scalars$1['BigDecimal']>;
    beta_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    beta_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    beta_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    beta_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    beta_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    beta_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    beta_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    c?: InputMaybe$1<Scalars$1['BigDecimal']>;
    c_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    c_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    c_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    c_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    c_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    c_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    c_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    circuitBreakers_?: InputMaybe$1<CircuitBreaker_Filter>;
    createTime?: InputMaybe$1<Scalars$1['Int']>;
    createTime_gt?: InputMaybe$1<Scalars$1['Int']>;
    createTime_gte?: InputMaybe$1<Scalars$1['Int']>;
    createTime_in?: InputMaybe$1<Array<Scalars$1['Int']>>;
    createTime_lt?: InputMaybe$1<Scalars$1['Int']>;
    createTime_lte?: InputMaybe$1<Scalars$1['Int']>;
    createTime_not?: InputMaybe$1<Scalars$1['Int']>;
    createTime_not_in?: InputMaybe$1<Array<Scalars$1['Int']>>;
    dSq?: InputMaybe$1<Scalars$1['BigDecimal']>;
    dSq_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    dSq_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    dSq_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    dSq_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    dSq_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    dSq_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    dSq_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    delta?: InputMaybe$1<Scalars$1['BigDecimal']>;
    delta_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    delta_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    delta_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    delta_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    delta_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    delta_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    delta_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    epsilon?: InputMaybe$1<Scalars$1['BigDecimal']>;
    epsilon_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    epsilon_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    epsilon_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    epsilon_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    epsilon_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    epsilon_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    epsilon_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    expiryTime?: InputMaybe$1<Scalars$1['BigInt']>;
    expiryTime_gt?: InputMaybe$1<Scalars$1['BigInt']>;
    expiryTime_gte?: InputMaybe$1<Scalars$1['BigInt']>;
    expiryTime_in?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
    expiryTime_lt?: InputMaybe$1<Scalars$1['BigInt']>;
    expiryTime_lte?: InputMaybe$1<Scalars$1['BigInt']>;
    expiryTime_not?: InputMaybe$1<Scalars$1['BigInt']>;
    expiryTime_not_in?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
    factory?: InputMaybe$1<Scalars$1['Bytes']>;
    factory_contains?: InputMaybe$1<Scalars$1['Bytes']>;
    factory_gt?: InputMaybe$1<Scalars$1['Bytes']>;
    factory_gte?: InputMaybe$1<Scalars$1['Bytes']>;
    factory_in?: InputMaybe$1<Array<Scalars$1['Bytes']>>;
    factory_lt?: InputMaybe$1<Scalars$1['Bytes']>;
    factory_lte?: InputMaybe$1<Scalars$1['Bytes']>;
    factory_not?: InputMaybe$1<Scalars$1['Bytes']>;
    factory_not_contains?: InputMaybe$1<Scalars$1['Bytes']>;
    factory_not_in?: InputMaybe$1<Array<Scalars$1['Bytes']>>;
    historicalValues_?: InputMaybe$1<PoolHistoricalLiquidity_Filter>;
    holdersCount?: InputMaybe$1<Scalars$1['BigInt']>;
    holdersCount_gt?: InputMaybe$1<Scalars$1['BigInt']>;
    holdersCount_gte?: InputMaybe$1<Scalars$1['BigInt']>;
    holdersCount_in?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
    holdersCount_lt?: InputMaybe$1<Scalars$1['BigInt']>;
    holdersCount_lte?: InputMaybe$1<Scalars$1['BigInt']>;
    holdersCount_not?: InputMaybe$1<Scalars$1['BigInt']>;
    holdersCount_not_in?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
    id?: InputMaybe$1<Scalars$1['ID']>;
    id_gt?: InputMaybe$1<Scalars$1['ID']>;
    id_gte?: InputMaybe$1<Scalars$1['ID']>;
    id_in?: InputMaybe$1<Array<Scalars$1['ID']>>;
    id_lt?: InputMaybe$1<Scalars$1['ID']>;
    id_lte?: InputMaybe$1<Scalars$1['ID']>;
    id_not?: InputMaybe$1<Scalars$1['ID']>;
    id_not_in?: InputMaybe$1<Array<Scalars$1['ID']>>;
    isInRecoveryMode?: InputMaybe$1<Scalars$1['Boolean']>;
    isInRecoveryMode_in?: InputMaybe$1<Array<Scalars$1['Boolean']>>;
    isInRecoveryMode_not?: InputMaybe$1<Scalars$1['Boolean']>;
    isInRecoveryMode_not_in?: InputMaybe$1<Array<Scalars$1['Boolean']>>;
    isPaused?: InputMaybe$1<Scalars$1['Boolean']>;
    isPaused_in?: InputMaybe$1<Array<Scalars$1['Boolean']>>;
    isPaused_not?: InputMaybe$1<Scalars$1['Boolean']>;
    isPaused_not_in?: InputMaybe$1<Array<Scalars$1['Boolean']>>;
    joinExitEnabled?: InputMaybe$1<Scalars$1['Boolean']>;
    joinExitEnabled_in?: InputMaybe$1<Array<Scalars$1['Boolean']>>;
    joinExitEnabled_not?: InputMaybe$1<Scalars$1['Boolean']>;
    joinExitEnabled_not_in?: InputMaybe$1<Array<Scalars$1['Boolean']>>;
    lambda?: InputMaybe$1<Scalars$1['BigDecimal']>;
    lambda_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    lambda_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    lambda_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    lambda_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    lambda_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    lambda_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    lambda_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    lastJoinExitAmp?: InputMaybe$1<Scalars$1['BigInt']>;
    lastJoinExitAmp_gt?: InputMaybe$1<Scalars$1['BigInt']>;
    lastJoinExitAmp_gte?: InputMaybe$1<Scalars$1['BigInt']>;
    lastJoinExitAmp_in?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
    lastJoinExitAmp_lt?: InputMaybe$1<Scalars$1['BigInt']>;
    lastJoinExitAmp_lte?: InputMaybe$1<Scalars$1['BigInt']>;
    lastJoinExitAmp_not?: InputMaybe$1<Scalars$1['BigInt']>;
    lastJoinExitAmp_not_in?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
    lastPostJoinExitInvariant?: InputMaybe$1<Scalars$1['BigDecimal']>;
    lastPostJoinExitInvariant_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    lastPostJoinExitInvariant_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    lastPostJoinExitInvariant_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    lastPostJoinExitInvariant_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    lastPostJoinExitInvariant_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    lastPostJoinExitInvariant_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    lastPostJoinExitInvariant_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    latestAmpUpdate?: InputMaybe$1<Scalars$1['String']>;
    latestAmpUpdate_?: InputMaybe$1<AmpUpdate_Filter>;
    latestAmpUpdate_contains?: InputMaybe$1<Scalars$1['String']>;
    latestAmpUpdate_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    latestAmpUpdate_ends_with?: InputMaybe$1<Scalars$1['String']>;
    latestAmpUpdate_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    latestAmpUpdate_gt?: InputMaybe$1<Scalars$1['String']>;
    latestAmpUpdate_gte?: InputMaybe$1<Scalars$1['String']>;
    latestAmpUpdate_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    latestAmpUpdate_lt?: InputMaybe$1<Scalars$1['String']>;
    latestAmpUpdate_lte?: InputMaybe$1<Scalars$1['String']>;
    latestAmpUpdate_not?: InputMaybe$1<Scalars$1['String']>;
    latestAmpUpdate_not_contains?: InputMaybe$1<Scalars$1['String']>;
    latestAmpUpdate_not_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    latestAmpUpdate_not_ends_with?: InputMaybe$1<Scalars$1['String']>;
    latestAmpUpdate_not_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    latestAmpUpdate_not_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    latestAmpUpdate_not_starts_with?: InputMaybe$1<Scalars$1['String']>;
    latestAmpUpdate_not_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    latestAmpUpdate_starts_with?: InputMaybe$1<Scalars$1['String']>;
    latestAmpUpdate_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    lowerTarget?: InputMaybe$1<Scalars$1['BigDecimal']>;
    lowerTarget_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    lowerTarget_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    lowerTarget_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    lowerTarget_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    lowerTarget_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    lowerTarget_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    lowerTarget_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    mainIndex?: InputMaybe$1<Scalars$1['Int']>;
    mainIndex_gt?: InputMaybe$1<Scalars$1['Int']>;
    mainIndex_gte?: InputMaybe$1<Scalars$1['Int']>;
    mainIndex_in?: InputMaybe$1<Array<Scalars$1['Int']>>;
    mainIndex_lt?: InputMaybe$1<Scalars$1['Int']>;
    mainIndex_lte?: InputMaybe$1<Scalars$1['Int']>;
    mainIndex_not?: InputMaybe$1<Scalars$1['Int']>;
    mainIndex_not_in?: InputMaybe$1<Array<Scalars$1['Int']>>;
    managementAumFee?: InputMaybe$1<Scalars$1['BigDecimal']>;
    managementAumFee_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    managementAumFee_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    managementAumFee_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    managementAumFee_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    managementAumFee_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    managementAumFee_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    managementAumFee_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    managementFee?: InputMaybe$1<Scalars$1['BigDecimal']>;
    managementFee_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    managementFee_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    managementFee_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    managementFee_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    managementFee_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    managementFee_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    managementFee_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    mustAllowlistLPs?: InputMaybe$1<Scalars$1['Boolean']>;
    mustAllowlistLPs_in?: InputMaybe$1<Array<Scalars$1['Boolean']>>;
    mustAllowlistLPs_not?: InputMaybe$1<Scalars$1['Boolean']>;
    mustAllowlistLPs_not_in?: InputMaybe$1<Array<Scalars$1['Boolean']>>;
    name?: InputMaybe$1<Scalars$1['String']>;
    name_contains?: InputMaybe$1<Scalars$1['String']>;
    name_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    name_ends_with?: InputMaybe$1<Scalars$1['String']>;
    name_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    name_gt?: InputMaybe$1<Scalars$1['String']>;
    name_gte?: InputMaybe$1<Scalars$1['String']>;
    name_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    name_lt?: InputMaybe$1<Scalars$1['String']>;
    name_lte?: InputMaybe$1<Scalars$1['String']>;
    name_not?: InputMaybe$1<Scalars$1['String']>;
    name_not_contains?: InputMaybe$1<Scalars$1['String']>;
    name_not_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    name_not_ends_with?: InputMaybe$1<Scalars$1['String']>;
    name_not_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    name_not_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    name_not_starts_with?: InputMaybe$1<Scalars$1['String']>;
    name_not_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    name_starts_with?: InputMaybe$1<Scalars$1['String']>;
    name_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    or?: InputMaybe$1<Array<InputMaybe$1<Pool_Filter$1>>>;
    oracleEnabled?: InputMaybe$1<Scalars$1['Boolean']>;
    oracleEnabled_in?: InputMaybe$1<Array<Scalars$1['Boolean']>>;
    oracleEnabled_not?: InputMaybe$1<Scalars$1['Boolean']>;
    oracleEnabled_not_in?: InputMaybe$1<Array<Scalars$1['Boolean']>>;
    owner?: InputMaybe$1<Scalars$1['Bytes']>;
    owner_contains?: InputMaybe$1<Scalars$1['Bytes']>;
    owner_gt?: InputMaybe$1<Scalars$1['Bytes']>;
    owner_gte?: InputMaybe$1<Scalars$1['Bytes']>;
    owner_in?: InputMaybe$1<Array<Scalars$1['Bytes']>>;
    owner_lt?: InputMaybe$1<Scalars$1['Bytes']>;
    owner_lte?: InputMaybe$1<Scalars$1['Bytes']>;
    owner_not?: InputMaybe$1<Scalars$1['Bytes']>;
    owner_not_contains?: InputMaybe$1<Scalars$1['Bytes']>;
    owner_not_in?: InputMaybe$1<Array<Scalars$1['Bytes']>>;
    poolType?: InputMaybe$1<Scalars$1['String']>;
    poolTypeVersion?: InputMaybe$1<Scalars$1['Int']>;
    poolTypeVersion_gt?: InputMaybe$1<Scalars$1['Int']>;
    poolTypeVersion_gte?: InputMaybe$1<Scalars$1['Int']>;
    poolTypeVersion_in?: InputMaybe$1<Array<Scalars$1['Int']>>;
    poolTypeVersion_lt?: InputMaybe$1<Scalars$1['Int']>;
    poolTypeVersion_lte?: InputMaybe$1<Scalars$1['Int']>;
    poolTypeVersion_not?: InputMaybe$1<Scalars$1['Int']>;
    poolTypeVersion_not_in?: InputMaybe$1<Array<Scalars$1['Int']>>;
    poolType_contains?: InputMaybe$1<Scalars$1['String']>;
    poolType_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolType_ends_with?: InputMaybe$1<Scalars$1['String']>;
    poolType_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolType_gt?: InputMaybe$1<Scalars$1['String']>;
    poolType_gte?: InputMaybe$1<Scalars$1['String']>;
    poolType_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    poolType_lt?: InputMaybe$1<Scalars$1['String']>;
    poolType_lte?: InputMaybe$1<Scalars$1['String']>;
    poolType_not?: InputMaybe$1<Scalars$1['String']>;
    poolType_not_contains?: InputMaybe$1<Scalars$1['String']>;
    poolType_not_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolType_not_ends_with?: InputMaybe$1<Scalars$1['String']>;
    poolType_not_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolType_not_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    poolType_not_starts_with?: InputMaybe$1<Scalars$1['String']>;
    poolType_not_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolType_starts_with?: InputMaybe$1<Scalars$1['String']>;
    poolType_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    priceRateProviders_?: InputMaybe$1<PriceRateProvider_Filter>;
    principalToken?: InputMaybe$1<Scalars$1['Bytes']>;
    principalToken_contains?: InputMaybe$1<Scalars$1['Bytes']>;
    principalToken_gt?: InputMaybe$1<Scalars$1['Bytes']>;
    principalToken_gte?: InputMaybe$1<Scalars$1['Bytes']>;
    principalToken_in?: InputMaybe$1<Array<Scalars$1['Bytes']>>;
    principalToken_lt?: InputMaybe$1<Scalars$1['Bytes']>;
    principalToken_lte?: InputMaybe$1<Scalars$1['Bytes']>;
    principalToken_not?: InputMaybe$1<Scalars$1['Bytes']>;
    principalToken_not_contains?: InputMaybe$1<Scalars$1['Bytes']>;
    principalToken_not_in?: InputMaybe$1<Array<Scalars$1['Bytes']>>;
    protocolAumFeeCache?: InputMaybe$1<Scalars$1['BigDecimal']>;
    protocolAumFeeCache_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    protocolAumFeeCache_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    protocolAumFeeCache_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    protocolAumFeeCache_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    protocolAumFeeCache_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    protocolAumFeeCache_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    protocolAumFeeCache_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    protocolId?: InputMaybe$1<Scalars$1['Int']>;
    protocolIdData?: InputMaybe$1<Scalars$1['String']>;
    protocolIdData_?: InputMaybe$1<ProtocolIdData_Filter>;
    protocolIdData_contains?: InputMaybe$1<Scalars$1['String']>;
    protocolIdData_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    protocolIdData_ends_with?: InputMaybe$1<Scalars$1['String']>;
    protocolIdData_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    protocolIdData_gt?: InputMaybe$1<Scalars$1['String']>;
    protocolIdData_gte?: InputMaybe$1<Scalars$1['String']>;
    protocolIdData_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    protocolIdData_lt?: InputMaybe$1<Scalars$1['String']>;
    protocolIdData_lte?: InputMaybe$1<Scalars$1['String']>;
    protocolIdData_not?: InputMaybe$1<Scalars$1['String']>;
    protocolIdData_not_contains?: InputMaybe$1<Scalars$1['String']>;
    protocolIdData_not_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    protocolIdData_not_ends_with?: InputMaybe$1<Scalars$1['String']>;
    protocolIdData_not_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    protocolIdData_not_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    protocolIdData_not_starts_with?: InputMaybe$1<Scalars$1['String']>;
    protocolIdData_not_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    protocolIdData_starts_with?: InputMaybe$1<Scalars$1['String']>;
    protocolIdData_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    protocolId_gt?: InputMaybe$1<Scalars$1['Int']>;
    protocolId_gte?: InputMaybe$1<Scalars$1['Int']>;
    protocolId_in?: InputMaybe$1<Array<Scalars$1['Int']>>;
    protocolId_lt?: InputMaybe$1<Scalars$1['Int']>;
    protocolId_lte?: InputMaybe$1<Scalars$1['Int']>;
    protocolId_not?: InputMaybe$1<Scalars$1['Int']>;
    protocolId_not_in?: InputMaybe$1<Array<Scalars$1['Int']>>;
    protocolSwapFeeCache?: InputMaybe$1<Scalars$1['BigDecimal']>;
    protocolSwapFeeCache_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    protocolSwapFeeCache_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    protocolSwapFeeCache_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    protocolSwapFeeCache_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    protocolSwapFeeCache_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    protocolSwapFeeCache_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    protocolSwapFeeCache_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    protocolYieldFeeCache?: InputMaybe$1<Scalars$1['BigDecimal']>;
    protocolYieldFeeCache_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    protocolYieldFeeCache_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    protocolYieldFeeCache_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    protocolYieldFeeCache_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    protocolYieldFeeCache_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    protocolYieldFeeCache_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    protocolYieldFeeCache_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    root3Alpha?: InputMaybe$1<Scalars$1['BigDecimal']>;
    root3Alpha_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    root3Alpha_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    root3Alpha_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    root3Alpha_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    root3Alpha_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    root3Alpha_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    root3Alpha_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    s?: InputMaybe$1<Scalars$1['BigDecimal']>;
    s_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    s_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    s_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    s_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    s_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    s_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    s_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    shares_?: InputMaybe$1<PoolShare_Filter>;
    snapshots_?: InputMaybe$1<PoolSnapshot_Filter>;
    sqrtAlpha?: InputMaybe$1<Scalars$1['BigDecimal']>;
    sqrtAlpha_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    sqrtAlpha_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    sqrtAlpha_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    sqrtAlpha_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    sqrtAlpha_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    sqrtAlpha_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    sqrtAlpha_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    sqrtBeta?: InputMaybe$1<Scalars$1['BigDecimal']>;
    sqrtBeta_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    sqrtBeta_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    sqrtBeta_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    sqrtBeta_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    sqrtBeta_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    sqrtBeta_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    sqrtBeta_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    strategyType?: InputMaybe$1<Scalars$1['Int']>;
    strategyType_gt?: InputMaybe$1<Scalars$1['Int']>;
    strategyType_gte?: InputMaybe$1<Scalars$1['Int']>;
    strategyType_in?: InputMaybe$1<Array<Scalars$1['Int']>>;
    strategyType_lt?: InputMaybe$1<Scalars$1['Int']>;
    strategyType_lte?: InputMaybe$1<Scalars$1['Int']>;
    strategyType_not?: InputMaybe$1<Scalars$1['Int']>;
    strategyType_not_in?: InputMaybe$1<Array<Scalars$1['Int']>>;
    swapEnabled?: InputMaybe$1<Scalars$1['Boolean']>;
    swapEnabledCurationSignal?: InputMaybe$1<Scalars$1['Boolean']>;
    swapEnabledCurationSignal_in?: InputMaybe$1<Array<Scalars$1['Boolean']>>;
    swapEnabledCurationSignal_not?: InputMaybe$1<Scalars$1['Boolean']>;
    swapEnabledCurationSignal_not_in?: InputMaybe$1<Array<Scalars$1['Boolean']>>;
    swapEnabledInternal?: InputMaybe$1<Scalars$1['Boolean']>;
    swapEnabledInternal_in?: InputMaybe$1<Array<Scalars$1['Boolean']>>;
    swapEnabledInternal_not?: InputMaybe$1<Scalars$1['Boolean']>;
    swapEnabledInternal_not_in?: InputMaybe$1<Array<Scalars$1['Boolean']>>;
    swapEnabled_in?: InputMaybe$1<Array<Scalars$1['Boolean']>>;
    swapEnabled_not?: InputMaybe$1<Scalars$1['Boolean']>;
    swapEnabled_not_in?: InputMaybe$1<Array<Scalars$1['Boolean']>>;
    swapFee?: InputMaybe$1<Scalars$1['BigDecimal']>;
    swapFee_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    swapFee_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    swapFee_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    swapFee_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    swapFee_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    swapFee_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    swapFee_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    swapsCount?: InputMaybe$1<Scalars$1['BigInt']>;
    swapsCount_gt?: InputMaybe$1<Scalars$1['BigInt']>;
    swapsCount_gte?: InputMaybe$1<Scalars$1['BigInt']>;
    swapsCount_in?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
    swapsCount_lt?: InputMaybe$1<Scalars$1['BigInt']>;
    swapsCount_lte?: InputMaybe$1<Scalars$1['BigInt']>;
    swapsCount_not?: InputMaybe$1<Scalars$1['BigInt']>;
    swapsCount_not_in?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
    swaps_?: InputMaybe$1<Swap_Filter>;
    symbol?: InputMaybe$1<Scalars$1['String']>;
    symbol_contains?: InputMaybe$1<Scalars$1['String']>;
    symbol_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    symbol_ends_with?: InputMaybe$1<Scalars$1['String']>;
    symbol_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    symbol_gt?: InputMaybe$1<Scalars$1['String']>;
    symbol_gte?: InputMaybe$1<Scalars$1['String']>;
    symbol_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    symbol_lt?: InputMaybe$1<Scalars$1['String']>;
    symbol_lte?: InputMaybe$1<Scalars$1['String']>;
    symbol_not?: InputMaybe$1<Scalars$1['String']>;
    symbol_not_contains?: InputMaybe$1<Scalars$1['String']>;
    symbol_not_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    symbol_not_ends_with?: InputMaybe$1<Scalars$1['String']>;
    symbol_not_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    symbol_not_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    symbol_not_starts_with?: InputMaybe$1<Scalars$1['String']>;
    symbol_not_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    symbol_starts_with?: InputMaybe$1<Scalars$1['String']>;
    symbol_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    tauAlphaX?: InputMaybe$1<Scalars$1['BigDecimal']>;
    tauAlphaX_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    tauAlphaX_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    tauAlphaX_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    tauAlphaX_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    tauAlphaX_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    tauAlphaX_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    tauAlphaX_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    tauAlphaY?: InputMaybe$1<Scalars$1['BigDecimal']>;
    tauAlphaY_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    tauAlphaY_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    tauAlphaY_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    tauAlphaY_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    tauAlphaY_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    tauAlphaY_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    tauAlphaY_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    tauBetaX?: InputMaybe$1<Scalars$1['BigDecimal']>;
    tauBetaX_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    tauBetaX_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    tauBetaX_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    tauBetaX_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    tauBetaX_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    tauBetaX_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    tauBetaX_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    tauBetaY?: InputMaybe$1<Scalars$1['BigDecimal']>;
    tauBetaY_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    tauBetaY_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    tauBetaY_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    tauBetaY_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    tauBetaY_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    tauBetaY_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    tauBetaY_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    tokensList?: InputMaybe$1<Array<Scalars$1['Bytes']>>;
    tokensList_contains?: InputMaybe$1<Array<Scalars$1['Bytes']>>;
    tokensList_contains_nocase?: InputMaybe$1<Array<Scalars$1['Bytes']>>;
    tokensList_not?: InputMaybe$1<Array<Scalars$1['Bytes']>>;
    tokensList_not_contains?: InputMaybe$1<Array<Scalars$1['Bytes']>>;
    tokensList_not_contains_nocase?: InputMaybe$1<Array<Scalars$1['Bytes']>>;
    tokens_?: InputMaybe$1<PoolToken_Filter>;
    totalAumFeeCollectedInBPT?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalAumFeeCollectedInBPT_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalAumFeeCollectedInBPT_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalAumFeeCollectedInBPT_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    totalAumFeeCollectedInBPT_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalAumFeeCollectedInBPT_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalAumFeeCollectedInBPT_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalAumFeeCollectedInBPT_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    totalLiquidity?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalLiquiditySansBPT?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalLiquiditySansBPT_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalLiquiditySansBPT_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalLiquiditySansBPT_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    totalLiquiditySansBPT_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalLiquiditySansBPT_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalLiquiditySansBPT_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalLiquiditySansBPT_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    totalLiquidity_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalLiquidity_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalLiquidity_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    totalLiquidity_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalLiquidity_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalLiquidity_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalLiquidity_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    totalProtocolFee?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalProtocolFeePaidInBPT?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalProtocolFeePaidInBPT_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalProtocolFeePaidInBPT_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalProtocolFeePaidInBPT_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    totalProtocolFeePaidInBPT_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalProtocolFeePaidInBPT_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalProtocolFeePaidInBPT_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalProtocolFeePaidInBPT_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    totalProtocolFee_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalProtocolFee_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalProtocolFee_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    totalProtocolFee_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalProtocolFee_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalProtocolFee_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalProtocolFee_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    totalShares?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalShares_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalShares_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalShares_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    totalShares_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalShares_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalShares_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalShares_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    totalSwapFee?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalSwapFee_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalSwapFee_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalSwapFee_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    totalSwapFee_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalSwapFee_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalSwapFee_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalSwapFee_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    totalSwapVolume?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalSwapVolume_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalSwapVolume_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalSwapVolume_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    totalSwapVolume_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalSwapVolume_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalSwapVolume_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalSwapVolume_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    totalWeight?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalWeight_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalWeight_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalWeight_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    totalWeight_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalWeight_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalWeight_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalWeight_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    tx?: InputMaybe$1<Scalars$1['Bytes']>;
    tx_contains?: InputMaybe$1<Scalars$1['Bytes']>;
    tx_gt?: InputMaybe$1<Scalars$1['Bytes']>;
    tx_gte?: InputMaybe$1<Scalars$1['Bytes']>;
    tx_in?: InputMaybe$1<Array<Scalars$1['Bytes']>>;
    tx_lt?: InputMaybe$1<Scalars$1['Bytes']>;
    tx_lte?: InputMaybe$1<Scalars$1['Bytes']>;
    tx_not?: InputMaybe$1<Scalars$1['Bytes']>;
    tx_not_contains?: InputMaybe$1<Scalars$1['Bytes']>;
    tx_not_in?: InputMaybe$1<Array<Scalars$1['Bytes']>>;
    u?: InputMaybe$1<Scalars$1['BigDecimal']>;
    u_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    u_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    u_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    u_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    u_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    u_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    u_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    unitSeconds?: InputMaybe$1<Scalars$1['BigInt']>;
    unitSeconds_gt?: InputMaybe$1<Scalars$1['BigInt']>;
    unitSeconds_gte?: InputMaybe$1<Scalars$1['BigInt']>;
    unitSeconds_in?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
    unitSeconds_lt?: InputMaybe$1<Scalars$1['BigInt']>;
    unitSeconds_lte?: InputMaybe$1<Scalars$1['BigInt']>;
    unitSeconds_not?: InputMaybe$1<Scalars$1['BigInt']>;
    unitSeconds_not_in?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
    upperTarget?: InputMaybe$1<Scalars$1['BigDecimal']>;
    upperTarget_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    upperTarget_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    upperTarget_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    upperTarget_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    upperTarget_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    upperTarget_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    upperTarget_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    v?: InputMaybe$1<Scalars$1['BigDecimal']>;
    v_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    v_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    v_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    v_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    v_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    v_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    v_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    vaultID?: InputMaybe$1<Scalars$1['String']>;
    vaultID_?: InputMaybe$1<Balancer_Filter>;
    vaultID_contains?: InputMaybe$1<Scalars$1['String']>;
    vaultID_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    vaultID_ends_with?: InputMaybe$1<Scalars$1['String']>;
    vaultID_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    vaultID_gt?: InputMaybe$1<Scalars$1['String']>;
    vaultID_gte?: InputMaybe$1<Scalars$1['String']>;
    vaultID_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    vaultID_lt?: InputMaybe$1<Scalars$1['String']>;
    vaultID_lte?: InputMaybe$1<Scalars$1['String']>;
    vaultID_not?: InputMaybe$1<Scalars$1['String']>;
    vaultID_not_contains?: InputMaybe$1<Scalars$1['String']>;
    vaultID_not_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    vaultID_not_ends_with?: InputMaybe$1<Scalars$1['String']>;
    vaultID_not_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    vaultID_not_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    vaultID_not_starts_with?: InputMaybe$1<Scalars$1['String']>;
    vaultID_not_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    vaultID_starts_with?: InputMaybe$1<Scalars$1['String']>;
    vaultID_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    w?: InputMaybe$1<Scalars$1['BigDecimal']>;
    w_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    w_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    w_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    w_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    w_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    w_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    w_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    weightUpdates_?: InputMaybe$1<GradualWeightUpdate_Filter>;
    wrappedIndex?: InputMaybe$1<Scalars$1['Int']>;
    wrappedIndex_gt?: InputMaybe$1<Scalars$1['Int']>;
    wrappedIndex_gte?: InputMaybe$1<Scalars$1['Int']>;
    wrappedIndex_in?: InputMaybe$1<Array<Scalars$1['Int']>>;
    wrappedIndex_lt?: InputMaybe$1<Scalars$1['Int']>;
    wrappedIndex_lte?: InputMaybe$1<Scalars$1['Int']>;
    wrappedIndex_not?: InputMaybe$1<Scalars$1['Int']>;
    wrappedIndex_not_in?: InputMaybe$1<Array<Scalars$1['Int']>>;
    z?: InputMaybe$1<Scalars$1['BigDecimal']>;
    z_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    z_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    z_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    z_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    z_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    z_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    z_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
};
declare enum Pool_OrderBy$1 {
    Address = "address",
    Alpha = "alpha",
    Amp = "amp",
    AmpUpdates = "ampUpdates",
    BaseToken = "baseToken",
    Beta = "beta",
    C = "c",
    CircuitBreakers = "circuitBreakers",
    CreateTime = "createTime",
    DSq = "dSq",
    Delta = "delta",
    Epsilon = "epsilon",
    ExpiryTime = "expiryTime",
    Factory = "factory",
    HistoricalValues = "historicalValues",
    HoldersCount = "holdersCount",
    Id = "id",
    IsInRecoveryMode = "isInRecoveryMode",
    IsPaused = "isPaused",
    JoinExitEnabled = "joinExitEnabled",
    Lambda = "lambda",
    LastJoinExitAmp = "lastJoinExitAmp",
    LastPostJoinExitInvariant = "lastPostJoinExitInvariant",
    LatestAmpUpdate = "latestAmpUpdate",
    LatestAmpUpdateEndAmp = "latestAmpUpdate__endAmp",
    LatestAmpUpdateEndTimestamp = "latestAmpUpdate__endTimestamp",
    LatestAmpUpdateId = "latestAmpUpdate__id",
    LatestAmpUpdateScheduledTimestamp = "latestAmpUpdate__scheduledTimestamp",
    LatestAmpUpdateStartAmp = "latestAmpUpdate__startAmp",
    LatestAmpUpdateStartTimestamp = "latestAmpUpdate__startTimestamp",
    LowerTarget = "lowerTarget",
    MainIndex = "mainIndex",
    ManagementAumFee = "managementAumFee",
    ManagementFee = "managementFee",
    MustAllowlistLPs = "mustAllowlistLPs",
    Name = "name",
    OracleEnabled = "oracleEnabled",
    Owner = "owner",
    PoolType = "poolType",
    PoolTypeVersion = "poolTypeVersion",
    PriceRateProviders = "priceRateProviders",
    PrincipalToken = "principalToken",
    ProtocolAumFeeCache = "protocolAumFeeCache",
    ProtocolId = "protocolId",
    ProtocolIdData = "protocolIdData",
    ProtocolIdDataId = "protocolIdData__id",
    ProtocolIdDataName = "protocolIdData__name",
    ProtocolSwapFeeCache = "protocolSwapFeeCache",
    ProtocolYieldFeeCache = "protocolYieldFeeCache",
    Root3Alpha = "root3Alpha",
    S = "s",
    Shares = "shares",
    Snapshots = "snapshots",
    SqrtAlpha = "sqrtAlpha",
    SqrtBeta = "sqrtBeta",
    StrategyType = "strategyType",
    SwapEnabled = "swapEnabled",
    SwapEnabledCurationSignal = "swapEnabledCurationSignal",
    SwapEnabledInternal = "swapEnabledInternal",
    SwapFee = "swapFee",
    Swaps = "swaps",
    SwapsCount = "swapsCount",
    Symbol = "symbol",
    TauAlphaX = "tauAlphaX",
    TauAlphaY = "tauAlphaY",
    TauBetaX = "tauBetaX",
    TauBetaY = "tauBetaY",
    Tokens = "tokens",
    TokensList = "tokensList",
    TotalAumFeeCollectedInBpt = "totalAumFeeCollectedInBPT",
    TotalLiquidity = "totalLiquidity",
    TotalLiquiditySansBpt = "totalLiquiditySansBPT",
    TotalProtocolFee = "totalProtocolFee",
    TotalProtocolFeePaidInBpt = "totalProtocolFeePaidInBPT",
    TotalShares = "totalShares",
    TotalSwapFee = "totalSwapFee",
    TotalSwapVolume = "totalSwapVolume",
    TotalWeight = "totalWeight",
    Tx = "tx",
    U = "u",
    UnitSeconds = "unitSeconds",
    UpperTarget = "upperTarget",
    V = "v",
    VaultId = "vaultID",
    VaultIdId = "vaultID__id",
    VaultIdPoolCount = "vaultID__poolCount",
    VaultIdProtocolFeesCollector = "vaultID__protocolFeesCollector",
    VaultIdTotalLiquidity = "vaultID__totalLiquidity",
    VaultIdTotalProtocolFee = "vaultID__totalProtocolFee",
    VaultIdTotalSwapCount = "vaultID__totalSwapCount",
    VaultIdTotalSwapFee = "vaultID__totalSwapFee",
    VaultIdTotalSwapVolume = "vaultID__totalSwapVolume",
    W = "w",
    WeightUpdates = "weightUpdates",
    WrappedIndex = "wrappedIndex",
    Z = "z"
}
type PriceRateProvider_Filter = {
    /** Filter for the block changed event. */
    _change_block?: InputMaybe$1<BlockChangedFilter$1>;
    address?: InputMaybe$1<Scalars$1['Bytes']>;
    address_contains?: InputMaybe$1<Scalars$1['Bytes']>;
    address_gt?: InputMaybe$1<Scalars$1['Bytes']>;
    address_gte?: InputMaybe$1<Scalars$1['Bytes']>;
    address_in?: InputMaybe$1<Array<Scalars$1['Bytes']>>;
    address_lt?: InputMaybe$1<Scalars$1['Bytes']>;
    address_lte?: InputMaybe$1<Scalars$1['Bytes']>;
    address_not?: InputMaybe$1<Scalars$1['Bytes']>;
    address_not_contains?: InputMaybe$1<Scalars$1['Bytes']>;
    address_not_in?: InputMaybe$1<Array<Scalars$1['Bytes']>>;
    and?: InputMaybe$1<Array<InputMaybe$1<PriceRateProvider_Filter>>>;
    cacheDuration?: InputMaybe$1<Scalars$1['Int']>;
    cacheDuration_gt?: InputMaybe$1<Scalars$1['Int']>;
    cacheDuration_gte?: InputMaybe$1<Scalars$1['Int']>;
    cacheDuration_in?: InputMaybe$1<Array<Scalars$1['Int']>>;
    cacheDuration_lt?: InputMaybe$1<Scalars$1['Int']>;
    cacheDuration_lte?: InputMaybe$1<Scalars$1['Int']>;
    cacheDuration_not?: InputMaybe$1<Scalars$1['Int']>;
    cacheDuration_not_in?: InputMaybe$1<Array<Scalars$1['Int']>>;
    cacheExpiry?: InputMaybe$1<Scalars$1['Int']>;
    cacheExpiry_gt?: InputMaybe$1<Scalars$1['Int']>;
    cacheExpiry_gte?: InputMaybe$1<Scalars$1['Int']>;
    cacheExpiry_in?: InputMaybe$1<Array<Scalars$1['Int']>>;
    cacheExpiry_lt?: InputMaybe$1<Scalars$1['Int']>;
    cacheExpiry_lte?: InputMaybe$1<Scalars$1['Int']>;
    cacheExpiry_not?: InputMaybe$1<Scalars$1['Int']>;
    cacheExpiry_not_in?: InputMaybe$1<Array<Scalars$1['Int']>>;
    id?: InputMaybe$1<Scalars$1['ID']>;
    id_gt?: InputMaybe$1<Scalars$1['ID']>;
    id_gte?: InputMaybe$1<Scalars$1['ID']>;
    id_in?: InputMaybe$1<Array<Scalars$1['ID']>>;
    id_lt?: InputMaybe$1<Scalars$1['ID']>;
    id_lte?: InputMaybe$1<Scalars$1['ID']>;
    id_not?: InputMaybe$1<Scalars$1['ID']>;
    id_not_in?: InputMaybe$1<Array<Scalars$1['ID']>>;
    lastCached?: InputMaybe$1<Scalars$1['Int']>;
    lastCached_gt?: InputMaybe$1<Scalars$1['Int']>;
    lastCached_gte?: InputMaybe$1<Scalars$1['Int']>;
    lastCached_in?: InputMaybe$1<Array<Scalars$1['Int']>>;
    lastCached_lt?: InputMaybe$1<Scalars$1['Int']>;
    lastCached_lte?: InputMaybe$1<Scalars$1['Int']>;
    lastCached_not?: InputMaybe$1<Scalars$1['Int']>;
    lastCached_not_in?: InputMaybe$1<Array<Scalars$1['Int']>>;
    or?: InputMaybe$1<Array<InputMaybe$1<PriceRateProvider_Filter>>>;
    poolId?: InputMaybe$1<Scalars$1['String']>;
    poolId_?: InputMaybe$1<Pool_Filter$1>;
    poolId_contains?: InputMaybe$1<Scalars$1['String']>;
    poolId_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolId_ends_with?: InputMaybe$1<Scalars$1['String']>;
    poolId_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolId_gt?: InputMaybe$1<Scalars$1['String']>;
    poolId_gte?: InputMaybe$1<Scalars$1['String']>;
    poolId_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    poolId_lt?: InputMaybe$1<Scalars$1['String']>;
    poolId_lte?: InputMaybe$1<Scalars$1['String']>;
    poolId_not?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_contains?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_ends_with?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    poolId_not_starts_with?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolId_starts_with?: InputMaybe$1<Scalars$1['String']>;
    poolId_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    rate?: InputMaybe$1<Scalars$1['BigDecimal']>;
    rate_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    rate_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    rate_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    rate_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    rate_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    rate_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    rate_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    token?: InputMaybe$1<Scalars$1['String']>;
    token_?: InputMaybe$1<PoolToken_Filter>;
    token_contains?: InputMaybe$1<Scalars$1['String']>;
    token_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    token_ends_with?: InputMaybe$1<Scalars$1['String']>;
    token_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    token_gt?: InputMaybe$1<Scalars$1['String']>;
    token_gte?: InputMaybe$1<Scalars$1['String']>;
    token_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    token_lt?: InputMaybe$1<Scalars$1['String']>;
    token_lte?: InputMaybe$1<Scalars$1['String']>;
    token_not?: InputMaybe$1<Scalars$1['String']>;
    token_not_contains?: InputMaybe$1<Scalars$1['String']>;
    token_not_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    token_not_ends_with?: InputMaybe$1<Scalars$1['String']>;
    token_not_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    token_not_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    token_not_starts_with?: InputMaybe$1<Scalars$1['String']>;
    token_not_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    token_starts_with?: InputMaybe$1<Scalars$1['String']>;
    token_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
};
type ProtocolIdData_Filter = {
    /** Filter for the block changed event. */
    _change_block?: InputMaybe$1<BlockChangedFilter$1>;
    and?: InputMaybe$1<Array<InputMaybe$1<ProtocolIdData_Filter>>>;
    id?: InputMaybe$1<Scalars$1['ID']>;
    id_gt?: InputMaybe$1<Scalars$1['ID']>;
    id_gte?: InputMaybe$1<Scalars$1['ID']>;
    id_in?: InputMaybe$1<Array<Scalars$1['ID']>>;
    id_lt?: InputMaybe$1<Scalars$1['ID']>;
    id_lte?: InputMaybe$1<Scalars$1['ID']>;
    id_not?: InputMaybe$1<Scalars$1['ID']>;
    id_not_in?: InputMaybe$1<Array<Scalars$1['ID']>>;
    name?: InputMaybe$1<Scalars$1['String']>;
    name_contains?: InputMaybe$1<Scalars$1['String']>;
    name_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    name_ends_with?: InputMaybe$1<Scalars$1['String']>;
    name_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    name_gt?: InputMaybe$1<Scalars$1['String']>;
    name_gte?: InputMaybe$1<Scalars$1['String']>;
    name_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    name_lt?: InputMaybe$1<Scalars$1['String']>;
    name_lte?: InputMaybe$1<Scalars$1['String']>;
    name_not?: InputMaybe$1<Scalars$1['String']>;
    name_not_contains?: InputMaybe$1<Scalars$1['String']>;
    name_not_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    name_not_ends_with?: InputMaybe$1<Scalars$1['String']>;
    name_not_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    name_not_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    name_not_starts_with?: InputMaybe$1<Scalars$1['String']>;
    name_not_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    name_starts_with?: InputMaybe$1<Scalars$1['String']>;
    name_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    or?: InputMaybe$1<Array<InputMaybe$1<ProtocolIdData_Filter>>>;
};
type Swap_Filter = {
    /** Filter for the block changed event. */
    _change_block?: InputMaybe$1<BlockChangedFilter$1>;
    and?: InputMaybe$1<Array<InputMaybe$1<Swap_Filter>>>;
    caller?: InputMaybe$1<Scalars$1['Bytes']>;
    caller_contains?: InputMaybe$1<Scalars$1['Bytes']>;
    caller_gt?: InputMaybe$1<Scalars$1['Bytes']>;
    caller_gte?: InputMaybe$1<Scalars$1['Bytes']>;
    caller_in?: InputMaybe$1<Array<Scalars$1['Bytes']>>;
    caller_lt?: InputMaybe$1<Scalars$1['Bytes']>;
    caller_lte?: InputMaybe$1<Scalars$1['Bytes']>;
    caller_not?: InputMaybe$1<Scalars$1['Bytes']>;
    caller_not_contains?: InputMaybe$1<Scalars$1['Bytes']>;
    caller_not_in?: InputMaybe$1<Array<Scalars$1['Bytes']>>;
    id?: InputMaybe$1<Scalars$1['ID']>;
    id_gt?: InputMaybe$1<Scalars$1['ID']>;
    id_gte?: InputMaybe$1<Scalars$1['ID']>;
    id_in?: InputMaybe$1<Array<Scalars$1['ID']>>;
    id_lt?: InputMaybe$1<Scalars$1['ID']>;
    id_lte?: InputMaybe$1<Scalars$1['ID']>;
    id_not?: InputMaybe$1<Scalars$1['ID']>;
    id_not_in?: InputMaybe$1<Array<Scalars$1['ID']>>;
    or?: InputMaybe$1<Array<InputMaybe$1<Swap_Filter>>>;
    poolId?: InputMaybe$1<Scalars$1['String']>;
    poolId_?: InputMaybe$1<Pool_Filter$1>;
    poolId_contains?: InputMaybe$1<Scalars$1['String']>;
    poolId_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolId_ends_with?: InputMaybe$1<Scalars$1['String']>;
    poolId_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolId_gt?: InputMaybe$1<Scalars$1['String']>;
    poolId_gte?: InputMaybe$1<Scalars$1['String']>;
    poolId_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    poolId_lt?: InputMaybe$1<Scalars$1['String']>;
    poolId_lte?: InputMaybe$1<Scalars$1['String']>;
    poolId_not?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_contains?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_ends_with?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    poolId_not_starts_with?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolId_starts_with?: InputMaybe$1<Scalars$1['String']>;
    poolId_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    timestamp?: InputMaybe$1<Scalars$1['Int']>;
    timestamp_gt?: InputMaybe$1<Scalars$1['Int']>;
    timestamp_gte?: InputMaybe$1<Scalars$1['Int']>;
    timestamp_in?: InputMaybe$1<Array<Scalars$1['Int']>>;
    timestamp_lt?: InputMaybe$1<Scalars$1['Int']>;
    timestamp_lte?: InputMaybe$1<Scalars$1['Int']>;
    timestamp_not?: InputMaybe$1<Scalars$1['Int']>;
    timestamp_not_in?: InputMaybe$1<Array<Scalars$1['Int']>>;
    tokenAmountIn?: InputMaybe$1<Scalars$1['BigDecimal']>;
    tokenAmountIn_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    tokenAmountIn_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    tokenAmountIn_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    tokenAmountIn_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    tokenAmountIn_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    tokenAmountIn_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    tokenAmountIn_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    tokenAmountOut?: InputMaybe$1<Scalars$1['BigDecimal']>;
    tokenAmountOut_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    tokenAmountOut_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    tokenAmountOut_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    tokenAmountOut_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    tokenAmountOut_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    tokenAmountOut_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    tokenAmountOut_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    tokenIn?: InputMaybe$1<Scalars$1['Bytes']>;
    tokenInSym?: InputMaybe$1<Scalars$1['String']>;
    tokenInSym_contains?: InputMaybe$1<Scalars$1['String']>;
    tokenInSym_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    tokenInSym_ends_with?: InputMaybe$1<Scalars$1['String']>;
    tokenInSym_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    tokenInSym_gt?: InputMaybe$1<Scalars$1['String']>;
    tokenInSym_gte?: InputMaybe$1<Scalars$1['String']>;
    tokenInSym_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    tokenInSym_lt?: InputMaybe$1<Scalars$1['String']>;
    tokenInSym_lte?: InputMaybe$1<Scalars$1['String']>;
    tokenInSym_not?: InputMaybe$1<Scalars$1['String']>;
    tokenInSym_not_contains?: InputMaybe$1<Scalars$1['String']>;
    tokenInSym_not_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    tokenInSym_not_ends_with?: InputMaybe$1<Scalars$1['String']>;
    tokenInSym_not_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    tokenInSym_not_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    tokenInSym_not_starts_with?: InputMaybe$1<Scalars$1['String']>;
    tokenInSym_not_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    tokenInSym_starts_with?: InputMaybe$1<Scalars$1['String']>;
    tokenInSym_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    tokenIn_contains?: InputMaybe$1<Scalars$1['Bytes']>;
    tokenIn_gt?: InputMaybe$1<Scalars$1['Bytes']>;
    tokenIn_gte?: InputMaybe$1<Scalars$1['Bytes']>;
    tokenIn_in?: InputMaybe$1<Array<Scalars$1['Bytes']>>;
    tokenIn_lt?: InputMaybe$1<Scalars$1['Bytes']>;
    tokenIn_lte?: InputMaybe$1<Scalars$1['Bytes']>;
    tokenIn_not?: InputMaybe$1<Scalars$1['Bytes']>;
    tokenIn_not_contains?: InputMaybe$1<Scalars$1['Bytes']>;
    tokenIn_not_in?: InputMaybe$1<Array<Scalars$1['Bytes']>>;
    tokenOut?: InputMaybe$1<Scalars$1['Bytes']>;
    tokenOutSym?: InputMaybe$1<Scalars$1['String']>;
    tokenOutSym_contains?: InputMaybe$1<Scalars$1['String']>;
    tokenOutSym_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    tokenOutSym_ends_with?: InputMaybe$1<Scalars$1['String']>;
    tokenOutSym_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    tokenOutSym_gt?: InputMaybe$1<Scalars$1['String']>;
    tokenOutSym_gte?: InputMaybe$1<Scalars$1['String']>;
    tokenOutSym_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    tokenOutSym_lt?: InputMaybe$1<Scalars$1['String']>;
    tokenOutSym_lte?: InputMaybe$1<Scalars$1['String']>;
    tokenOutSym_not?: InputMaybe$1<Scalars$1['String']>;
    tokenOutSym_not_contains?: InputMaybe$1<Scalars$1['String']>;
    tokenOutSym_not_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    tokenOutSym_not_ends_with?: InputMaybe$1<Scalars$1['String']>;
    tokenOutSym_not_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    tokenOutSym_not_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    tokenOutSym_not_starts_with?: InputMaybe$1<Scalars$1['String']>;
    tokenOutSym_not_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    tokenOutSym_starts_with?: InputMaybe$1<Scalars$1['String']>;
    tokenOutSym_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    tokenOut_contains?: InputMaybe$1<Scalars$1['Bytes']>;
    tokenOut_gt?: InputMaybe$1<Scalars$1['Bytes']>;
    tokenOut_gte?: InputMaybe$1<Scalars$1['Bytes']>;
    tokenOut_in?: InputMaybe$1<Array<Scalars$1['Bytes']>>;
    tokenOut_lt?: InputMaybe$1<Scalars$1['Bytes']>;
    tokenOut_lte?: InputMaybe$1<Scalars$1['Bytes']>;
    tokenOut_not?: InputMaybe$1<Scalars$1['Bytes']>;
    tokenOut_not_contains?: InputMaybe$1<Scalars$1['Bytes']>;
    tokenOut_not_in?: InputMaybe$1<Array<Scalars$1['Bytes']>>;
    tx?: InputMaybe$1<Scalars$1['Bytes']>;
    tx_contains?: InputMaybe$1<Scalars$1['Bytes']>;
    tx_gt?: InputMaybe$1<Scalars$1['Bytes']>;
    tx_gte?: InputMaybe$1<Scalars$1['Bytes']>;
    tx_in?: InputMaybe$1<Array<Scalars$1['Bytes']>>;
    tx_lt?: InputMaybe$1<Scalars$1['Bytes']>;
    tx_lte?: InputMaybe$1<Scalars$1['Bytes']>;
    tx_not?: InputMaybe$1<Scalars$1['Bytes']>;
    tx_not_contains?: InputMaybe$1<Scalars$1['Bytes']>;
    tx_not_in?: InputMaybe$1<Array<Scalars$1['Bytes']>>;
    userAddress?: InputMaybe$1<Scalars$1['String']>;
    userAddress_?: InputMaybe$1<User_Filter$1>;
    userAddress_contains?: InputMaybe$1<Scalars$1['String']>;
    userAddress_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    userAddress_ends_with?: InputMaybe$1<Scalars$1['String']>;
    userAddress_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    userAddress_gt?: InputMaybe$1<Scalars$1['String']>;
    userAddress_gte?: InputMaybe$1<Scalars$1['String']>;
    userAddress_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    userAddress_lt?: InputMaybe$1<Scalars$1['String']>;
    userAddress_lte?: InputMaybe$1<Scalars$1['String']>;
    userAddress_not?: InputMaybe$1<Scalars$1['String']>;
    userAddress_not_contains?: InputMaybe$1<Scalars$1['String']>;
    userAddress_not_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    userAddress_not_ends_with?: InputMaybe$1<Scalars$1['String']>;
    userAddress_not_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    userAddress_not_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    userAddress_not_starts_with?: InputMaybe$1<Scalars$1['String']>;
    userAddress_not_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    userAddress_starts_with?: InputMaybe$1<Scalars$1['String']>;
    userAddress_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    valueUSD?: InputMaybe$1<Scalars$1['BigDecimal']>;
    valueUSD_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    valueUSD_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    valueUSD_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    valueUSD_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    valueUSD_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    valueUSD_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    valueUSD_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
};
type TokenPrice_Filter = {
    /** Filter for the block changed event. */
    _change_block?: InputMaybe$1<BlockChangedFilter$1>;
    amount?: InputMaybe$1<Scalars$1['BigDecimal']>;
    amount_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    amount_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    amount_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    amount_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    amount_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    amount_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    amount_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    and?: InputMaybe$1<Array<InputMaybe$1<TokenPrice_Filter>>>;
    asset?: InputMaybe$1<Scalars$1['Bytes']>;
    asset_contains?: InputMaybe$1<Scalars$1['Bytes']>;
    asset_gt?: InputMaybe$1<Scalars$1['Bytes']>;
    asset_gte?: InputMaybe$1<Scalars$1['Bytes']>;
    asset_in?: InputMaybe$1<Array<Scalars$1['Bytes']>>;
    asset_lt?: InputMaybe$1<Scalars$1['Bytes']>;
    asset_lte?: InputMaybe$1<Scalars$1['Bytes']>;
    asset_not?: InputMaybe$1<Scalars$1['Bytes']>;
    asset_not_contains?: InputMaybe$1<Scalars$1['Bytes']>;
    asset_not_in?: InputMaybe$1<Array<Scalars$1['Bytes']>>;
    block?: InputMaybe$1<Scalars$1['BigInt']>;
    block_gt?: InputMaybe$1<Scalars$1['BigInt']>;
    block_gte?: InputMaybe$1<Scalars$1['BigInt']>;
    block_in?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
    block_lt?: InputMaybe$1<Scalars$1['BigInt']>;
    block_lte?: InputMaybe$1<Scalars$1['BigInt']>;
    block_not?: InputMaybe$1<Scalars$1['BigInt']>;
    block_not_in?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
    id?: InputMaybe$1<Scalars$1['ID']>;
    id_gt?: InputMaybe$1<Scalars$1['ID']>;
    id_gte?: InputMaybe$1<Scalars$1['ID']>;
    id_in?: InputMaybe$1<Array<Scalars$1['ID']>>;
    id_lt?: InputMaybe$1<Scalars$1['ID']>;
    id_lte?: InputMaybe$1<Scalars$1['ID']>;
    id_not?: InputMaybe$1<Scalars$1['ID']>;
    id_not_in?: InputMaybe$1<Array<Scalars$1['ID']>>;
    or?: InputMaybe$1<Array<InputMaybe$1<TokenPrice_Filter>>>;
    poolId?: InputMaybe$1<Scalars$1['String']>;
    poolId_?: InputMaybe$1<Pool_Filter$1>;
    poolId_contains?: InputMaybe$1<Scalars$1['String']>;
    poolId_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolId_ends_with?: InputMaybe$1<Scalars$1['String']>;
    poolId_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolId_gt?: InputMaybe$1<Scalars$1['String']>;
    poolId_gte?: InputMaybe$1<Scalars$1['String']>;
    poolId_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    poolId_lt?: InputMaybe$1<Scalars$1['String']>;
    poolId_lte?: InputMaybe$1<Scalars$1['String']>;
    poolId_not?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_contains?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_ends_with?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    poolId_not_starts_with?: InputMaybe$1<Scalars$1['String']>;
    poolId_not_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    poolId_starts_with?: InputMaybe$1<Scalars$1['String']>;
    poolId_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    price?: InputMaybe$1<Scalars$1['BigDecimal']>;
    price_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    price_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    price_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    price_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    price_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    price_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    price_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    pricingAsset?: InputMaybe$1<Scalars$1['Bytes']>;
    pricingAsset_contains?: InputMaybe$1<Scalars$1['Bytes']>;
    pricingAsset_gt?: InputMaybe$1<Scalars$1['Bytes']>;
    pricingAsset_gte?: InputMaybe$1<Scalars$1['Bytes']>;
    pricingAsset_in?: InputMaybe$1<Array<Scalars$1['Bytes']>>;
    pricingAsset_lt?: InputMaybe$1<Scalars$1['Bytes']>;
    pricingAsset_lte?: InputMaybe$1<Scalars$1['Bytes']>;
    pricingAsset_not?: InputMaybe$1<Scalars$1['Bytes']>;
    pricingAsset_not_contains?: InputMaybe$1<Scalars$1['Bytes']>;
    pricingAsset_not_in?: InputMaybe$1<Array<Scalars$1['Bytes']>>;
    timestamp?: InputMaybe$1<Scalars$1['Int']>;
    timestamp_gt?: InputMaybe$1<Scalars$1['Int']>;
    timestamp_gte?: InputMaybe$1<Scalars$1['Int']>;
    timestamp_in?: InputMaybe$1<Array<Scalars$1['Int']>>;
    timestamp_lt?: InputMaybe$1<Scalars$1['Int']>;
    timestamp_lte?: InputMaybe$1<Scalars$1['Int']>;
    timestamp_not?: InputMaybe$1<Scalars$1['Int']>;
    timestamp_not_in?: InputMaybe$1<Array<Scalars$1['Int']>>;
};
declare enum TokenPrice_OrderBy {
    Amount = "amount",
    Asset = "asset",
    Block = "block",
    Id = "id",
    PoolId = "poolId",
    PoolIdAddress = "poolId__address",
    PoolIdAlpha = "poolId__alpha",
    PoolIdAmp = "poolId__amp",
    PoolIdBaseToken = "poolId__baseToken",
    PoolIdBeta = "poolId__beta",
    PoolIdC = "poolId__c",
    PoolIdCreateTime = "poolId__createTime",
    PoolIdDSq = "poolId__dSq",
    PoolIdDelta = "poolId__delta",
    PoolIdEpsilon = "poolId__epsilon",
    PoolIdExpiryTime = "poolId__expiryTime",
    PoolIdFactory = "poolId__factory",
    PoolIdHoldersCount = "poolId__holdersCount",
    PoolIdId = "poolId__id",
    PoolIdIsInRecoveryMode = "poolId__isInRecoveryMode",
    PoolIdIsPaused = "poolId__isPaused",
    PoolIdJoinExitEnabled = "poolId__joinExitEnabled",
    PoolIdLambda = "poolId__lambda",
    PoolIdLastJoinExitAmp = "poolId__lastJoinExitAmp",
    PoolIdLastPostJoinExitInvariant = "poolId__lastPostJoinExitInvariant",
    PoolIdLowerTarget = "poolId__lowerTarget",
    PoolIdMainIndex = "poolId__mainIndex",
    PoolIdManagementAumFee = "poolId__managementAumFee",
    PoolIdManagementFee = "poolId__managementFee",
    PoolIdMustAllowlistLPs = "poolId__mustAllowlistLPs",
    PoolIdName = "poolId__name",
    PoolIdOracleEnabled = "poolId__oracleEnabled",
    PoolIdOwner = "poolId__owner",
    PoolIdPoolType = "poolId__poolType",
    PoolIdPoolTypeVersion = "poolId__poolTypeVersion",
    PoolIdPrincipalToken = "poolId__principalToken",
    PoolIdProtocolAumFeeCache = "poolId__protocolAumFeeCache",
    PoolIdProtocolId = "poolId__protocolId",
    PoolIdProtocolSwapFeeCache = "poolId__protocolSwapFeeCache",
    PoolIdProtocolYieldFeeCache = "poolId__protocolYieldFeeCache",
    PoolIdRoot3Alpha = "poolId__root3Alpha",
    PoolIdS = "poolId__s",
    PoolIdSqrtAlpha = "poolId__sqrtAlpha",
    PoolIdSqrtBeta = "poolId__sqrtBeta",
    PoolIdStrategyType = "poolId__strategyType",
    PoolIdSwapEnabled = "poolId__swapEnabled",
    PoolIdSwapEnabledCurationSignal = "poolId__swapEnabledCurationSignal",
    PoolIdSwapEnabledInternal = "poolId__swapEnabledInternal",
    PoolIdSwapFee = "poolId__swapFee",
    PoolIdSwapsCount = "poolId__swapsCount",
    PoolIdSymbol = "poolId__symbol",
    PoolIdTauAlphaX = "poolId__tauAlphaX",
    PoolIdTauAlphaY = "poolId__tauAlphaY",
    PoolIdTauBetaX = "poolId__tauBetaX",
    PoolIdTauBetaY = "poolId__tauBetaY",
    PoolIdTotalAumFeeCollectedInBpt = "poolId__totalAumFeeCollectedInBPT",
    PoolIdTotalLiquidity = "poolId__totalLiquidity",
    PoolIdTotalLiquiditySansBpt = "poolId__totalLiquiditySansBPT",
    PoolIdTotalProtocolFee = "poolId__totalProtocolFee",
    PoolIdTotalProtocolFeePaidInBpt = "poolId__totalProtocolFeePaidInBPT",
    PoolIdTotalShares = "poolId__totalShares",
    PoolIdTotalSwapFee = "poolId__totalSwapFee",
    PoolIdTotalSwapVolume = "poolId__totalSwapVolume",
    PoolIdTotalWeight = "poolId__totalWeight",
    PoolIdTx = "poolId__tx",
    PoolIdU = "poolId__u",
    PoolIdUnitSeconds = "poolId__unitSeconds",
    PoolIdUpperTarget = "poolId__upperTarget",
    PoolIdV = "poolId__v",
    PoolIdW = "poolId__w",
    PoolIdWrappedIndex = "poolId__wrappedIndex",
    PoolIdZ = "poolId__z",
    Price = "price",
    PricingAsset = "pricingAsset",
    Timestamp = "timestamp"
}
type Token_Filter = {
    /** Filter for the block changed event. */
    _change_block?: InputMaybe$1<BlockChangedFilter$1>;
    address?: InputMaybe$1<Scalars$1['String']>;
    address_contains?: InputMaybe$1<Scalars$1['String']>;
    address_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    address_ends_with?: InputMaybe$1<Scalars$1['String']>;
    address_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    address_gt?: InputMaybe$1<Scalars$1['String']>;
    address_gte?: InputMaybe$1<Scalars$1['String']>;
    address_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    address_lt?: InputMaybe$1<Scalars$1['String']>;
    address_lte?: InputMaybe$1<Scalars$1['String']>;
    address_not?: InputMaybe$1<Scalars$1['String']>;
    address_not_contains?: InputMaybe$1<Scalars$1['String']>;
    address_not_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    address_not_ends_with?: InputMaybe$1<Scalars$1['String']>;
    address_not_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    address_not_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    address_not_starts_with?: InputMaybe$1<Scalars$1['String']>;
    address_not_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    address_starts_with?: InputMaybe$1<Scalars$1['String']>;
    address_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    and?: InputMaybe$1<Array<InputMaybe$1<Token_Filter>>>;
    decimals?: InputMaybe$1<Scalars$1['Int']>;
    decimals_gt?: InputMaybe$1<Scalars$1['Int']>;
    decimals_gte?: InputMaybe$1<Scalars$1['Int']>;
    decimals_in?: InputMaybe$1<Array<Scalars$1['Int']>>;
    decimals_lt?: InputMaybe$1<Scalars$1['Int']>;
    decimals_lte?: InputMaybe$1<Scalars$1['Int']>;
    decimals_not?: InputMaybe$1<Scalars$1['Int']>;
    decimals_not_in?: InputMaybe$1<Array<Scalars$1['Int']>>;
    fxOracleDecimals?: InputMaybe$1<Scalars$1['Int']>;
    fxOracleDecimals_gt?: InputMaybe$1<Scalars$1['Int']>;
    fxOracleDecimals_gte?: InputMaybe$1<Scalars$1['Int']>;
    fxOracleDecimals_in?: InputMaybe$1<Array<Scalars$1['Int']>>;
    fxOracleDecimals_lt?: InputMaybe$1<Scalars$1['Int']>;
    fxOracleDecimals_lte?: InputMaybe$1<Scalars$1['Int']>;
    fxOracleDecimals_not?: InputMaybe$1<Scalars$1['Int']>;
    fxOracleDecimals_not_in?: InputMaybe$1<Array<Scalars$1['Int']>>;
    id?: InputMaybe$1<Scalars$1['ID']>;
    id_gt?: InputMaybe$1<Scalars$1['ID']>;
    id_gte?: InputMaybe$1<Scalars$1['ID']>;
    id_in?: InputMaybe$1<Array<Scalars$1['ID']>>;
    id_lt?: InputMaybe$1<Scalars$1['ID']>;
    id_lte?: InputMaybe$1<Scalars$1['ID']>;
    id_not?: InputMaybe$1<Scalars$1['ID']>;
    id_not_in?: InputMaybe$1<Array<Scalars$1['ID']>>;
    latestFXPrice?: InputMaybe$1<Scalars$1['BigDecimal']>;
    latestFXPrice_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    latestFXPrice_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    latestFXPrice_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    latestFXPrice_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    latestFXPrice_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    latestFXPrice_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    latestFXPrice_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    latestPrice?: InputMaybe$1<Scalars$1['String']>;
    latestPrice_?: InputMaybe$1<LatestPrice_Filter>;
    latestPrice_contains?: InputMaybe$1<Scalars$1['String']>;
    latestPrice_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    latestPrice_ends_with?: InputMaybe$1<Scalars$1['String']>;
    latestPrice_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    latestPrice_gt?: InputMaybe$1<Scalars$1['String']>;
    latestPrice_gte?: InputMaybe$1<Scalars$1['String']>;
    latestPrice_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    latestPrice_lt?: InputMaybe$1<Scalars$1['String']>;
    latestPrice_lte?: InputMaybe$1<Scalars$1['String']>;
    latestPrice_not?: InputMaybe$1<Scalars$1['String']>;
    latestPrice_not_contains?: InputMaybe$1<Scalars$1['String']>;
    latestPrice_not_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    latestPrice_not_ends_with?: InputMaybe$1<Scalars$1['String']>;
    latestPrice_not_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    latestPrice_not_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    latestPrice_not_starts_with?: InputMaybe$1<Scalars$1['String']>;
    latestPrice_not_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    latestPrice_starts_with?: InputMaybe$1<Scalars$1['String']>;
    latestPrice_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    latestUSDPrice?: InputMaybe$1<Scalars$1['BigDecimal']>;
    latestUSDPriceTimestamp?: InputMaybe$1<Scalars$1['BigInt']>;
    latestUSDPriceTimestamp_gt?: InputMaybe$1<Scalars$1['BigInt']>;
    latestUSDPriceTimestamp_gte?: InputMaybe$1<Scalars$1['BigInt']>;
    latestUSDPriceTimestamp_in?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
    latestUSDPriceTimestamp_lt?: InputMaybe$1<Scalars$1['BigInt']>;
    latestUSDPriceTimestamp_lte?: InputMaybe$1<Scalars$1['BigInt']>;
    latestUSDPriceTimestamp_not?: InputMaybe$1<Scalars$1['BigInt']>;
    latestUSDPriceTimestamp_not_in?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
    latestUSDPrice_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    latestUSDPrice_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    latestUSDPrice_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    latestUSDPrice_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    latestUSDPrice_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    latestUSDPrice_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    latestUSDPrice_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    name?: InputMaybe$1<Scalars$1['String']>;
    name_contains?: InputMaybe$1<Scalars$1['String']>;
    name_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    name_ends_with?: InputMaybe$1<Scalars$1['String']>;
    name_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    name_gt?: InputMaybe$1<Scalars$1['String']>;
    name_gte?: InputMaybe$1<Scalars$1['String']>;
    name_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    name_lt?: InputMaybe$1<Scalars$1['String']>;
    name_lte?: InputMaybe$1<Scalars$1['String']>;
    name_not?: InputMaybe$1<Scalars$1['String']>;
    name_not_contains?: InputMaybe$1<Scalars$1['String']>;
    name_not_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    name_not_ends_with?: InputMaybe$1<Scalars$1['String']>;
    name_not_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    name_not_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    name_not_starts_with?: InputMaybe$1<Scalars$1['String']>;
    name_not_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    name_starts_with?: InputMaybe$1<Scalars$1['String']>;
    name_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    or?: InputMaybe$1<Array<InputMaybe$1<Token_Filter>>>;
    pool?: InputMaybe$1<Scalars$1['String']>;
    pool_?: InputMaybe$1<Pool_Filter$1>;
    pool_contains?: InputMaybe$1<Scalars$1['String']>;
    pool_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    pool_ends_with?: InputMaybe$1<Scalars$1['String']>;
    pool_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    pool_gt?: InputMaybe$1<Scalars$1['String']>;
    pool_gte?: InputMaybe$1<Scalars$1['String']>;
    pool_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    pool_lt?: InputMaybe$1<Scalars$1['String']>;
    pool_lte?: InputMaybe$1<Scalars$1['String']>;
    pool_not?: InputMaybe$1<Scalars$1['String']>;
    pool_not_contains?: InputMaybe$1<Scalars$1['String']>;
    pool_not_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    pool_not_ends_with?: InputMaybe$1<Scalars$1['String']>;
    pool_not_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    pool_not_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    pool_not_starts_with?: InputMaybe$1<Scalars$1['String']>;
    pool_not_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    pool_starts_with?: InputMaybe$1<Scalars$1['String']>;
    pool_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    symbol?: InputMaybe$1<Scalars$1['String']>;
    symbol_contains?: InputMaybe$1<Scalars$1['String']>;
    symbol_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    symbol_ends_with?: InputMaybe$1<Scalars$1['String']>;
    symbol_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    symbol_gt?: InputMaybe$1<Scalars$1['String']>;
    symbol_gte?: InputMaybe$1<Scalars$1['String']>;
    symbol_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    symbol_lt?: InputMaybe$1<Scalars$1['String']>;
    symbol_lte?: InputMaybe$1<Scalars$1['String']>;
    symbol_not?: InputMaybe$1<Scalars$1['String']>;
    symbol_not_contains?: InputMaybe$1<Scalars$1['String']>;
    symbol_not_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    symbol_not_ends_with?: InputMaybe$1<Scalars$1['String']>;
    symbol_not_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    symbol_not_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    symbol_not_starts_with?: InputMaybe$1<Scalars$1['String']>;
    symbol_not_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    symbol_starts_with?: InputMaybe$1<Scalars$1['String']>;
    symbol_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    totalBalanceNotional?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalBalanceNotional_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalBalanceNotional_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalBalanceNotional_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    totalBalanceNotional_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalBalanceNotional_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalBalanceNotional_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalBalanceNotional_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    totalBalanceUSD?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalBalanceUSD_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalBalanceUSD_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalBalanceUSD_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    totalBalanceUSD_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalBalanceUSD_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalBalanceUSD_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalBalanceUSD_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    totalSwapCount?: InputMaybe$1<Scalars$1['BigInt']>;
    totalSwapCount_gt?: InputMaybe$1<Scalars$1['BigInt']>;
    totalSwapCount_gte?: InputMaybe$1<Scalars$1['BigInt']>;
    totalSwapCount_in?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
    totalSwapCount_lt?: InputMaybe$1<Scalars$1['BigInt']>;
    totalSwapCount_lte?: InputMaybe$1<Scalars$1['BigInt']>;
    totalSwapCount_not?: InputMaybe$1<Scalars$1['BigInt']>;
    totalSwapCount_not_in?: InputMaybe$1<Array<Scalars$1['BigInt']>>;
    totalVolumeNotional?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalVolumeNotional_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalVolumeNotional_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalVolumeNotional_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    totalVolumeNotional_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalVolumeNotional_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalVolumeNotional_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalVolumeNotional_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    totalVolumeUSD?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalVolumeUSD_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalVolumeUSD_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalVolumeUSD_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    totalVolumeUSD_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalVolumeUSD_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalVolumeUSD_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    totalVolumeUSD_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
};
type UserInternalBalance_Filter = {
    /** Filter for the block changed event. */
    _change_block?: InputMaybe$1<BlockChangedFilter$1>;
    and?: InputMaybe$1<Array<InputMaybe$1<UserInternalBalance_Filter>>>;
    balance?: InputMaybe$1<Scalars$1['BigDecimal']>;
    balance_gt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    balance_gte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    balance_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    balance_lt?: InputMaybe$1<Scalars$1['BigDecimal']>;
    balance_lte?: InputMaybe$1<Scalars$1['BigDecimal']>;
    balance_not?: InputMaybe$1<Scalars$1['BigDecimal']>;
    balance_not_in?: InputMaybe$1<Array<Scalars$1['BigDecimal']>>;
    id?: InputMaybe$1<Scalars$1['ID']>;
    id_gt?: InputMaybe$1<Scalars$1['ID']>;
    id_gte?: InputMaybe$1<Scalars$1['ID']>;
    id_in?: InputMaybe$1<Array<Scalars$1['ID']>>;
    id_lt?: InputMaybe$1<Scalars$1['ID']>;
    id_lte?: InputMaybe$1<Scalars$1['ID']>;
    id_not?: InputMaybe$1<Scalars$1['ID']>;
    id_not_in?: InputMaybe$1<Array<Scalars$1['ID']>>;
    or?: InputMaybe$1<Array<InputMaybe$1<UserInternalBalance_Filter>>>;
    token?: InputMaybe$1<Scalars$1['Bytes']>;
    tokenInfo?: InputMaybe$1<Scalars$1['String']>;
    tokenInfo_?: InputMaybe$1<Token_Filter>;
    tokenInfo_contains?: InputMaybe$1<Scalars$1['String']>;
    tokenInfo_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    tokenInfo_ends_with?: InputMaybe$1<Scalars$1['String']>;
    tokenInfo_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    tokenInfo_gt?: InputMaybe$1<Scalars$1['String']>;
    tokenInfo_gte?: InputMaybe$1<Scalars$1['String']>;
    tokenInfo_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    tokenInfo_lt?: InputMaybe$1<Scalars$1['String']>;
    tokenInfo_lte?: InputMaybe$1<Scalars$1['String']>;
    tokenInfo_not?: InputMaybe$1<Scalars$1['String']>;
    tokenInfo_not_contains?: InputMaybe$1<Scalars$1['String']>;
    tokenInfo_not_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    tokenInfo_not_ends_with?: InputMaybe$1<Scalars$1['String']>;
    tokenInfo_not_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    tokenInfo_not_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    tokenInfo_not_starts_with?: InputMaybe$1<Scalars$1['String']>;
    tokenInfo_not_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    tokenInfo_starts_with?: InputMaybe$1<Scalars$1['String']>;
    tokenInfo_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    token_contains?: InputMaybe$1<Scalars$1['Bytes']>;
    token_gt?: InputMaybe$1<Scalars$1['Bytes']>;
    token_gte?: InputMaybe$1<Scalars$1['Bytes']>;
    token_in?: InputMaybe$1<Array<Scalars$1['Bytes']>>;
    token_lt?: InputMaybe$1<Scalars$1['Bytes']>;
    token_lte?: InputMaybe$1<Scalars$1['Bytes']>;
    token_not?: InputMaybe$1<Scalars$1['Bytes']>;
    token_not_contains?: InputMaybe$1<Scalars$1['Bytes']>;
    token_not_in?: InputMaybe$1<Array<Scalars$1['Bytes']>>;
    userAddress?: InputMaybe$1<Scalars$1['String']>;
    userAddress_?: InputMaybe$1<User_Filter$1>;
    userAddress_contains?: InputMaybe$1<Scalars$1['String']>;
    userAddress_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    userAddress_ends_with?: InputMaybe$1<Scalars$1['String']>;
    userAddress_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    userAddress_gt?: InputMaybe$1<Scalars$1['String']>;
    userAddress_gte?: InputMaybe$1<Scalars$1['String']>;
    userAddress_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    userAddress_lt?: InputMaybe$1<Scalars$1['String']>;
    userAddress_lte?: InputMaybe$1<Scalars$1['String']>;
    userAddress_not?: InputMaybe$1<Scalars$1['String']>;
    userAddress_not_contains?: InputMaybe$1<Scalars$1['String']>;
    userAddress_not_contains_nocase?: InputMaybe$1<Scalars$1['String']>;
    userAddress_not_ends_with?: InputMaybe$1<Scalars$1['String']>;
    userAddress_not_ends_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    userAddress_not_in?: InputMaybe$1<Array<Scalars$1['String']>>;
    userAddress_not_starts_with?: InputMaybe$1<Scalars$1['String']>;
    userAddress_not_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
    userAddress_starts_with?: InputMaybe$1<Scalars$1['String']>;
    userAddress_starts_with_nocase?: InputMaybe$1<Scalars$1['String']>;
};
type User_Filter$1 = {
    /** Filter for the block changed event. */
    _change_block?: InputMaybe$1<BlockChangedFilter$1>;
    and?: InputMaybe$1<Array<InputMaybe$1<User_Filter$1>>>;
    id?: InputMaybe$1<Scalars$1['ID']>;
    id_gt?: InputMaybe$1<Scalars$1['ID']>;
    id_gte?: InputMaybe$1<Scalars$1['ID']>;
    id_in?: InputMaybe$1<Array<Scalars$1['ID']>>;
    id_lt?: InputMaybe$1<Scalars$1['ID']>;
    id_lte?: InputMaybe$1<Scalars$1['ID']>;
    id_not?: InputMaybe$1<Scalars$1['ID']>;
    id_not_in?: InputMaybe$1<Array<Scalars$1['ID']>>;
    or?: InputMaybe$1<Array<InputMaybe$1<User_Filter$1>>>;
    sharesOwned_?: InputMaybe$1<PoolShare_Filter>;
    swaps_?: InputMaybe$1<Swap_Filter>;
    userInternalBalances_?: InputMaybe$1<UserInternalBalance_Filter>;
};
declare enum User_OrderBy {
    Id = "id",
    SharesOwned = "sharesOwned",
    Swaps = "swaps",
    UserInternalBalances = "userInternalBalances"
}
type PoolShareQueryVariables = Exact$1<{
    id: Scalars$1['ID'];
    block?: InputMaybe$1<Block_Height$1>;
}>;
type PoolShareQuery = {
    __typename?: 'Query';
    poolShare?: {
        __typename?: 'PoolShare';
        id: string;
        balance: string;
        userAddress: {
            __typename?: 'User';
            id: string;
        };
        poolId: {
            __typename?: 'Pool';
            id: string;
            address: string;
        };
    } | null;
};
type PoolSharesQueryVariables = Exact$1<{
    first?: InputMaybe$1<Scalars$1['Int']>;
    orderBy?: InputMaybe$1<PoolShare_OrderBy>;
    orderDirection?: InputMaybe$1<OrderDirection$1>;
    skip?: InputMaybe$1<Scalars$1['Int']>;
    where?: InputMaybe$1<PoolShare_Filter>;
    block?: InputMaybe$1<Block_Height$1>;
}>;
type PoolSharesQuery = {
    __typename?: 'Query';
    poolShares: Array<{
        __typename?: 'PoolShare';
        id: string;
        balance: string;
        userAddress: {
            __typename?: 'User';
            id: string;
        };
        poolId: {
            __typename?: 'Pool';
            id: string;
            address: string;
        };
    }>;
};
type SubgraphPoolShareFragment = {
    __typename?: 'PoolShare';
    id: string;
    balance: string;
    userAddress: {
        __typename?: 'User';
        id: string;
    };
    poolId: {
        __typename?: 'Pool';
        id: string;
        address: string;
    };
};
type PoolsQueryVariables$1 = Exact$1<{
    skip?: InputMaybe$1<Scalars$1['Int']>;
    first?: InputMaybe$1<Scalars$1['Int']>;
    orderBy?: InputMaybe$1<Pool_OrderBy$1>;
    orderDirection?: InputMaybe$1<OrderDirection$1>;
    where?: InputMaybe$1<Pool_Filter$1>;
    block?: InputMaybe$1<Block_Height$1>;
}>;
type PoolsQuery$1 = {
    __typename?: 'Query';
    pools: Array<{
        __typename?: 'Pool';
        id: string;
        address: string;
        poolType?: string | null;
        poolTypeVersion?: number | null;
        factory?: string | null;
        strategyType: number;
        symbol?: string | null;
        name?: string | null;
        swapEnabled: boolean;
        swapFee: string;
        protocolYieldFeeCache?: string | null;
        protocolSwapFeeCache?: string | null;
        owner?: string | null;
        totalWeight?: string | null;
        totalSwapVolume: string;
        totalSwapFee: string;
        totalLiquidity: string;
        totalShares: string;
        swapsCount: string;
        holdersCount: string;
        tokensList: Array<string>;
        amp?: string | null;
        expiryTime?: string | null;
        unitSeconds?: string | null;
        createTime: number;
        principalToken?: string | null;
        baseToken?: string | null;
        wrappedIndex?: number | null;
        mainIndex?: number | null;
        lowerTarget?: string | null;
        upperTarget?: string | null;
        sqrtAlpha?: string | null;
        sqrtBeta?: string | null;
        root3Alpha?: string | null;
        isInRecoveryMode?: boolean | null;
        isPaused?: boolean | null;
        alpha?: string | null;
        beta?: string | null;
        c?: string | null;
        s?: string | null;
        lambda?: string | null;
        tauAlphaX?: string | null;
        tauAlphaY?: string | null;
        tauBetaX?: string | null;
        tauBetaY?: string | null;
        u?: string | null;
        v?: string | null;
        w?: string | null;
        z?: string | null;
        dSq?: string | null;
        delta?: string | null;
        epsilon?: string | null;
        tokens?: Array<{
            __typename?: 'PoolToken';
            id: string;
            symbol: string;
            name: string;
            decimals: number;
            address: string;
            balance: string;
            managedBalance: string;
            weight?: string | null;
            priceRate: string;
            isExemptFromYieldProtocolFee?: boolean | null;
            token: {
                __typename?: 'Token';
                latestUSDPrice?: string | null;
                latestFXPrice?: string | null;
                pool?: {
                    __typename?: 'Pool';
                    id: string;
                    totalShares: string;
                    address: string;
                    poolType?: string | null;
                    mainIndex?: number | null;
                    tokens?: Array<{
                        __typename?: 'PoolToken';
                        address: string;
                        balance: string;
                        weight?: string | null;
                        priceRate: string;
                        symbol: string;
                        decimals: number;
                        isExemptFromYieldProtocolFee?: boolean | null;
                        token: {
                            __typename?: 'Token';
                            latestUSDPrice?: string | null;
                            pool?: {
                                __typename?: 'Pool';
                                id: string;
                                totalShares: string;
                                address: string;
                                poolType?: string | null;
                                mainIndex?: number | null;
                                tokens?: Array<{
                                    __typename?: 'PoolToken';
                                    address: string;
                                    balance: string;
                                    weight?: string | null;
                                    priceRate: string;
                                    symbol: string;
                                    decimals: number;
                                    isExemptFromYieldProtocolFee?: boolean | null;
                                    token: {
                                        __typename?: 'Token';
                                        latestUSDPrice?: string | null;
                                        pool?: {
                                            __typename?: 'Pool';
                                            id: string;
                                            totalShares: string;
                                            address: string;
                                            poolType?: string | null;
                                            mainIndex?: number | null;
                                        } | null;
                                    };
                                }> | null;
                            } | null;
                        };
                    }> | null;
                } | null;
            };
        }> | null;
        priceRateProviders?: Array<{
            __typename?: 'PriceRateProvider';
            address: string;
            token: {
                __typename?: 'PoolToken';
                address: string;
            };
        }> | null;
    }>;
};
type AllPoolsQueryVariables = Exact$1<{
    skip?: InputMaybe$1<Scalars$1['Int']>;
    first?: InputMaybe$1<Scalars$1['Int']>;
    orderBy?: InputMaybe$1<Pool_OrderBy$1>;
    orderDirection?: InputMaybe$1<OrderDirection$1>;
    where?: InputMaybe$1<Pool_Filter$1>;
    block?: InputMaybe$1<Block_Height$1>;
}>;
type AllPoolsQuery = {
    __typename?: 'Query';
    pool0: Array<{
        __typename?: 'Pool';
        id: string;
        address: string;
        poolType?: string | null;
        poolTypeVersion?: number | null;
        factory?: string | null;
        strategyType: number;
        symbol?: string | null;
        name?: string | null;
        swapEnabled: boolean;
        swapFee: string;
        protocolYieldFeeCache?: string | null;
        protocolSwapFeeCache?: string | null;
        owner?: string | null;
        totalWeight?: string | null;
        totalSwapVolume: string;
        totalSwapFee: string;
        totalLiquidity: string;
        totalShares: string;
        swapsCount: string;
        holdersCount: string;
        tokensList: Array<string>;
        amp?: string | null;
        expiryTime?: string | null;
        unitSeconds?: string | null;
        createTime: number;
        principalToken?: string | null;
        baseToken?: string | null;
        wrappedIndex?: number | null;
        mainIndex?: number | null;
        lowerTarget?: string | null;
        upperTarget?: string | null;
        sqrtAlpha?: string | null;
        sqrtBeta?: string | null;
        root3Alpha?: string | null;
        isInRecoveryMode?: boolean | null;
        isPaused?: boolean | null;
        alpha?: string | null;
        beta?: string | null;
        c?: string | null;
        s?: string | null;
        lambda?: string | null;
        tauAlphaX?: string | null;
        tauAlphaY?: string | null;
        tauBetaX?: string | null;
        tauBetaY?: string | null;
        u?: string | null;
        v?: string | null;
        w?: string | null;
        z?: string | null;
        dSq?: string | null;
        delta?: string | null;
        epsilon?: string | null;
        tokens?: Array<{
            __typename?: 'PoolToken';
            id: string;
            symbol: string;
            name: string;
            decimals: number;
            address: string;
            balance: string;
            managedBalance: string;
            weight?: string | null;
            priceRate: string;
            isExemptFromYieldProtocolFee?: boolean | null;
            token: {
                __typename?: 'Token';
                latestUSDPrice?: string | null;
                latestFXPrice?: string | null;
                pool?: {
                    __typename?: 'Pool';
                    id: string;
                    totalShares: string;
                    address: string;
                    poolType?: string | null;
                    mainIndex?: number | null;
                    tokens?: Array<{
                        __typename?: 'PoolToken';
                        address: string;
                        balance: string;
                        weight?: string | null;
                        priceRate: string;
                        symbol: string;
                        decimals: number;
                        isExemptFromYieldProtocolFee?: boolean | null;
                        token: {
                            __typename?: 'Token';
                            latestUSDPrice?: string | null;
                            pool?: {
                                __typename?: 'Pool';
                                id: string;
                                totalShares: string;
                                address: string;
                                poolType?: string | null;
                                mainIndex?: number | null;
                                tokens?: Array<{
                                    __typename?: 'PoolToken';
                                    address: string;
                                    balance: string;
                                    weight?: string | null;
                                    priceRate: string;
                                    symbol: string;
                                    decimals: number;
                                    isExemptFromYieldProtocolFee?: boolean | null;
                                    token: {
                                        __typename?: 'Token';
                                        latestUSDPrice?: string | null;
                                        pool?: {
                                            __typename?: 'Pool';
                                            id: string;
                                            totalShares: string;
                                            address: string;
                                            poolType?: string | null;
                                            mainIndex?: number | null;
                                        } | null;
                                    };
                                }> | null;
                            } | null;
                        };
                    }> | null;
                } | null;
            };
        }> | null;
        priceRateProviders?: Array<{
            __typename?: 'PriceRateProvider';
            address: string;
            token: {
                __typename?: 'PoolToken';
                address: string;
            };
        }> | null;
    }>;
    pool1000: Array<{
        __typename?: 'Pool';
        id: string;
        address: string;
        poolType?: string | null;
        poolTypeVersion?: number | null;
        factory?: string | null;
        strategyType: number;
        symbol?: string | null;
        name?: string | null;
        swapEnabled: boolean;
        swapFee: string;
        protocolYieldFeeCache?: string | null;
        protocolSwapFeeCache?: string | null;
        owner?: string | null;
        totalWeight?: string | null;
        totalSwapVolume: string;
        totalSwapFee: string;
        totalLiquidity: string;
        totalShares: string;
        swapsCount: string;
        holdersCount: string;
        tokensList: Array<string>;
        amp?: string | null;
        expiryTime?: string | null;
        unitSeconds?: string | null;
        createTime: number;
        principalToken?: string | null;
        baseToken?: string | null;
        wrappedIndex?: number | null;
        mainIndex?: number | null;
        lowerTarget?: string | null;
        upperTarget?: string | null;
        sqrtAlpha?: string | null;
        sqrtBeta?: string | null;
        root3Alpha?: string | null;
        isInRecoveryMode?: boolean | null;
        isPaused?: boolean | null;
        alpha?: string | null;
        beta?: string | null;
        c?: string | null;
        s?: string | null;
        lambda?: string | null;
        tauAlphaX?: string | null;
        tauAlphaY?: string | null;
        tauBetaX?: string | null;
        tauBetaY?: string | null;
        u?: string | null;
        v?: string | null;
        w?: string | null;
        z?: string | null;
        dSq?: string | null;
        delta?: string | null;
        epsilon?: string | null;
        tokens?: Array<{
            __typename?: 'PoolToken';
            id: string;
            symbol: string;
            name: string;
            decimals: number;
            address: string;
            balance: string;
            managedBalance: string;
            weight?: string | null;
            priceRate: string;
            isExemptFromYieldProtocolFee?: boolean | null;
            token: {
                __typename?: 'Token';
                latestUSDPrice?: string | null;
                latestFXPrice?: string | null;
                pool?: {
                    __typename?: 'Pool';
                    id: string;
                    totalShares: string;
                    address: string;
                    poolType?: string | null;
                    mainIndex?: number | null;
                    tokens?: Array<{
                        __typename?: 'PoolToken';
                        address: string;
                        balance: string;
                        weight?: string | null;
                        priceRate: string;
                        symbol: string;
                        decimals: number;
                        isExemptFromYieldProtocolFee?: boolean | null;
                        token: {
                            __typename?: 'Token';
                            latestUSDPrice?: string | null;
                            pool?: {
                                __typename?: 'Pool';
                                id: string;
                                totalShares: string;
                                address: string;
                                poolType?: string | null;
                                mainIndex?: number | null;
                                tokens?: Array<{
                                    __typename?: 'PoolToken';
                                    address: string;
                                    balance: string;
                                    weight?: string | null;
                                    priceRate: string;
                                    symbol: string;
                                    decimals: number;
                                    isExemptFromYieldProtocolFee?: boolean | null;
                                    token: {
                                        __typename?: 'Token';
                                        latestUSDPrice?: string | null;
                                        pool?: {
                                            __typename?: 'Pool';
                                            id: string;
                                            totalShares: string;
                                            address: string;
                                            poolType?: string | null;
                                            mainIndex?: number | null;
                                        } | null;
                                    };
                                }> | null;
                            } | null;
                        };
                    }> | null;
                } | null;
            };
        }> | null;
        priceRateProviders?: Array<{
            __typename?: 'PriceRateProvider';
            address: string;
            token: {
                __typename?: 'PoolToken';
                address: string;
            };
        }> | null;
    }>;
    pool2000: Array<{
        __typename?: 'Pool';
        id: string;
        address: string;
        poolType?: string | null;
        poolTypeVersion?: number | null;
        factory?: string | null;
        strategyType: number;
        symbol?: string | null;
        name?: string | null;
        swapEnabled: boolean;
        swapFee: string;
        protocolYieldFeeCache?: string | null;
        protocolSwapFeeCache?: string | null;
        owner?: string | null;
        totalWeight?: string | null;
        totalSwapVolume: string;
        totalSwapFee: string;
        totalLiquidity: string;
        totalShares: string;
        swapsCount: string;
        holdersCount: string;
        tokensList: Array<string>;
        amp?: string | null;
        expiryTime?: string | null;
        unitSeconds?: string | null;
        createTime: number;
        principalToken?: string | null;
        baseToken?: string | null;
        wrappedIndex?: number | null;
        mainIndex?: number | null;
        lowerTarget?: string | null;
        upperTarget?: string | null;
        sqrtAlpha?: string | null;
        sqrtBeta?: string | null;
        root3Alpha?: string | null;
        isInRecoveryMode?: boolean | null;
        isPaused?: boolean | null;
        alpha?: string | null;
        beta?: string | null;
        c?: string | null;
        s?: string | null;
        lambda?: string | null;
        tauAlphaX?: string | null;
        tauAlphaY?: string | null;
        tauBetaX?: string | null;
        tauBetaY?: string | null;
        u?: string | null;
        v?: string | null;
        w?: string | null;
        z?: string | null;
        dSq?: string | null;
        delta?: string | null;
        epsilon?: string | null;
        tokens?: Array<{
            __typename?: 'PoolToken';
            id: string;
            symbol: string;
            name: string;
            decimals: number;
            address: string;
            balance: string;
            managedBalance: string;
            weight?: string | null;
            priceRate: string;
            isExemptFromYieldProtocolFee?: boolean | null;
            token: {
                __typename?: 'Token';
                latestUSDPrice?: string | null;
                latestFXPrice?: string | null;
                pool?: {
                    __typename?: 'Pool';
                    id: string;
                    totalShares: string;
                    address: string;
                    poolType?: string | null;
                    mainIndex?: number | null;
                    tokens?: Array<{
                        __typename?: 'PoolToken';
                        address: string;
                        balance: string;
                        weight?: string | null;
                        priceRate: string;
                        symbol: string;
                        decimals: number;
                        isExemptFromYieldProtocolFee?: boolean | null;
                        token: {
                            __typename?: 'Token';
                            latestUSDPrice?: string | null;
                            pool?: {
                                __typename?: 'Pool';
                                id: string;
                                totalShares: string;
                                address: string;
                                poolType?: string | null;
                                mainIndex?: number | null;
                                tokens?: Array<{
                                    __typename?: 'PoolToken';
                                    address: string;
                                    balance: string;
                                    weight?: string | null;
                                    priceRate: string;
                                    symbol: string;
                                    decimals: number;
                                    isExemptFromYieldProtocolFee?: boolean | null;
                                    token: {
                                        __typename?: 'Token';
                                        latestUSDPrice?: string | null;
                                        pool?: {
                                            __typename?: 'Pool';
                                            id: string;
                                            totalShares: string;
                                            address: string;
                                            poolType?: string | null;
                                            mainIndex?: number | null;
                                        } | null;
                                    };
                                }> | null;
                            } | null;
                        };
                    }> | null;
                } | null;
            };
        }> | null;
        priceRateProviders?: Array<{
            __typename?: 'PriceRateProvider';
            address: string;
            token: {
                __typename?: 'PoolToken';
                address: string;
            };
        }> | null;
    }>;
};
type PoolQueryVariables = Exact$1<{
    id: Scalars$1['ID'];
    block?: InputMaybe$1<Block_Height$1>;
}>;
type PoolQuery = {
    __typename?: 'Query';
    pool?: {
        __typename?: 'Pool';
        id: string;
        address: string;
        poolType?: string | null;
        poolTypeVersion?: number | null;
        factory?: string | null;
        strategyType: number;
        symbol?: string | null;
        name?: string | null;
        swapEnabled: boolean;
        swapFee: string;
        protocolYieldFeeCache?: string | null;
        protocolSwapFeeCache?: string | null;
        owner?: string | null;
        totalWeight?: string | null;
        totalSwapVolume: string;
        totalSwapFee: string;
        totalLiquidity: string;
        totalShares: string;
        swapsCount: string;
        holdersCount: string;
        tokensList: Array<string>;
        amp?: string | null;
        expiryTime?: string | null;
        unitSeconds?: string | null;
        createTime: number;
        principalToken?: string | null;
        baseToken?: string | null;
        wrappedIndex?: number | null;
        mainIndex?: number | null;
        lowerTarget?: string | null;
        upperTarget?: string | null;
        sqrtAlpha?: string | null;
        sqrtBeta?: string | null;
        root3Alpha?: string | null;
        isInRecoveryMode?: boolean | null;
        isPaused?: boolean | null;
        alpha?: string | null;
        beta?: string | null;
        c?: string | null;
        s?: string | null;
        lambda?: string | null;
        tauAlphaX?: string | null;
        tauAlphaY?: string | null;
        tauBetaX?: string | null;
        tauBetaY?: string | null;
        u?: string | null;
        v?: string | null;
        w?: string | null;
        z?: string | null;
        dSq?: string | null;
        delta?: string | null;
        epsilon?: string | null;
        tokens?: Array<{
            __typename?: 'PoolToken';
            id: string;
            symbol: string;
            name: string;
            decimals: number;
            address: string;
            balance: string;
            managedBalance: string;
            weight?: string | null;
            priceRate: string;
            isExemptFromYieldProtocolFee?: boolean | null;
            token: {
                __typename?: 'Token';
                latestUSDPrice?: string | null;
                latestFXPrice?: string | null;
                pool?: {
                    __typename?: 'Pool';
                    id: string;
                    totalShares: string;
                    address: string;
                    poolType?: string | null;
                    mainIndex?: number | null;
                    tokens?: Array<{
                        __typename?: 'PoolToken';
                        address: string;
                        balance: string;
                        weight?: string | null;
                        priceRate: string;
                        symbol: string;
                        decimals: number;
                        isExemptFromYieldProtocolFee?: boolean | null;
                        token: {
                            __typename?: 'Token';
                            latestUSDPrice?: string | null;
                            pool?: {
                                __typename?: 'Pool';
                                id: string;
                                totalShares: string;
                                address: string;
                                poolType?: string | null;
                                mainIndex?: number | null;
                                tokens?: Array<{
                                    __typename?: 'PoolToken';
                                    address: string;
                                    balance: string;
                                    weight?: string | null;
                                    priceRate: string;
                                    symbol: string;
                                    decimals: number;
                                    isExemptFromYieldProtocolFee?: boolean | null;
                                    token: {
                                        __typename?: 'Token';
                                        latestUSDPrice?: string | null;
                                        pool?: {
                                            __typename?: 'Pool';
                                            id: string;
                                            totalShares: string;
                                            address: string;
                                            poolType?: string | null;
                                            mainIndex?: number | null;
                                        } | null;
                                    };
                                }> | null;
                            } | null;
                        };
                    }> | null;
                } | null;
            };
        }> | null;
        priceRateProviders?: Array<{
            __typename?: 'PriceRateProvider';
            address: string;
            token: {
                __typename?: 'PoolToken';
                address: string;
            };
        }> | null;
    } | null;
};
type PoolHistoricalLiquiditiesQueryVariables = Exact$1<{
    skip?: InputMaybe$1<Scalars$1['Int']>;
    first?: InputMaybe$1<Scalars$1['Int']>;
    orderBy?: InputMaybe$1<PoolHistoricalLiquidity_OrderBy>;
    orderDirection?: InputMaybe$1<OrderDirection$1>;
    where?: InputMaybe$1<PoolHistoricalLiquidity_Filter>;
    block?: InputMaybe$1<Block_Height$1>;
}>;
type PoolHistoricalLiquiditiesQuery = {
    __typename?: 'Query';
    poolHistoricalLiquidities: Array<{
        __typename?: 'PoolHistoricalLiquidity';
        id: string;
        poolTotalShares: string;
        poolLiquidity: string;
        poolShareValue: string;
        pricingAsset: string;
        block: string;
        poolId: {
            __typename?: 'Pool';
            id: string;
        };
    }>;
};
type PoolSnapshotsQueryVariables = Exact$1<{
    skip?: InputMaybe$1<Scalars$1['Int']>;
    first?: InputMaybe$1<Scalars$1['Int']>;
    orderBy?: InputMaybe$1<PoolSnapshot_OrderBy>;
    orderDirection?: InputMaybe$1<OrderDirection$1>;
    where?: InputMaybe$1<PoolSnapshot_Filter>;
    block?: InputMaybe$1<Block_Height$1>;
}>;
type PoolSnapshotsQuery = {
    __typename?: 'Query';
    poolSnapshots: Array<{
        __typename?: 'PoolSnapshot';
        id: string;
        totalShares: string;
        swapVolume: string;
        swapFees: string;
        timestamp: number;
        pool: {
            __typename?: 'Pool';
            id: string;
        };
    }>;
};
type JoinExitsQueryVariables = Exact$1<{
    skip?: InputMaybe$1<Scalars$1['Int']>;
    first?: InputMaybe$1<Scalars$1['Int']>;
    orderBy?: InputMaybe$1<JoinExit_OrderBy>;
    orderDirection?: InputMaybe$1<OrderDirection$1>;
    where?: InputMaybe$1<JoinExit_Filter>;
    block?: InputMaybe$1<Block_Height$1>;
}>;
type JoinExitsQuery = {
    __typename?: 'Query';
    joinExits: Array<{
        __typename?: 'JoinExit';
        amounts: Array<string>;
        id: string;
        sender: string;
        timestamp: number;
        tx: string;
        type: InvestType;
        user: {
            __typename?: 'User';
            id: string;
        };
        pool: {
            __typename?: 'Pool';
            id: string;
            tokensList: Array<string>;
        };
    }>;
};
type SubgraphJoinExitFragment = {
    __typename?: 'JoinExit';
    amounts: Array<string>;
    id: string;
    sender: string;
    timestamp: number;
    tx: string;
    type: InvestType;
    user: {
        __typename?: 'User';
        id: string;
    };
    pool: {
        __typename?: 'Pool';
        id: string;
        tokensList: Array<string>;
    };
};
type BalancersQueryVariables = Exact$1<{
    skip?: InputMaybe$1<Scalars$1['Int']>;
    first?: InputMaybe$1<Scalars$1['Int']>;
    orderBy?: InputMaybe$1<Balancer_OrderBy>;
    orderDirection?: InputMaybe$1<OrderDirection$1>;
    where?: InputMaybe$1<Balancer_Filter>;
    block?: InputMaybe$1<Block_Height$1>;
}>;
type BalancersQuery = {
    __typename?: 'Query';
    balancers: Array<{
        __typename?: 'Balancer';
        id: string;
        totalLiquidity: string;
        totalSwapVolume: string;
        totalSwapFee: string;
        totalSwapCount: string;
        poolCount: number;
    }>;
};
type TokenPricesQueryVariables = Exact$1<{
    skip?: InputMaybe$1<Scalars$1['Int']>;
    first?: InputMaybe$1<Scalars$1['Int']>;
    orderBy?: InputMaybe$1<TokenPrice_OrderBy>;
    orderDirection?: InputMaybe$1<OrderDirection$1>;
    where?: InputMaybe$1<TokenPrice_Filter>;
    block?: InputMaybe$1<Block_Height$1>;
}>;
type TokenPricesQuery = {
    __typename?: 'Query';
    tokenPrices: Array<{
        __typename?: 'TokenPrice';
        id: string;
        asset: string;
        amount: string;
        pricingAsset: string;
        price: string;
        block: string;
        timestamp: number;
        poolId: {
            __typename?: 'Pool';
            id: string;
        };
    }>;
};
type TokenLatestPricesQueryVariables = Exact$1<{
    skip?: InputMaybe$1<Scalars$1['Int']>;
    first?: InputMaybe$1<Scalars$1['Int']>;
    orderBy?: InputMaybe$1<LatestPrice_OrderBy>;
    orderDirection?: InputMaybe$1<OrderDirection$1>;
    where?: InputMaybe$1<LatestPrice_Filter>;
    block?: InputMaybe$1<Block_Height$1>;
}>;
type TokenLatestPricesQuery = {
    __typename?: 'Query';
    latestPrices: Array<{
        __typename?: 'LatestPrice';
        id: string;
        asset: string;
        price: string;
        pricingAsset: string;
        poolId: {
            __typename?: 'Pool';
            id: string;
        };
    }>;
};
type TokenLatestPriceQueryVariables = Exact$1<{
    id: Scalars$1['ID'];
}>;
type TokenLatestPriceQuery = {
    __typename?: 'Query';
    latestPrice?: {
        __typename?: 'LatestPrice';
        id: string;
        asset: string;
        price: string;
        pricingAsset: string;
        poolId: {
            __typename?: 'Pool';
            id: string;
        };
    } | null;
};
type UserQueryVariables = Exact$1<{
    id: Scalars$1['ID'];
    block?: InputMaybe$1<Block_Height$1>;
}>;
type UserQuery = {
    __typename?: 'Query';
    user?: {
        __typename?: 'User';
        id: string;
        sharesOwned?: Array<{
            __typename?: 'PoolShare';
            balance: string;
            poolId: {
                __typename?: 'Pool';
                id: string;
            };
        }> | null;
    } | null;
};
type UsersQueryVariables = Exact$1<{
    skip?: InputMaybe$1<Scalars$1['Int']>;
    first?: InputMaybe$1<Scalars$1['Int']>;
    orderBy?: InputMaybe$1<User_OrderBy>;
    orderDirection?: InputMaybe$1<OrderDirection$1>;
    where?: InputMaybe$1<User_Filter$1>;
    block?: InputMaybe$1<Block_Height$1>;
}>;
type UsersQuery = {
    __typename?: 'Query';
    users: Array<{
        __typename?: 'User';
        id: string;
        sharesOwned?: Array<{
            __typename?: 'PoolShare';
            balance: string;
            poolId: {
                __typename?: 'Pool';
                id: string;
            };
        }> | null;
    }>;
};
type SdkFunctionWrapper$1 = <T>(action: (requestHeaders?: Record<string, string>) => Promise<T>, operationName: string, operationType?: string) => Promise<T>;
declare function getSdk$1(client: GraphQLClient, withWrapper?: SdkFunctionWrapper$1): {
    PoolShare(variables: PoolShareQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<PoolShareQuery>;
    PoolShares(variables?: PoolSharesQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<PoolSharesQuery>;
    Pools(variables?: PoolsQueryVariables$1, requestHeaders?: Dom.RequestInit["headers"]): Promise<PoolsQuery$1>;
    AllPools(variables?: AllPoolsQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<AllPoolsQuery>;
    Pool(variables: PoolQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<PoolQuery>;
    PoolHistoricalLiquidities(variables?: PoolHistoricalLiquiditiesQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<PoolHistoricalLiquiditiesQuery>;
    PoolSnapshots(variables?: PoolSnapshotsQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<PoolSnapshotsQuery>;
    JoinExits(variables?: JoinExitsQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<JoinExitsQuery>;
    Balancers(variables?: BalancersQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<BalancersQuery>;
    TokenPrices(variables?: TokenPricesQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<TokenPricesQuery>;
    TokenLatestPrices(variables?: TokenLatestPricesQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<TokenLatestPricesQuery>;
    TokenLatestPrice(variables: TokenLatestPriceQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<TokenLatestPriceQuery>;
    User(variables: UserQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<UserQuery>;
    Users(variables?: UsersQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<UsersQuery>;
};
type Sdk$1 = ReturnType<typeof getSdk$1>;

type Maybe<T> = T | null;
type InputMaybe<T> = Maybe<T>;
type Exact<T extends {
    [key: string]: unknown;
}> = {
    [K in keyof T]: T[K];
};
/** All built-in and custom scalars, mapped to their actual values */
type Scalars = {
    ID: string;
    String: string;
    Boolean: boolean;
    Int: number;
    Float: number;
    BigDecimal: string;
    BigInt: string;
    Bytes: string;
    Int8: any;
};
type BlockChangedFilter = {
    number_gte: Scalars['Int'];
};
type Block_Height = {
    hash?: InputMaybe<Scalars['Bytes']>;
    number?: InputMaybe<Scalars['Int']>;
    number_gte?: InputMaybe<Scalars['Int']>;
};
declare enum Chain {
    Arbitrum = "Arbitrum",
    Avalanche = "Avalanche",
    Base = "Base",
    Gnosis = "Gnosis",
    Optimism = "Optimism",
    Polygon = "Polygon",
    PolygonZkEvm = "PolygonZkEvm"
}
type Gauge = {
    __typename?: 'Gauge';
    /**  Timestamp at which Balancer DAO added the gauge to GaugeController [seconds]  */
    addedTimestamp: Scalars['Int'];
    /**  Address of the gauge  */
    address: Scalars['Bytes'];
    /**  Equal to: <gaugeAddress>-<typeID>  */
    id: Scalars['ID'];
    /**  Reference to LiquidityGauge  */
    liquidityGauge?: Maybe<LiquidityGauge$1>;
    /**  Reference to RootGauge  */
    rootGauge?: Maybe<RootGauge>;
    /**  Type of the gauge  */
    type: GaugeType;
};
type GaugeFactory = {
    __typename?: 'GaugeFactory';
    /**  List of gauges created through the factory  */
    gauges?: Maybe<Array<LiquidityGauge$1>>;
    /**  Factory contract address  */
    id: Scalars['ID'];
    /**  Number of gauges created through the factory  */
    numGauges: Scalars['Int'];
};
type GaugeFactory_Filter = {
    /** Filter for the block changed event. */
    _change_block?: InputMaybe<BlockChangedFilter>;
    and?: InputMaybe<Array<InputMaybe<GaugeFactory_Filter>>>;
    gauges_?: InputMaybe<LiquidityGauge_Filter>;
    id?: InputMaybe<Scalars['ID']>;
    id_gt?: InputMaybe<Scalars['ID']>;
    id_gte?: InputMaybe<Scalars['ID']>;
    id_in?: InputMaybe<Array<Scalars['ID']>>;
    id_lt?: InputMaybe<Scalars['ID']>;
    id_lte?: InputMaybe<Scalars['ID']>;
    id_not?: InputMaybe<Scalars['ID']>;
    id_not_in?: InputMaybe<Array<Scalars['ID']>>;
    numGauges?: InputMaybe<Scalars['Int']>;
    numGauges_gt?: InputMaybe<Scalars['Int']>;
    numGauges_gte?: InputMaybe<Scalars['Int']>;
    numGauges_in?: InputMaybe<Array<Scalars['Int']>>;
    numGauges_lt?: InputMaybe<Scalars['Int']>;
    numGauges_lte?: InputMaybe<Scalars['Int']>;
    numGauges_not?: InputMaybe<Scalars['Int']>;
    numGauges_not_in?: InputMaybe<Array<Scalars['Int']>>;
    or?: InputMaybe<Array<InputMaybe<GaugeFactory_Filter>>>;
};
type GaugeShare$1 = {
    __typename?: 'GaugeShare';
    /**  User's balance of gauge deposit tokens  */
    balance: Scalars['BigDecimal'];
    /**  Reference to LiquidityGauge entity  */
    gauge: LiquidityGauge$1;
    /**  Equal to: <userAddress>-<gaugeAddress>  */
    id: Scalars['ID'];
    /**  Reference to User entity  */
    user: User;
};
type GaugeShare_Filter = {
    /** Filter for the block changed event. */
    _change_block?: InputMaybe<BlockChangedFilter>;
    and?: InputMaybe<Array<InputMaybe<GaugeShare_Filter>>>;
    balance?: InputMaybe<Scalars['BigDecimal']>;
    balance_gt?: InputMaybe<Scalars['BigDecimal']>;
    balance_gte?: InputMaybe<Scalars['BigDecimal']>;
    balance_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
    balance_lt?: InputMaybe<Scalars['BigDecimal']>;
    balance_lte?: InputMaybe<Scalars['BigDecimal']>;
    balance_not?: InputMaybe<Scalars['BigDecimal']>;
    balance_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
    gauge?: InputMaybe<Scalars['String']>;
    gauge_?: InputMaybe<LiquidityGauge_Filter>;
    gauge_contains?: InputMaybe<Scalars['String']>;
    gauge_contains_nocase?: InputMaybe<Scalars['String']>;
    gauge_ends_with?: InputMaybe<Scalars['String']>;
    gauge_ends_with_nocase?: InputMaybe<Scalars['String']>;
    gauge_gt?: InputMaybe<Scalars['String']>;
    gauge_gte?: InputMaybe<Scalars['String']>;
    gauge_in?: InputMaybe<Array<Scalars['String']>>;
    gauge_lt?: InputMaybe<Scalars['String']>;
    gauge_lte?: InputMaybe<Scalars['String']>;
    gauge_not?: InputMaybe<Scalars['String']>;
    gauge_not_contains?: InputMaybe<Scalars['String']>;
    gauge_not_contains_nocase?: InputMaybe<Scalars['String']>;
    gauge_not_ends_with?: InputMaybe<Scalars['String']>;
    gauge_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
    gauge_not_in?: InputMaybe<Array<Scalars['String']>>;
    gauge_not_starts_with?: InputMaybe<Scalars['String']>;
    gauge_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
    gauge_starts_with?: InputMaybe<Scalars['String']>;
    gauge_starts_with_nocase?: InputMaybe<Scalars['String']>;
    id?: InputMaybe<Scalars['ID']>;
    id_gt?: InputMaybe<Scalars['ID']>;
    id_gte?: InputMaybe<Scalars['ID']>;
    id_in?: InputMaybe<Array<Scalars['ID']>>;
    id_lt?: InputMaybe<Scalars['ID']>;
    id_lte?: InputMaybe<Scalars['ID']>;
    id_not?: InputMaybe<Scalars['ID']>;
    id_not_in?: InputMaybe<Array<Scalars['ID']>>;
    or?: InputMaybe<Array<InputMaybe<GaugeShare_Filter>>>;
    user?: InputMaybe<Scalars['String']>;
    user_?: InputMaybe<User_Filter>;
    user_contains?: InputMaybe<Scalars['String']>;
    user_contains_nocase?: InputMaybe<Scalars['String']>;
    user_ends_with?: InputMaybe<Scalars['String']>;
    user_ends_with_nocase?: InputMaybe<Scalars['String']>;
    user_gt?: InputMaybe<Scalars['String']>;
    user_gte?: InputMaybe<Scalars['String']>;
    user_in?: InputMaybe<Array<Scalars['String']>>;
    user_lt?: InputMaybe<Scalars['String']>;
    user_lte?: InputMaybe<Scalars['String']>;
    user_not?: InputMaybe<Scalars['String']>;
    user_not_contains?: InputMaybe<Scalars['String']>;
    user_not_contains_nocase?: InputMaybe<Scalars['String']>;
    user_not_ends_with?: InputMaybe<Scalars['String']>;
    user_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
    user_not_in?: InputMaybe<Array<Scalars['String']>>;
    user_not_starts_with?: InputMaybe<Scalars['String']>;
    user_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
    user_starts_with?: InputMaybe<Scalars['String']>;
    user_starts_with_nocase?: InputMaybe<Scalars['String']>;
};
declare enum GaugeShare_OrderBy {
    balance = "balance",
    gauge = "gauge",
    gauge__id = "gauge__id",
    gauge__isKilled = "gauge__isKilled",
    gauge__isPreferentialGauge = "gauge__isPreferentialGauge",
    gauge__poolAddress = "gauge__poolAddress",
    gauge__poolId = "gauge__poolId",
    gauge__relativeWeightCap = "gauge__relativeWeightCap",
    gauge__streamer = "gauge__streamer",
    gauge__symbol = "gauge__symbol",
    gauge__totalSupply = "gauge__totalSupply",
    id = "id",
    user = "user",
    user__id = "user__id"
}
type GaugeType = {
    __typename?: 'GaugeType';
    /**  Type ID  */
    id: Scalars['ID'];
    /**  Name of the type - empty string if call reverts  */
    name: Scalars['String'];
};
type GaugeType_Filter = {
    /** Filter for the block changed event. */
    _change_block?: InputMaybe<BlockChangedFilter>;
    and?: InputMaybe<Array<InputMaybe<GaugeType_Filter>>>;
    id?: InputMaybe<Scalars['ID']>;
    id_gt?: InputMaybe<Scalars['ID']>;
    id_gte?: InputMaybe<Scalars['ID']>;
    id_in?: InputMaybe<Array<Scalars['ID']>>;
    id_lt?: InputMaybe<Scalars['ID']>;
    id_lte?: InputMaybe<Scalars['ID']>;
    id_not?: InputMaybe<Scalars['ID']>;
    id_not_in?: InputMaybe<Array<Scalars['ID']>>;
    name?: InputMaybe<Scalars['String']>;
    name_contains?: InputMaybe<Scalars['String']>;
    name_contains_nocase?: InputMaybe<Scalars['String']>;
    name_ends_with?: InputMaybe<Scalars['String']>;
    name_ends_with_nocase?: InputMaybe<Scalars['String']>;
    name_gt?: InputMaybe<Scalars['String']>;
    name_gte?: InputMaybe<Scalars['String']>;
    name_in?: InputMaybe<Array<Scalars['String']>>;
    name_lt?: InputMaybe<Scalars['String']>;
    name_lte?: InputMaybe<Scalars['String']>;
    name_not?: InputMaybe<Scalars['String']>;
    name_not_contains?: InputMaybe<Scalars['String']>;
    name_not_contains_nocase?: InputMaybe<Scalars['String']>;
    name_not_ends_with?: InputMaybe<Scalars['String']>;
    name_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
    name_not_in?: InputMaybe<Array<Scalars['String']>>;
    name_not_starts_with?: InputMaybe<Scalars['String']>;
    name_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
    name_starts_with?: InputMaybe<Scalars['String']>;
    name_starts_with_nocase?: InputMaybe<Scalars['String']>;
    or?: InputMaybe<Array<InputMaybe<GaugeType_Filter>>>;
};
type GaugeVote = {
    __typename?: 'GaugeVote';
    /**  Reference to Gauge entity  */
    gauge: Gauge;
    /**  Equal to: <userAddress>-<gaugeAddress>  */
    id: Scalars['ID'];
    /**  Timestamp at which user voted [seconds]  */
    timestamp?: Maybe<Scalars['BigInt']>;
    /**  Reference to User entity  */
    user: User;
    /**  Weight of veBAL power user has used to vote  */
    weight?: Maybe<Scalars['BigDecimal']>;
};
type GaugeVote_Filter = {
    /** Filter for the block changed event. */
    _change_block?: InputMaybe<BlockChangedFilter>;
    and?: InputMaybe<Array<InputMaybe<GaugeVote_Filter>>>;
    gauge?: InputMaybe<Scalars['String']>;
    gauge_?: InputMaybe<Gauge_Filter>;
    gauge_contains?: InputMaybe<Scalars['String']>;
    gauge_contains_nocase?: InputMaybe<Scalars['String']>;
    gauge_ends_with?: InputMaybe<Scalars['String']>;
    gauge_ends_with_nocase?: InputMaybe<Scalars['String']>;
    gauge_gt?: InputMaybe<Scalars['String']>;
    gauge_gte?: InputMaybe<Scalars['String']>;
    gauge_in?: InputMaybe<Array<Scalars['String']>>;
    gauge_lt?: InputMaybe<Scalars['String']>;
    gauge_lte?: InputMaybe<Scalars['String']>;
    gauge_not?: InputMaybe<Scalars['String']>;
    gauge_not_contains?: InputMaybe<Scalars['String']>;
    gauge_not_contains_nocase?: InputMaybe<Scalars['String']>;
    gauge_not_ends_with?: InputMaybe<Scalars['String']>;
    gauge_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
    gauge_not_in?: InputMaybe<Array<Scalars['String']>>;
    gauge_not_starts_with?: InputMaybe<Scalars['String']>;
    gauge_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
    gauge_starts_with?: InputMaybe<Scalars['String']>;
    gauge_starts_with_nocase?: InputMaybe<Scalars['String']>;
    id?: InputMaybe<Scalars['ID']>;
    id_gt?: InputMaybe<Scalars['ID']>;
    id_gte?: InputMaybe<Scalars['ID']>;
    id_in?: InputMaybe<Array<Scalars['ID']>>;
    id_lt?: InputMaybe<Scalars['ID']>;
    id_lte?: InputMaybe<Scalars['ID']>;
    id_not?: InputMaybe<Scalars['ID']>;
    id_not_in?: InputMaybe<Array<Scalars['ID']>>;
    or?: InputMaybe<Array<InputMaybe<GaugeVote_Filter>>>;
    timestamp?: InputMaybe<Scalars['BigInt']>;
    timestamp_gt?: InputMaybe<Scalars['BigInt']>;
    timestamp_gte?: InputMaybe<Scalars['BigInt']>;
    timestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
    timestamp_lt?: InputMaybe<Scalars['BigInt']>;
    timestamp_lte?: InputMaybe<Scalars['BigInt']>;
    timestamp_not?: InputMaybe<Scalars['BigInt']>;
    timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
    user?: InputMaybe<Scalars['String']>;
    user_?: InputMaybe<User_Filter>;
    user_contains?: InputMaybe<Scalars['String']>;
    user_contains_nocase?: InputMaybe<Scalars['String']>;
    user_ends_with?: InputMaybe<Scalars['String']>;
    user_ends_with_nocase?: InputMaybe<Scalars['String']>;
    user_gt?: InputMaybe<Scalars['String']>;
    user_gte?: InputMaybe<Scalars['String']>;
    user_in?: InputMaybe<Array<Scalars['String']>>;
    user_lt?: InputMaybe<Scalars['String']>;
    user_lte?: InputMaybe<Scalars['String']>;
    user_not?: InputMaybe<Scalars['String']>;
    user_not_contains?: InputMaybe<Scalars['String']>;
    user_not_contains_nocase?: InputMaybe<Scalars['String']>;
    user_not_ends_with?: InputMaybe<Scalars['String']>;
    user_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
    user_not_in?: InputMaybe<Array<Scalars['String']>>;
    user_not_starts_with?: InputMaybe<Scalars['String']>;
    user_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
    user_starts_with?: InputMaybe<Scalars['String']>;
    user_starts_with_nocase?: InputMaybe<Scalars['String']>;
    weight?: InputMaybe<Scalars['BigDecimal']>;
    weight_gt?: InputMaybe<Scalars['BigDecimal']>;
    weight_gte?: InputMaybe<Scalars['BigDecimal']>;
    weight_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
    weight_lt?: InputMaybe<Scalars['BigDecimal']>;
    weight_lte?: InputMaybe<Scalars['BigDecimal']>;
    weight_not?: InputMaybe<Scalars['BigDecimal']>;
    weight_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
};
type Gauge_Filter = {
    /** Filter for the block changed event. */
    _change_block?: InputMaybe<BlockChangedFilter>;
    addedTimestamp?: InputMaybe<Scalars['Int']>;
    addedTimestamp_gt?: InputMaybe<Scalars['Int']>;
    addedTimestamp_gte?: InputMaybe<Scalars['Int']>;
    addedTimestamp_in?: InputMaybe<Array<Scalars['Int']>>;
    addedTimestamp_lt?: InputMaybe<Scalars['Int']>;
    addedTimestamp_lte?: InputMaybe<Scalars['Int']>;
    addedTimestamp_not?: InputMaybe<Scalars['Int']>;
    addedTimestamp_not_in?: InputMaybe<Array<Scalars['Int']>>;
    address?: InputMaybe<Scalars['Bytes']>;
    address_contains?: InputMaybe<Scalars['Bytes']>;
    address_gt?: InputMaybe<Scalars['Bytes']>;
    address_gte?: InputMaybe<Scalars['Bytes']>;
    address_in?: InputMaybe<Array<Scalars['Bytes']>>;
    address_lt?: InputMaybe<Scalars['Bytes']>;
    address_lte?: InputMaybe<Scalars['Bytes']>;
    address_not?: InputMaybe<Scalars['Bytes']>;
    address_not_contains?: InputMaybe<Scalars['Bytes']>;
    address_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
    and?: InputMaybe<Array<InputMaybe<Gauge_Filter>>>;
    id?: InputMaybe<Scalars['ID']>;
    id_gt?: InputMaybe<Scalars['ID']>;
    id_gte?: InputMaybe<Scalars['ID']>;
    id_in?: InputMaybe<Array<Scalars['ID']>>;
    id_lt?: InputMaybe<Scalars['ID']>;
    id_lte?: InputMaybe<Scalars['ID']>;
    id_not?: InputMaybe<Scalars['ID']>;
    id_not_in?: InputMaybe<Array<Scalars['ID']>>;
    liquidityGauge?: InputMaybe<Scalars['String']>;
    liquidityGauge_?: InputMaybe<LiquidityGauge_Filter>;
    liquidityGauge_contains?: InputMaybe<Scalars['String']>;
    liquidityGauge_contains_nocase?: InputMaybe<Scalars['String']>;
    liquidityGauge_ends_with?: InputMaybe<Scalars['String']>;
    liquidityGauge_ends_with_nocase?: InputMaybe<Scalars['String']>;
    liquidityGauge_gt?: InputMaybe<Scalars['String']>;
    liquidityGauge_gte?: InputMaybe<Scalars['String']>;
    liquidityGauge_in?: InputMaybe<Array<Scalars['String']>>;
    liquidityGauge_lt?: InputMaybe<Scalars['String']>;
    liquidityGauge_lte?: InputMaybe<Scalars['String']>;
    liquidityGauge_not?: InputMaybe<Scalars['String']>;
    liquidityGauge_not_contains?: InputMaybe<Scalars['String']>;
    liquidityGauge_not_contains_nocase?: InputMaybe<Scalars['String']>;
    liquidityGauge_not_ends_with?: InputMaybe<Scalars['String']>;
    liquidityGauge_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
    liquidityGauge_not_in?: InputMaybe<Array<Scalars['String']>>;
    liquidityGauge_not_starts_with?: InputMaybe<Scalars['String']>;
    liquidityGauge_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
    liquidityGauge_starts_with?: InputMaybe<Scalars['String']>;
    liquidityGauge_starts_with_nocase?: InputMaybe<Scalars['String']>;
    or?: InputMaybe<Array<InputMaybe<Gauge_Filter>>>;
    rootGauge?: InputMaybe<Scalars['String']>;
    rootGauge_?: InputMaybe<RootGauge_Filter>;
    rootGauge_contains?: InputMaybe<Scalars['String']>;
    rootGauge_contains_nocase?: InputMaybe<Scalars['String']>;
    rootGauge_ends_with?: InputMaybe<Scalars['String']>;
    rootGauge_ends_with_nocase?: InputMaybe<Scalars['String']>;
    rootGauge_gt?: InputMaybe<Scalars['String']>;
    rootGauge_gte?: InputMaybe<Scalars['String']>;
    rootGauge_in?: InputMaybe<Array<Scalars['String']>>;
    rootGauge_lt?: InputMaybe<Scalars['String']>;
    rootGauge_lte?: InputMaybe<Scalars['String']>;
    rootGauge_not?: InputMaybe<Scalars['String']>;
    rootGauge_not_contains?: InputMaybe<Scalars['String']>;
    rootGauge_not_contains_nocase?: InputMaybe<Scalars['String']>;
    rootGauge_not_ends_with?: InputMaybe<Scalars['String']>;
    rootGauge_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
    rootGauge_not_in?: InputMaybe<Array<Scalars['String']>>;
    rootGauge_not_starts_with?: InputMaybe<Scalars['String']>;
    rootGauge_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
    rootGauge_starts_with?: InputMaybe<Scalars['String']>;
    rootGauge_starts_with_nocase?: InputMaybe<Scalars['String']>;
    type?: InputMaybe<Scalars['String']>;
    type_?: InputMaybe<GaugeType_Filter>;
    type_contains?: InputMaybe<Scalars['String']>;
    type_contains_nocase?: InputMaybe<Scalars['String']>;
    type_ends_with?: InputMaybe<Scalars['String']>;
    type_ends_with_nocase?: InputMaybe<Scalars['String']>;
    type_gt?: InputMaybe<Scalars['String']>;
    type_gte?: InputMaybe<Scalars['String']>;
    type_in?: InputMaybe<Array<Scalars['String']>>;
    type_lt?: InputMaybe<Scalars['String']>;
    type_lte?: InputMaybe<Scalars['String']>;
    type_not?: InputMaybe<Scalars['String']>;
    type_not_contains?: InputMaybe<Scalars['String']>;
    type_not_contains_nocase?: InputMaybe<Scalars['String']>;
    type_not_ends_with?: InputMaybe<Scalars['String']>;
    type_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
    type_not_in?: InputMaybe<Array<Scalars['String']>>;
    type_not_starts_with?: InputMaybe<Scalars['String']>;
    type_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
    type_starts_with?: InputMaybe<Scalars['String']>;
    type_starts_with_nocase?: InputMaybe<Scalars['String']>;
};
type LiquidityGauge$1 = {
    __typename?: 'LiquidityGauge';
    /**  Factory contract address  */
    factory: GaugeFactory;
    /**  Reference to Gauge entity - created when LiquidityGauge is added to GaugeController */
    gauge?: Maybe<Gauge>;
    /**  LiquidityGauge contract address  */
    id: Scalars['ID'];
    /**  Whether Balancer DAO killed the gauge  */
    isKilled: Scalars['Boolean'];
    /**  Whether the LiquidityGauge is the most recent added to GaugeController  */
    isPreferentialGauge: Scalars['Boolean'];
    /**  Reference to Pool entity  */
    pool?: Maybe<Pool$2>;
    /**  Address of the pool (lp_token of the gauge)  */
    poolAddress: Scalars['Bytes'];
    /**  Pool ID if lp_token is a Balancer pool; null otherwise  */
    poolId?: Maybe<Scalars['Bytes']>;
    /**  Relative weight cap of the gauge (0.01 = 1%) - V2 factories only  */
    relativeWeightCap?: Maybe<Scalars['BigDecimal']>;
    /**  List of reward tokens depositted in the gauge - ChildChainLiquidityGauge only  */
    rewardTokensList?: Maybe<Array<Scalars['Bytes']>>;
    /**  List of user shares  */
    shares?: Maybe<Array<GaugeShare$1>>;
    /**  Address of the contract that streams reward tokens to the gauge - ChildChainLiquidityGauge only  */
    streamer?: Maybe<Scalars['Bytes']>;
    /**  ERC20 token symbol  */
    symbol: Scalars['String'];
    /**  List of reward tokens depositted in the gauge  */
    tokens?: Maybe<Array<RewardToken>>;
    /**  Total of BPTs users have staked in the LiquidityGauge  */
    totalSupply: Scalars['BigDecimal'];
};
type LiquidityGauge_Filter = {
    /** Filter for the block changed event. */
    _change_block?: InputMaybe<BlockChangedFilter>;
    and?: InputMaybe<Array<InputMaybe<LiquidityGauge_Filter>>>;
    factory?: InputMaybe<Scalars['String']>;
    factory_?: InputMaybe<GaugeFactory_Filter>;
    factory_contains?: InputMaybe<Scalars['String']>;
    factory_contains_nocase?: InputMaybe<Scalars['String']>;
    factory_ends_with?: InputMaybe<Scalars['String']>;
    factory_ends_with_nocase?: InputMaybe<Scalars['String']>;
    factory_gt?: InputMaybe<Scalars['String']>;
    factory_gte?: InputMaybe<Scalars['String']>;
    factory_in?: InputMaybe<Array<Scalars['String']>>;
    factory_lt?: InputMaybe<Scalars['String']>;
    factory_lte?: InputMaybe<Scalars['String']>;
    factory_not?: InputMaybe<Scalars['String']>;
    factory_not_contains?: InputMaybe<Scalars['String']>;
    factory_not_contains_nocase?: InputMaybe<Scalars['String']>;
    factory_not_ends_with?: InputMaybe<Scalars['String']>;
    factory_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
    factory_not_in?: InputMaybe<Array<Scalars['String']>>;
    factory_not_starts_with?: InputMaybe<Scalars['String']>;
    factory_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
    factory_starts_with?: InputMaybe<Scalars['String']>;
    factory_starts_with_nocase?: InputMaybe<Scalars['String']>;
    gauge?: InputMaybe<Scalars['String']>;
    gauge_?: InputMaybe<Gauge_Filter>;
    gauge_contains?: InputMaybe<Scalars['String']>;
    gauge_contains_nocase?: InputMaybe<Scalars['String']>;
    gauge_ends_with?: InputMaybe<Scalars['String']>;
    gauge_ends_with_nocase?: InputMaybe<Scalars['String']>;
    gauge_gt?: InputMaybe<Scalars['String']>;
    gauge_gte?: InputMaybe<Scalars['String']>;
    gauge_in?: InputMaybe<Array<Scalars['String']>>;
    gauge_lt?: InputMaybe<Scalars['String']>;
    gauge_lte?: InputMaybe<Scalars['String']>;
    gauge_not?: InputMaybe<Scalars['String']>;
    gauge_not_contains?: InputMaybe<Scalars['String']>;
    gauge_not_contains_nocase?: InputMaybe<Scalars['String']>;
    gauge_not_ends_with?: InputMaybe<Scalars['String']>;
    gauge_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
    gauge_not_in?: InputMaybe<Array<Scalars['String']>>;
    gauge_not_starts_with?: InputMaybe<Scalars['String']>;
    gauge_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
    gauge_starts_with?: InputMaybe<Scalars['String']>;
    gauge_starts_with_nocase?: InputMaybe<Scalars['String']>;
    id?: InputMaybe<Scalars['ID']>;
    id_gt?: InputMaybe<Scalars['ID']>;
    id_gte?: InputMaybe<Scalars['ID']>;
    id_in?: InputMaybe<Array<Scalars['ID']>>;
    id_lt?: InputMaybe<Scalars['ID']>;
    id_lte?: InputMaybe<Scalars['ID']>;
    id_not?: InputMaybe<Scalars['ID']>;
    id_not_in?: InputMaybe<Array<Scalars['ID']>>;
    isKilled?: InputMaybe<Scalars['Boolean']>;
    isKilled_in?: InputMaybe<Array<Scalars['Boolean']>>;
    isKilled_not?: InputMaybe<Scalars['Boolean']>;
    isKilled_not_in?: InputMaybe<Array<Scalars['Boolean']>>;
    isPreferentialGauge?: InputMaybe<Scalars['Boolean']>;
    isPreferentialGauge_in?: InputMaybe<Array<Scalars['Boolean']>>;
    isPreferentialGauge_not?: InputMaybe<Scalars['Boolean']>;
    isPreferentialGauge_not_in?: InputMaybe<Array<Scalars['Boolean']>>;
    or?: InputMaybe<Array<InputMaybe<LiquidityGauge_Filter>>>;
    pool?: InputMaybe<Scalars['String']>;
    poolAddress?: InputMaybe<Scalars['Bytes']>;
    poolAddress_contains?: InputMaybe<Scalars['Bytes']>;
    poolAddress_gt?: InputMaybe<Scalars['Bytes']>;
    poolAddress_gte?: InputMaybe<Scalars['Bytes']>;
    poolAddress_in?: InputMaybe<Array<Scalars['Bytes']>>;
    poolAddress_lt?: InputMaybe<Scalars['Bytes']>;
    poolAddress_lte?: InputMaybe<Scalars['Bytes']>;
    poolAddress_not?: InputMaybe<Scalars['Bytes']>;
    poolAddress_not_contains?: InputMaybe<Scalars['Bytes']>;
    poolAddress_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
    poolId?: InputMaybe<Scalars['Bytes']>;
    poolId_contains?: InputMaybe<Scalars['Bytes']>;
    poolId_gt?: InputMaybe<Scalars['Bytes']>;
    poolId_gte?: InputMaybe<Scalars['Bytes']>;
    poolId_in?: InputMaybe<Array<Scalars['Bytes']>>;
    poolId_lt?: InputMaybe<Scalars['Bytes']>;
    poolId_lte?: InputMaybe<Scalars['Bytes']>;
    poolId_not?: InputMaybe<Scalars['Bytes']>;
    poolId_not_contains?: InputMaybe<Scalars['Bytes']>;
    poolId_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
    pool_?: InputMaybe<Pool_Filter>;
    pool_contains?: InputMaybe<Scalars['String']>;
    pool_contains_nocase?: InputMaybe<Scalars['String']>;
    pool_ends_with?: InputMaybe<Scalars['String']>;
    pool_ends_with_nocase?: InputMaybe<Scalars['String']>;
    pool_gt?: InputMaybe<Scalars['String']>;
    pool_gte?: InputMaybe<Scalars['String']>;
    pool_in?: InputMaybe<Array<Scalars['String']>>;
    pool_lt?: InputMaybe<Scalars['String']>;
    pool_lte?: InputMaybe<Scalars['String']>;
    pool_not?: InputMaybe<Scalars['String']>;
    pool_not_contains?: InputMaybe<Scalars['String']>;
    pool_not_contains_nocase?: InputMaybe<Scalars['String']>;
    pool_not_ends_with?: InputMaybe<Scalars['String']>;
    pool_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
    pool_not_in?: InputMaybe<Array<Scalars['String']>>;
    pool_not_starts_with?: InputMaybe<Scalars['String']>;
    pool_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
    pool_starts_with?: InputMaybe<Scalars['String']>;
    pool_starts_with_nocase?: InputMaybe<Scalars['String']>;
    relativeWeightCap?: InputMaybe<Scalars['BigDecimal']>;
    relativeWeightCap_gt?: InputMaybe<Scalars['BigDecimal']>;
    relativeWeightCap_gte?: InputMaybe<Scalars['BigDecimal']>;
    relativeWeightCap_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
    relativeWeightCap_lt?: InputMaybe<Scalars['BigDecimal']>;
    relativeWeightCap_lte?: InputMaybe<Scalars['BigDecimal']>;
    relativeWeightCap_not?: InputMaybe<Scalars['BigDecimal']>;
    relativeWeightCap_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
    rewardTokensList?: InputMaybe<Array<Scalars['Bytes']>>;
    rewardTokensList_contains?: InputMaybe<Array<Scalars['Bytes']>>;
    rewardTokensList_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
    rewardTokensList_not?: InputMaybe<Array<Scalars['Bytes']>>;
    rewardTokensList_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;
    rewardTokensList_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
    shares_?: InputMaybe<GaugeShare_Filter>;
    streamer?: InputMaybe<Scalars['Bytes']>;
    streamer_contains?: InputMaybe<Scalars['Bytes']>;
    streamer_gt?: InputMaybe<Scalars['Bytes']>;
    streamer_gte?: InputMaybe<Scalars['Bytes']>;
    streamer_in?: InputMaybe<Array<Scalars['Bytes']>>;
    streamer_lt?: InputMaybe<Scalars['Bytes']>;
    streamer_lte?: InputMaybe<Scalars['Bytes']>;
    streamer_not?: InputMaybe<Scalars['Bytes']>;
    streamer_not_contains?: InputMaybe<Scalars['Bytes']>;
    streamer_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
    symbol?: InputMaybe<Scalars['String']>;
    symbol_contains?: InputMaybe<Scalars['String']>;
    symbol_contains_nocase?: InputMaybe<Scalars['String']>;
    symbol_ends_with?: InputMaybe<Scalars['String']>;
    symbol_ends_with_nocase?: InputMaybe<Scalars['String']>;
    symbol_gt?: InputMaybe<Scalars['String']>;
    symbol_gte?: InputMaybe<Scalars['String']>;
    symbol_in?: InputMaybe<Array<Scalars['String']>>;
    symbol_lt?: InputMaybe<Scalars['String']>;
    symbol_lte?: InputMaybe<Scalars['String']>;
    symbol_not?: InputMaybe<Scalars['String']>;
    symbol_not_contains?: InputMaybe<Scalars['String']>;
    symbol_not_contains_nocase?: InputMaybe<Scalars['String']>;
    symbol_not_ends_with?: InputMaybe<Scalars['String']>;
    symbol_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
    symbol_not_in?: InputMaybe<Array<Scalars['String']>>;
    symbol_not_starts_with?: InputMaybe<Scalars['String']>;
    symbol_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
    symbol_starts_with?: InputMaybe<Scalars['String']>;
    symbol_starts_with_nocase?: InputMaybe<Scalars['String']>;
    tokens_?: InputMaybe<RewardToken_Filter>;
    totalSupply?: InputMaybe<Scalars['BigDecimal']>;
    totalSupply_gt?: InputMaybe<Scalars['BigDecimal']>;
    totalSupply_gte?: InputMaybe<Scalars['BigDecimal']>;
    totalSupply_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
    totalSupply_lt?: InputMaybe<Scalars['BigDecimal']>;
    totalSupply_lte?: InputMaybe<Scalars['BigDecimal']>;
    totalSupply_not?: InputMaybe<Scalars['BigDecimal']>;
    totalSupply_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
};
declare enum LiquidityGauge_OrderBy {
    factory = "factory",
    factory__id = "factory__id",
    factory__numGauges = "factory__numGauges",
    gauge = "gauge",
    gauge__addedTimestamp = "gauge__addedTimestamp",
    gauge__address = "gauge__address",
    gauge__id = "gauge__id",
    id = "id",
    isKilled = "isKilled",
    isPreferentialGauge = "isPreferentialGauge",
    pool = "pool",
    poolAddress = "poolAddress",
    poolId = "poolId",
    pool__address = "pool__address",
    pool__id = "pool__id",
    pool__poolId = "pool__poolId",
    relativeWeightCap = "relativeWeightCap",
    rewardTokensList = "rewardTokensList",
    shares = "shares",
    streamer = "streamer",
    symbol = "symbol",
    tokens = "tokens",
    totalSupply = "totalSupply"
}
type OmniVotingEscrowLock = {
    __typename?: 'OmniVotingEscrowLock';
    /**  veBAL balance at the moment user locks  */
    bias: Scalars['BigDecimal'];
    /**  Chain where the lock was bridged to  */
    dstChainId: Scalars['Int'];
    /**  Equal to: <userAdress>-<omniVotingEscrow>  */
    id: Scalars['ID'];
    /**  User on the local chain (reference to User entity)  */
    localUser: User;
    /**  User address on the remote chain  */
    remoteUser: Scalars['Bytes'];
    /**  veBAL decay rate (per second)  */
    slope: Scalars['BigDecimal'];
    /**  Timestamp the lock was created [seconds]  */
    timestamp: Scalars['Int'];
    /**  Reference to VotingEscrow entity  */
    votingEscrowID: VotingEscrow;
};
type OmniVotingEscrowLock_Filter = {
    /** Filter for the block changed event. */
    _change_block?: InputMaybe<BlockChangedFilter>;
    and?: InputMaybe<Array<InputMaybe<OmniVotingEscrowLock_Filter>>>;
    bias?: InputMaybe<Scalars['BigDecimal']>;
    bias_gt?: InputMaybe<Scalars['BigDecimal']>;
    bias_gte?: InputMaybe<Scalars['BigDecimal']>;
    bias_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
    bias_lt?: InputMaybe<Scalars['BigDecimal']>;
    bias_lte?: InputMaybe<Scalars['BigDecimal']>;
    bias_not?: InputMaybe<Scalars['BigDecimal']>;
    bias_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
    dstChainId?: InputMaybe<Scalars['Int']>;
    dstChainId_gt?: InputMaybe<Scalars['Int']>;
    dstChainId_gte?: InputMaybe<Scalars['Int']>;
    dstChainId_in?: InputMaybe<Array<Scalars['Int']>>;
    dstChainId_lt?: InputMaybe<Scalars['Int']>;
    dstChainId_lte?: InputMaybe<Scalars['Int']>;
    dstChainId_not?: InputMaybe<Scalars['Int']>;
    dstChainId_not_in?: InputMaybe<Array<Scalars['Int']>>;
    id?: InputMaybe<Scalars['ID']>;
    id_gt?: InputMaybe<Scalars['ID']>;
    id_gte?: InputMaybe<Scalars['ID']>;
    id_in?: InputMaybe<Array<Scalars['ID']>>;
    id_lt?: InputMaybe<Scalars['ID']>;
    id_lte?: InputMaybe<Scalars['ID']>;
    id_not?: InputMaybe<Scalars['ID']>;
    id_not_in?: InputMaybe<Array<Scalars['ID']>>;
    localUser?: InputMaybe<Scalars['String']>;
    localUser_?: InputMaybe<User_Filter>;
    localUser_contains?: InputMaybe<Scalars['String']>;
    localUser_contains_nocase?: InputMaybe<Scalars['String']>;
    localUser_ends_with?: InputMaybe<Scalars['String']>;
    localUser_ends_with_nocase?: InputMaybe<Scalars['String']>;
    localUser_gt?: InputMaybe<Scalars['String']>;
    localUser_gte?: InputMaybe<Scalars['String']>;
    localUser_in?: InputMaybe<Array<Scalars['String']>>;
    localUser_lt?: InputMaybe<Scalars['String']>;
    localUser_lte?: InputMaybe<Scalars['String']>;
    localUser_not?: InputMaybe<Scalars['String']>;
    localUser_not_contains?: InputMaybe<Scalars['String']>;
    localUser_not_contains_nocase?: InputMaybe<Scalars['String']>;
    localUser_not_ends_with?: InputMaybe<Scalars['String']>;
    localUser_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
    localUser_not_in?: InputMaybe<Array<Scalars['String']>>;
    localUser_not_starts_with?: InputMaybe<Scalars['String']>;
    localUser_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
    localUser_starts_with?: InputMaybe<Scalars['String']>;
    localUser_starts_with_nocase?: InputMaybe<Scalars['String']>;
    or?: InputMaybe<Array<InputMaybe<OmniVotingEscrowLock_Filter>>>;
    remoteUser?: InputMaybe<Scalars['Bytes']>;
    remoteUser_contains?: InputMaybe<Scalars['Bytes']>;
    remoteUser_gt?: InputMaybe<Scalars['Bytes']>;
    remoteUser_gte?: InputMaybe<Scalars['Bytes']>;
    remoteUser_in?: InputMaybe<Array<Scalars['Bytes']>>;
    remoteUser_lt?: InputMaybe<Scalars['Bytes']>;
    remoteUser_lte?: InputMaybe<Scalars['Bytes']>;
    remoteUser_not?: InputMaybe<Scalars['Bytes']>;
    remoteUser_not_contains?: InputMaybe<Scalars['Bytes']>;
    remoteUser_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
    slope?: InputMaybe<Scalars['BigDecimal']>;
    slope_gt?: InputMaybe<Scalars['BigDecimal']>;
    slope_gte?: InputMaybe<Scalars['BigDecimal']>;
    slope_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
    slope_lt?: InputMaybe<Scalars['BigDecimal']>;
    slope_lte?: InputMaybe<Scalars['BigDecimal']>;
    slope_not?: InputMaybe<Scalars['BigDecimal']>;
    slope_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
    timestamp?: InputMaybe<Scalars['Int']>;
    timestamp_gt?: InputMaybe<Scalars['Int']>;
    timestamp_gte?: InputMaybe<Scalars['Int']>;
    timestamp_in?: InputMaybe<Array<Scalars['Int']>>;
    timestamp_lt?: InputMaybe<Scalars['Int']>;
    timestamp_lte?: InputMaybe<Scalars['Int']>;
    timestamp_not?: InputMaybe<Scalars['Int']>;
    timestamp_not_in?: InputMaybe<Array<Scalars['Int']>>;
    votingEscrowID?: InputMaybe<Scalars['String']>;
    votingEscrowID_?: InputMaybe<VotingEscrow_Filter>;
    votingEscrowID_contains?: InputMaybe<Scalars['String']>;
    votingEscrowID_contains_nocase?: InputMaybe<Scalars['String']>;
    votingEscrowID_ends_with?: InputMaybe<Scalars['String']>;
    votingEscrowID_ends_with_nocase?: InputMaybe<Scalars['String']>;
    votingEscrowID_gt?: InputMaybe<Scalars['String']>;
    votingEscrowID_gte?: InputMaybe<Scalars['String']>;
    votingEscrowID_in?: InputMaybe<Array<Scalars['String']>>;
    votingEscrowID_lt?: InputMaybe<Scalars['String']>;
    votingEscrowID_lte?: InputMaybe<Scalars['String']>;
    votingEscrowID_not?: InputMaybe<Scalars['String']>;
    votingEscrowID_not_contains?: InputMaybe<Scalars['String']>;
    votingEscrowID_not_contains_nocase?: InputMaybe<Scalars['String']>;
    votingEscrowID_not_ends_with?: InputMaybe<Scalars['String']>;
    votingEscrowID_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
    votingEscrowID_not_in?: InputMaybe<Array<Scalars['String']>>;
    votingEscrowID_not_starts_with?: InputMaybe<Scalars['String']>;
    votingEscrowID_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
    votingEscrowID_starts_with?: InputMaybe<Scalars['String']>;
    votingEscrowID_starts_with_nocase?: InputMaybe<Scalars['String']>;
};
/** Defines the order direction, either ascending or descending */
declare enum OrderDirection {
    asc = "asc",
    desc = "desc"
}
type Pool$2 = {
    __typename?: 'Pool';
    /**  Address of the pool (lp_token of the gauge)  */
    address: Scalars['Bytes'];
    /**  List of gauges created for the pool  */
    gauges?: Maybe<Array<LiquidityGauge$1>>;
    /**  List of the pool's gauges addresses  */
    gaugesList: Array<Scalars['Bytes']>;
    /**  Address of the pool (lp_token of the gauge)  */
    id: Scalars['ID'];
    /**  Pool ID if lp_token is a Balancer pool; null otherwise  */
    poolId?: Maybe<Scalars['Bytes']>;
    /**  Most recent, unkilled gauge in the GaugeController  */
    preferentialGauge?: Maybe<LiquidityGauge$1>;
};
type Pool_Filter = {
    /** Filter for the block changed event. */
    _change_block?: InputMaybe<BlockChangedFilter>;
    address?: InputMaybe<Scalars['Bytes']>;
    address_contains?: InputMaybe<Scalars['Bytes']>;
    address_gt?: InputMaybe<Scalars['Bytes']>;
    address_gte?: InputMaybe<Scalars['Bytes']>;
    address_in?: InputMaybe<Array<Scalars['Bytes']>>;
    address_lt?: InputMaybe<Scalars['Bytes']>;
    address_lte?: InputMaybe<Scalars['Bytes']>;
    address_not?: InputMaybe<Scalars['Bytes']>;
    address_not_contains?: InputMaybe<Scalars['Bytes']>;
    address_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
    and?: InputMaybe<Array<InputMaybe<Pool_Filter>>>;
    gaugesList?: InputMaybe<Array<Scalars['Bytes']>>;
    gaugesList_contains?: InputMaybe<Array<Scalars['Bytes']>>;
    gaugesList_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
    gaugesList_not?: InputMaybe<Array<Scalars['Bytes']>>;
    gaugesList_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;
    gaugesList_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
    gauges_?: InputMaybe<LiquidityGauge_Filter>;
    id?: InputMaybe<Scalars['ID']>;
    id_gt?: InputMaybe<Scalars['ID']>;
    id_gte?: InputMaybe<Scalars['ID']>;
    id_in?: InputMaybe<Array<Scalars['ID']>>;
    id_lt?: InputMaybe<Scalars['ID']>;
    id_lte?: InputMaybe<Scalars['ID']>;
    id_not?: InputMaybe<Scalars['ID']>;
    id_not_in?: InputMaybe<Array<Scalars['ID']>>;
    or?: InputMaybe<Array<InputMaybe<Pool_Filter>>>;
    poolId?: InputMaybe<Scalars['Bytes']>;
    poolId_contains?: InputMaybe<Scalars['Bytes']>;
    poolId_gt?: InputMaybe<Scalars['Bytes']>;
    poolId_gte?: InputMaybe<Scalars['Bytes']>;
    poolId_in?: InputMaybe<Array<Scalars['Bytes']>>;
    poolId_lt?: InputMaybe<Scalars['Bytes']>;
    poolId_lte?: InputMaybe<Scalars['Bytes']>;
    poolId_not?: InputMaybe<Scalars['Bytes']>;
    poolId_not_contains?: InputMaybe<Scalars['Bytes']>;
    poolId_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
    preferentialGauge?: InputMaybe<Scalars['String']>;
    preferentialGauge_?: InputMaybe<LiquidityGauge_Filter>;
    preferentialGauge_contains?: InputMaybe<Scalars['String']>;
    preferentialGauge_contains_nocase?: InputMaybe<Scalars['String']>;
    preferentialGauge_ends_with?: InputMaybe<Scalars['String']>;
    preferentialGauge_ends_with_nocase?: InputMaybe<Scalars['String']>;
    preferentialGauge_gt?: InputMaybe<Scalars['String']>;
    preferentialGauge_gte?: InputMaybe<Scalars['String']>;
    preferentialGauge_in?: InputMaybe<Array<Scalars['String']>>;
    preferentialGauge_lt?: InputMaybe<Scalars['String']>;
    preferentialGauge_lte?: InputMaybe<Scalars['String']>;
    preferentialGauge_not?: InputMaybe<Scalars['String']>;
    preferentialGauge_not_contains?: InputMaybe<Scalars['String']>;
    preferentialGauge_not_contains_nocase?: InputMaybe<Scalars['String']>;
    preferentialGauge_not_ends_with?: InputMaybe<Scalars['String']>;
    preferentialGauge_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
    preferentialGauge_not_in?: InputMaybe<Array<Scalars['String']>>;
    preferentialGauge_not_starts_with?: InputMaybe<Scalars['String']>;
    preferentialGauge_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
    preferentialGauge_starts_with?: InputMaybe<Scalars['String']>;
    preferentialGauge_starts_with_nocase?: InputMaybe<Scalars['String']>;
};
declare enum Pool_OrderBy {
    address = "address",
    gauges = "gauges",
    gaugesList = "gaugesList",
    id = "id",
    poolId = "poolId",
    preferentialGauge = "preferentialGauge",
    preferentialGauge__id = "preferentialGauge__id",
    preferentialGauge__isKilled = "preferentialGauge__isKilled",
    preferentialGauge__isPreferentialGauge = "preferentialGauge__isPreferentialGauge",
    preferentialGauge__poolAddress = "preferentialGauge__poolAddress",
    preferentialGauge__poolId = "preferentialGauge__poolId",
    preferentialGauge__relativeWeightCap = "preferentialGauge__relativeWeightCap",
    preferentialGauge__streamer = "preferentialGauge__streamer",
    preferentialGauge__symbol = "preferentialGauge__symbol",
    preferentialGauge__totalSupply = "preferentialGauge__totalSupply"
}
type RewardToken = {
    __typename?: 'RewardToken';
    /**  ERC20 token decimals - zero if call to decimals() reverts  */
    decimals: Scalars['Int'];
    /**  Reference to LiquidityGauge entity  */
    gauge: LiquidityGauge$1;
    /**  Equal to: <tokenAddress>-<gaugeAddress>  */
    id: Scalars['ID'];
    /**  Timestamp at which finishes the period of rewards  */
    periodFinish?: Maybe<Scalars['BigInt']>;
    /**  Rate of reward tokens streamed per second  */
    rate?: Maybe<Scalars['BigDecimal']>;
    /**  ERC20 token symbol - empty string if call to symbol() reverts  */
    symbol: Scalars['String'];
    /**  Amount of reward tokens that has been deposited into the gauge  */
    totalDeposited: Scalars['BigDecimal'];
};
type RewardToken_Filter = {
    /** Filter for the block changed event. */
    _change_block?: InputMaybe<BlockChangedFilter>;
    and?: InputMaybe<Array<InputMaybe<RewardToken_Filter>>>;
    decimals?: InputMaybe<Scalars['Int']>;
    decimals_gt?: InputMaybe<Scalars['Int']>;
    decimals_gte?: InputMaybe<Scalars['Int']>;
    decimals_in?: InputMaybe<Array<Scalars['Int']>>;
    decimals_lt?: InputMaybe<Scalars['Int']>;
    decimals_lte?: InputMaybe<Scalars['Int']>;
    decimals_not?: InputMaybe<Scalars['Int']>;
    decimals_not_in?: InputMaybe<Array<Scalars['Int']>>;
    gauge?: InputMaybe<Scalars['String']>;
    gauge_?: InputMaybe<LiquidityGauge_Filter>;
    gauge_contains?: InputMaybe<Scalars['String']>;
    gauge_contains_nocase?: InputMaybe<Scalars['String']>;
    gauge_ends_with?: InputMaybe<Scalars['String']>;
    gauge_ends_with_nocase?: InputMaybe<Scalars['String']>;
    gauge_gt?: InputMaybe<Scalars['String']>;
    gauge_gte?: InputMaybe<Scalars['String']>;
    gauge_in?: InputMaybe<Array<Scalars['String']>>;
    gauge_lt?: InputMaybe<Scalars['String']>;
    gauge_lte?: InputMaybe<Scalars['String']>;
    gauge_not?: InputMaybe<Scalars['String']>;
    gauge_not_contains?: InputMaybe<Scalars['String']>;
    gauge_not_contains_nocase?: InputMaybe<Scalars['String']>;
    gauge_not_ends_with?: InputMaybe<Scalars['String']>;
    gauge_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
    gauge_not_in?: InputMaybe<Array<Scalars['String']>>;
    gauge_not_starts_with?: InputMaybe<Scalars['String']>;
    gauge_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
    gauge_starts_with?: InputMaybe<Scalars['String']>;
    gauge_starts_with_nocase?: InputMaybe<Scalars['String']>;
    id?: InputMaybe<Scalars['ID']>;
    id_gt?: InputMaybe<Scalars['ID']>;
    id_gte?: InputMaybe<Scalars['ID']>;
    id_in?: InputMaybe<Array<Scalars['ID']>>;
    id_lt?: InputMaybe<Scalars['ID']>;
    id_lte?: InputMaybe<Scalars['ID']>;
    id_not?: InputMaybe<Scalars['ID']>;
    id_not_in?: InputMaybe<Array<Scalars['ID']>>;
    or?: InputMaybe<Array<InputMaybe<RewardToken_Filter>>>;
    periodFinish?: InputMaybe<Scalars['BigInt']>;
    periodFinish_gt?: InputMaybe<Scalars['BigInt']>;
    periodFinish_gte?: InputMaybe<Scalars['BigInt']>;
    periodFinish_in?: InputMaybe<Array<Scalars['BigInt']>>;
    periodFinish_lt?: InputMaybe<Scalars['BigInt']>;
    periodFinish_lte?: InputMaybe<Scalars['BigInt']>;
    periodFinish_not?: InputMaybe<Scalars['BigInt']>;
    periodFinish_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
    rate?: InputMaybe<Scalars['BigDecimal']>;
    rate_gt?: InputMaybe<Scalars['BigDecimal']>;
    rate_gte?: InputMaybe<Scalars['BigDecimal']>;
    rate_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
    rate_lt?: InputMaybe<Scalars['BigDecimal']>;
    rate_lte?: InputMaybe<Scalars['BigDecimal']>;
    rate_not?: InputMaybe<Scalars['BigDecimal']>;
    rate_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
    symbol?: InputMaybe<Scalars['String']>;
    symbol_contains?: InputMaybe<Scalars['String']>;
    symbol_contains_nocase?: InputMaybe<Scalars['String']>;
    symbol_ends_with?: InputMaybe<Scalars['String']>;
    symbol_ends_with_nocase?: InputMaybe<Scalars['String']>;
    symbol_gt?: InputMaybe<Scalars['String']>;
    symbol_gte?: InputMaybe<Scalars['String']>;
    symbol_in?: InputMaybe<Array<Scalars['String']>>;
    symbol_lt?: InputMaybe<Scalars['String']>;
    symbol_lte?: InputMaybe<Scalars['String']>;
    symbol_not?: InputMaybe<Scalars['String']>;
    symbol_not_contains?: InputMaybe<Scalars['String']>;
    symbol_not_contains_nocase?: InputMaybe<Scalars['String']>;
    symbol_not_ends_with?: InputMaybe<Scalars['String']>;
    symbol_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
    symbol_not_in?: InputMaybe<Array<Scalars['String']>>;
    symbol_not_starts_with?: InputMaybe<Scalars['String']>;
    symbol_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
    symbol_starts_with?: InputMaybe<Scalars['String']>;
    symbol_starts_with_nocase?: InputMaybe<Scalars['String']>;
    totalDeposited?: InputMaybe<Scalars['BigDecimal']>;
    totalDeposited_gt?: InputMaybe<Scalars['BigDecimal']>;
    totalDeposited_gte?: InputMaybe<Scalars['BigDecimal']>;
    totalDeposited_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
    totalDeposited_lt?: InputMaybe<Scalars['BigDecimal']>;
    totalDeposited_lte?: InputMaybe<Scalars['BigDecimal']>;
    totalDeposited_not?: InputMaybe<Scalars['BigDecimal']>;
    totalDeposited_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
};
type RootGauge = {
    __typename?: 'RootGauge';
    /**  Chain where emissions by this gauge will be bridged to  */
    chain: Chain;
    /**  Factory contract address  */
    factory: GaugeFactory;
    /**  Reference to Gauge entity - created when LiquidityGauge is added to GaugeController */
    gauge?: Maybe<Gauge>;
    /**  RootGauge contract address */
    id: Scalars['ID'];
    /**  Whether Balancer DAO killed the gauge  */
    isKilled: Scalars['Boolean'];
    /**  Address where emissions by this gauge will be bridged to  */
    recipient: Scalars['Bytes'];
    /**  Relative weight cap of the gauge (0.01 = 1%) - V2 factories only  */
    relativeWeightCap?: Maybe<Scalars['BigDecimal']>;
};
type RootGauge_Filter = {
    /** Filter for the block changed event. */
    _change_block?: InputMaybe<BlockChangedFilter>;
    and?: InputMaybe<Array<InputMaybe<RootGauge_Filter>>>;
    chain?: InputMaybe<Chain>;
    chain_in?: InputMaybe<Array<Chain>>;
    chain_not?: InputMaybe<Chain>;
    chain_not_in?: InputMaybe<Array<Chain>>;
    factory?: InputMaybe<Scalars['String']>;
    factory_?: InputMaybe<GaugeFactory_Filter>;
    factory_contains?: InputMaybe<Scalars['String']>;
    factory_contains_nocase?: InputMaybe<Scalars['String']>;
    factory_ends_with?: InputMaybe<Scalars['String']>;
    factory_ends_with_nocase?: InputMaybe<Scalars['String']>;
    factory_gt?: InputMaybe<Scalars['String']>;
    factory_gte?: InputMaybe<Scalars['String']>;
    factory_in?: InputMaybe<Array<Scalars['String']>>;
    factory_lt?: InputMaybe<Scalars['String']>;
    factory_lte?: InputMaybe<Scalars['String']>;
    factory_not?: InputMaybe<Scalars['String']>;
    factory_not_contains?: InputMaybe<Scalars['String']>;
    factory_not_contains_nocase?: InputMaybe<Scalars['String']>;
    factory_not_ends_with?: InputMaybe<Scalars['String']>;
    factory_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
    factory_not_in?: InputMaybe<Array<Scalars['String']>>;
    factory_not_starts_with?: InputMaybe<Scalars['String']>;
    factory_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
    factory_starts_with?: InputMaybe<Scalars['String']>;
    factory_starts_with_nocase?: InputMaybe<Scalars['String']>;
    gauge?: InputMaybe<Scalars['String']>;
    gauge_?: InputMaybe<Gauge_Filter>;
    gauge_contains?: InputMaybe<Scalars['String']>;
    gauge_contains_nocase?: InputMaybe<Scalars['String']>;
    gauge_ends_with?: InputMaybe<Scalars['String']>;
    gauge_ends_with_nocase?: InputMaybe<Scalars['String']>;
    gauge_gt?: InputMaybe<Scalars['String']>;
    gauge_gte?: InputMaybe<Scalars['String']>;
    gauge_in?: InputMaybe<Array<Scalars['String']>>;
    gauge_lt?: InputMaybe<Scalars['String']>;
    gauge_lte?: InputMaybe<Scalars['String']>;
    gauge_not?: InputMaybe<Scalars['String']>;
    gauge_not_contains?: InputMaybe<Scalars['String']>;
    gauge_not_contains_nocase?: InputMaybe<Scalars['String']>;
    gauge_not_ends_with?: InputMaybe<Scalars['String']>;
    gauge_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
    gauge_not_in?: InputMaybe<Array<Scalars['String']>>;
    gauge_not_starts_with?: InputMaybe<Scalars['String']>;
    gauge_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
    gauge_starts_with?: InputMaybe<Scalars['String']>;
    gauge_starts_with_nocase?: InputMaybe<Scalars['String']>;
    id?: InputMaybe<Scalars['ID']>;
    id_gt?: InputMaybe<Scalars['ID']>;
    id_gte?: InputMaybe<Scalars['ID']>;
    id_in?: InputMaybe<Array<Scalars['ID']>>;
    id_lt?: InputMaybe<Scalars['ID']>;
    id_lte?: InputMaybe<Scalars['ID']>;
    id_not?: InputMaybe<Scalars['ID']>;
    id_not_in?: InputMaybe<Array<Scalars['ID']>>;
    isKilled?: InputMaybe<Scalars['Boolean']>;
    isKilled_in?: InputMaybe<Array<Scalars['Boolean']>>;
    isKilled_not?: InputMaybe<Scalars['Boolean']>;
    isKilled_not_in?: InputMaybe<Array<Scalars['Boolean']>>;
    or?: InputMaybe<Array<InputMaybe<RootGauge_Filter>>>;
    recipient?: InputMaybe<Scalars['Bytes']>;
    recipient_contains?: InputMaybe<Scalars['Bytes']>;
    recipient_gt?: InputMaybe<Scalars['Bytes']>;
    recipient_gte?: InputMaybe<Scalars['Bytes']>;
    recipient_in?: InputMaybe<Array<Scalars['Bytes']>>;
    recipient_lt?: InputMaybe<Scalars['Bytes']>;
    recipient_lte?: InputMaybe<Scalars['Bytes']>;
    recipient_not?: InputMaybe<Scalars['Bytes']>;
    recipient_not_contains?: InputMaybe<Scalars['Bytes']>;
    recipient_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
    relativeWeightCap?: InputMaybe<Scalars['BigDecimal']>;
    relativeWeightCap_gt?: InputMaybe<Scalars['BigDecimal']>;
    relativeWeightCap_gte?: InputMaybe<Scalars['BigDecimal']>;
    relativeWeightCap_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
    relativeWeightCap_lt?: InputMaybe<Scalars['BigDecimal']>;
    relativeWeightCap_lte?: InputMaybe<Scalars['BigDecimal']>;
    relativeWeightCap_not?: InputMaybe<Scalars['BigDecimal']>;
    relativeWeightCap_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
};
type User = {
    __typename?: 'User';
    /**  List of gauge the user has shares  */
    gaugeShares?: Maybe<Array<GaugeShare$1>>;
    /**  List of votes on gauges  */
    gaugeVotes?: Maybe<Array<GaugeVote>>;
    /**  User address  */
    id: Scalars['ID'];
    /**  List of omni locks the user created  */
    omniVotingLocks?: Maybe<Array<OmniVotingEscrowLock>>;
    /**  List of locks the user created  */
    votingLocks?: Maybe<Array<VotingEscrowLock>>;
};
type User_Filter = {
    /** Filter for the block changed event. */
    _change_block?: InputMaybe<BlockChangedFilter>;
    and?: InputMaybe<Array<InputMaybe<User_Filter>>>;
    gaugeShares_?: InputMaybe<GaugeShare_Filter>;
    gaugeVotes_?: InputMaybe<GaugeVote_Filter>;
    id?: InputMaybe<Scalars['ID']>;
    id_gt?: InputMaybe<Scalars['ID']>;
    id_gte?: InputMaybe<Scalars['ID']>;
    id_in?: InputMaybe<Array<Scalars['ID']>>;
    id_lt?: InputMaybe<Scalars['ID']>;
    id_lte?: InputMaybe<Scalars['ID']>;
    id_not?: InputMaybe<Scalars['ID']>;
    id_not_in?: InputMaybe<Array<Scalars['ID']>>;
    omniVotingLocks_?: InputMaybe<OmniVotingEscrowLock_Filter>;
    or?: InputMaybe<Array<InputMaybe<User_Filter>>>;
    votingLocks_?: InputMaybe<VotingEscrowLock_Filter>;
};
type VotingEscrow = {
    __typename?: 'VotingEscrow';
    /**  VotingEscrow contract address  */
    id: Scalars['ID'];
    /**  List of veBAL locks created  */
    locks?: Maybe<Array<VotingEscrowLock>>;
    /**  List of veBAL locks created  */
    omniLocks?: Maybe<Array<OmniVotingEscrowLock>>;
    /**  Amount of B-80BAL-20WETH BPT locked, only applies on mainnet  */
    stakedSupply?: Maybe<Scalars['BigDecimal']>;
};
type VotingEscrowLock = {
    __typename?: 'VotingEscrowLock';
    /**  veBAL balance at the moment user locks  */
    bias: Scalars['BigDecimal'];
    /**  Equal to: <userAdress>-<votingEscrow>  */
    id: Scalars['ID'];
    /**  Amount of B-80BAL-20WETH BPT the user has locked  */
    lockedBalance: Scalars['BigDecimal'];
    /**  veBAL decay rate (per second)  */
    slope: Scalars['BigDecimal'];
    /**  Timestamp at which the lock was created [seconds]  */
    timestamp: Scalars['Int'];
    /**  Timestamp at which B-80BAL-20WETH BPT can be unlocked by user [seconds]  */
    unlockTime: Scalars['BigInt'];
    /**  Timestamp at which the lcok was created [seconds]. Same as timestamp  */
    updatedAt: Scalars['Int'];
    /**  Reference to User entity  */
    user: User;
    /**  Reference to VotingEscrow entity  */
    votingEscrowID: VotingEscrow;
};
type VotingEscrowLock_Filter = {
    /** Filter for the block changed event. */
    _change_block?: InputMaybe<BlockChangedFilter>;
    and?: InputMaybe<Array<InputMaybe<VotingEscrowLock_Filter>>>;
    bias?: InputMaybe<Scalars['BigDecimal']>;
    bias_gt?: InputMaybe<Scalars['BigDecimal']>;
    bias_gte?: InputMaybe<Scalars['BigDecimal']>;
    bias_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
    bias_lt?: InputMaybe<Scalars['BigDecimal']>;
    bias_lte?: InputMaybe<Scalars['BigDecimal']>;
    bias_not?: InputMaybe<Scalars['BigDecimal']>;
    bias_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
    id?: InputMaybe<Scalars['ID']>;
    id_gt?: InputMaybe<Scalars['ID']>;
    id_gte?: InputMaybe<Scalars['ID']>;
    id_in?: InputMaybe<Array<Scalars['ID']>>;
    id_lt?: InputMaybe<Scalars['ID']>;
    id_lte?: InputMaybe<Scalars['ID']>;
    id_not?: InputMaybe<Scalars['ID']>;
    id_not_in?: InputMaybe<Array<Scalars['ID']>>;
    lockedBalance?: InputMaybe<Scalars['BigDecimal']>;
    lockedBalance_gt?: InputMaybe<Scalars['BigDecimal']>;
    lockedBalance_gte?: InputMaybe<Scalars['BigDecimal']>;
    lockedBalance_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
    lockedBalance_lt?: InputMaybe<Scalars['BigDecimal']>;
    lockedBalance_lte?: InputMaybe<Scalars['BigDecimal']>;
    lockedBalance_not?: InputMaybe<Scalars['BigDecimal']>;
    lockedBalance_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
    or?: InputMaybe<Array<InputMaybe<VotingEscrowLock_Filter>>>;
    slope?: InputMaybe<Scalars['BigDecimal']>;
    slope_gt?: InputMaybe<Scalars['BigDecimal']>;
    slope_gte?: InputMaybe<Scalars['BigDecimal']>;
    slope_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
    slope_lt?: InputMaybe<Scalars['BigDecimal']>;
    slope_lte?: InputMaybe<Scalars['BigDecimal']>;
    slope_not?: InputMaybe<Scalars['BigDecimal']>;
    slope_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
    timestamp?: InputMaybe<Scalars['Int']>;
    timestamp_gt?: InputMaybe<Scalars['Int']>;
    timestamp_gte?: InputMaybe<Scalars['Int']>;
    timestamp_in?: InputMaybe<Array<Scalars['Int']>>;
    timestamp_lt?: InputMaybe<Scalars['Int']>;
    timestamp_lte?: InputMaybe<Scalars['Int']>;
    timestamp_not?: InputMaybe<Scalars['Int']>;
    timestamp_not_in?: InputMaybe<Array<Scalars['Int']>>;
    unlockTime?: InputMaybe<Scalars['BigInt']>;
    unlockTime_gt?: InputMaybe<Scalars['BigInt']>;
    unlockTime_gte?: InputMaybe<Scalars['BigInt']>;
    unlockTime_in?: InputMaybe<Array<Scalars['BigInt']>>;
    unlockTime_lt?: InputMaybe<Scalars['BigInt']>;
    unlockTime_lte?: InputMaybe<Scalars['BigInt']>;
    unlockTime_not?: InputMaybe<Scalars['BigInt']>;
    unlockTime_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
    updatedAt?: InputMaybe<Scalars['Int']>;
    updatedAt_gt?: InputMaybe<Scalars['Int']>;
    updatedAt_gte?: InputMaybe<Scalars['Int']>;
    updatedAt_in?: InputMaybe<Array<Scalars['Int']>>;
    updatedAt_lt?: InputMaybe<Scalars['Int']>;
    updatedAt_lte?: InputMaybe<Scalars['Int']>;
    updatedAt_not?: InputMaybe<Scalars['Int']>;
    updatedAt_not_in?: InputMaybe<Array<Scalars['Int']>>;
    user?: InputMaybe<Scalars['String']>;
    user_?: InputMaybe<User_Filter>;
    user_contains?: InputMaybe<Scalars['String']>;
    user_contains_nocase?: InputMaybe<Scalars['String']>;
    user_ends_with?: InputMaybe<Scalars['String']>;
    user_ends_with_nocase?: InputMaybe<Scalars['String']>;
    user_gt?: InputMaybe<Scalars['String']>;
    user_gte?: InputMaybe<Scalars['String']>;
    user_in?: InputMaybe<Array<Scalars['String']>>;
    user_lt?: InputMaybe<Scalars['String']>;
    user_lte?: InputMaybe<Scalars['String']>;
    user_not?: InputMaybe<Scalars['String']>;
    user_not_contains?: InputMaybe<Scalars['String']>;
    user_not_contains_nocase?: InputMaybe<Scalars['String']>;
    user_not_ends_with?: InputMaybe<Scalars['String']>;
    user_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
    user_not_in?: InputMaybe<Array<Scalars['String']>>;
    user_not_starts_with?: InputMaybe<Scalars['String']>;
    user_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
    user_starts_with?: InputMaybe<Scalars['String']>;
    user_starts_with_nocase?: InputMaybe<Scalars['String']>;
    votingEscrowID?: InputMaybe<Scalars['String']>;
    votingEscrowID_?: InputMaybe<VotingEscrow_Filter>;
    votingEscrowID_contains?: InputMaybe<Scalars['String']>;
    votingEscrowID_contains_nocase?: InputMaybe<Scalars['String']>;
    votingEscrowID_ends_with?: InputMaybe<Scalars['String']>;
    votingEscrowID_ends_with_nocase?: InputMaybe<Scalars['String']>;
    votingEscrowID_gt?: InputMaybe<Scalars['String']>;
    votingEscrowID_gte?: InputMaybe<Scalars['String']>;
    votingEscrowID_in?: InputMaybe<Array<Scalars['String']>>;
    votingEscrowID_lt?: InputMaybe<Scalars['String']>;
    votingEscrowID_lte?: InputMaybe<Scalars['String']>;
    votingEscrowID_not?: InputMaybe<Scalars['String']>;
    votingEscrowID_not_contains?: InputMaybe<Scalars['String']>;
    votingEscrowID_not_contains_nocase?: InputMaybe<Scalars['String']>;
    votingEscrowID_not_ends_with?: InputMaybe<Scalars['String']>;
    votingEscrowID_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
    votingEscrowID_not_in?: InputMaybe<Array<Scalars['String']>>;
    votingEscrowID_not_starts_with?: InputMaybe<Scalars['String']>;
    votingEscrowID_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
    votingEscrowID_starts_with?: InputMaybe<Scalars['String']>;
    votingEscrowID_starts_with_nocase?: InputMaybe<Scalars['String']>;
};
type VotingEscrow_Filter = {
    /** Filter for the block changed event. */
    _change_block?: InputMaybe<BlockChangedFilter>;
    and?: InputMaybe<Array<InputMaybe<VotingEscrow_Filter>>>;
    id?: InputMaybe<Scalars['ID']>;
    id_gt?: InputMaybe<Scalars['ID']>;
    id_gte?: InputMaybe<Scalars['ID']>;
    id_in?: InputMaybe<Array<Scalars['ID']>>;
    id_lt?: InputMaybe<Scalars['ID']>;
    id_lte?: InputMaybe<Scalars['ID']>;
    id_not?: InputMaybe<Scalars['ID']>;
    id_not_in?: InputMaybe<Array<Scalars['ID']>>;
    locks_?: InputMaybe<VotingEscrowLock_Filter>;
    omniLocks_?: InputMaybe<OmniVotingEscrowLock_Filter>;
    or?: InputMaybe<Array<InputMaybe<VotingEscrow_Filter>>>;
    stakedSupply?: InputMaybe<Scalars['BigDecimal']>;
    stakedSupply_gt?: InputMaybe<Scalars['BigDecimal']>;
    stakedSupply_gte?: InputMaybe<Scalars['BigDecimal']>;
    stakedSupply_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
    stakedSupply_lt?: InputMaybe<Scalars['BigDecimal']>;
    stakedSupply_lte?: InputMaybe<Scalars['BigDecimal']>;
    stakedSupply_not?: InputMaybe<Scalars['BigDecimal']>;
    stakedSupply_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
};
type GaugeShareQueryVariables = Exact<{
    id: Scalars['ID'];
    block?: InputMaybe<Block_Height>;
}>;
type GaugeShareQuery = {
    __typename?: 'Query';
    gaugeShare?: {
        __typename?: 'GaugeShare';
        id: string;
        balance: string;
        user: {
            __typename?: 'User';
            id: string;
        };
        gauge: {
            __typename?: 'LiquidityGauge';
            id: string;
            isKilled: boolean;
            poolId?: string | null;
            poolAddress: string;
            totalSupply: string;
        };
    } | null;
};
type GaugeSharesQueryVariables = Exact<{
    first?: InputMaybe<Scalars['Int']>;
    orderBy?: InputMaybe<GaugeShare_OrderBy>;
    orderDirection?: InputMaybe<OrderDirection>;
    skip?: InputMaybe<Scalars['Int']>;
    where?: InputMaybe<GaugeShare_Filter>;
    block?: InputMaybe<Block_Height>;
}>;
type GaugeSharesQuery = {
    __typename?: 'Query';
    gaugeShares: Array<{
        __typename?: 'GaugeShare';
        id: string;
        balance: string;
        user: {
            __typename?: 'User';
            id: string;
        };
        gauge: {
            __typename?: 'LiquidityGauge';
            id: string;
            isKilled: boolean;
            poolId?: string | null;
            poolAddress: string;
            totalSupply: string;
        };
    }>;
};
type SubgraphGaugeShareFragment = {
    __typename?: 'GaugeShare';
    id: string;
    balance: string;
    user: {
        __typename?: 'User';
        id: string;
    };
    gauge: {
        __typename?: 'LiquidityGauge';
        id: string;
        isKilled: boolean;
        poolId?: string | null;
        poolAddress: string;
        totalSupply: string;
    };
};
type LiquidityGaugesQueryVariables = Exact<{
    skip?: InputMaybe<Scalars['Int']>;
    first?: InputMaybe<Scalars['Int']>;
    orderBy?: InputMaybe<LiquidityGauge_OrderBy>;
    orderDirection?: InputMaybe<OrderDirection>;
    where?: InputMaybe<LiquidityGauge_Filter>;
    block?: InputMaybe<Block_Height>;
}>;
type LiquidityGaugesQuery = {
    __typename?: 'Query';
    liquidityGauges: Array<{
        __typename?: 'LiquidityGauge';
        id: string;
        symbol: string;
        poolAddress: string;
        poolId?: string | null;
        streamer?: string | null;
        totalSupply: string;
        factory: {
            __typename?: 'GaugeFactory';
            id: string;
            numGauges: number;
        };
        tokens?: Array<{
            __typename?: 'RewardToken';
            id: string;
            symbol: string;
            decimals: number;
            totalDeposited: string;
            rate?: string | null;
            periodFinish?: string | null;
        }> | null;
    }>;
};
type PoolsQueryVariables = Exact<{
    skip?: InputMaybe<Scalars['Int']>;
    first?: InputMaybe<Scalars['Int']>;
    orderBy?: InputMaybe<Pool_OrderBy>;
    orderDirection?: InputMaybe<OrderDirection>;
    where?: InputMaybe<Pool_Filter>;
    block?: InputMaybe<Block_Height>;
}>;
type PoolsQuery = {
    __typename?: 'Query';
    pools: Array<{
        __typename?: 'Pool';
        id: string;
        poolId?: string | null;
        preferentialGauge?: {
            __typename?: 'LiquidityGauge';
            id: string;
            symbol: string;
            poolAddress: string;
            poolId?: string | null;
            streamer?: string | null;
            totalSupply: string;
            factory: {
                __typename?: 'GaugeFactory';
                id: string;
                numGauges: number;
            };
            tokens?: Array<{
                __typename?: 'RewardToken';
                id: string;
                symbol: string;
                decimals: number;
                totalDeposited: string;
                rate?: string | null;
                periodFinish?: string | null;
            }> | null;
        } | null;
    }>;
};
type PoolGaugesQueryVariables = Exact<{
    where?: InputMaybe<Pool_Filter>;
    first?: InputMaybe<Scalars['Int']>;
    orderBy?: InputMaybe<Pool_OrderBy>;
    orderDirection?: InputMaybe<OrderDirection>;
    skip?: InputMaybe<Scalars['Int']>;
    block?: InputMaybe<Block_Height>;
}>;
type PoolGaugesQuery = {
    __typename?: 'Query';
    pools: Array<{
        __typename?: 'Pool';
        gauges?: Array<{
            __typename?: 'LiquidityGauge';
            id: string;
            relativeWeightCap?: string | null;
        }> | null;
        preferentialGauge?: {
            __typename?: 'LiquidityGauge';
            id: string;
        } | null;
    }>;
};
type SdkFunctionWrapper = <T>(action: (requestHeaders?: Record<string, string>) => Promise<T>, operationName: string, operationType?: string) => Promise<T>;
declare function getSdk(client: GraphQLClient, withWrapper?: SdkFunctionWrapper): {
    GaugeShare(variables: GaugeShareQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<GaugeShareQuery>;
    GaugeShares(variables?: GaugeSharesQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<GaugeSharesQuery>;
    LiquidityGauges(variables?: LiquidityGaugesQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<LiquidityGaugesQuery>;
    Pools(variables?: PoolsQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<PoolsQuery>;
    PoolGauges(variables?: PoolGaugesQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<PoolGaugesQuery>;
};
type Sdk = ReturnType<typeof getSdk>;

type SubgraphClient = Sdk$1;
type GaugesClient = Sdk;
type SubgraphLiquidityGauge = LiquidityGauge$1;

/**
 * Access liquidity gauges indexed by subgraph.
 * Because we have ~100 gauges to save on repeated http calls we cache all results as `gauges` on an instance.
 * Balancer's subgraph URL: https://thegraph.com/hosted-service/subgraph/balancer-labs/balancer-gauges
 */
declare class LiquidityGaugesSubgraphRepository implements Findable<SubgraphLiquidityGauge> {
    private client;
    gauges: SubgraphLiquidityGauge[];
    constructor(url: string);
    fetch(): Promise<SubgraphLiquidityGauge[]>;
    find(id: string): Promise<SubgraphLiquidityGauge | undefined>;
    findBy(param: string, value: string): Promise<SubgraphLiquidityGauge | undefined>;
}

interface LiquidityGauge {
    id: string;
    address: string;
    name: string;
    poolId?: Maybe$1<string>;
    poolAddress: string;
    totalSupply: number;
    workingSupply: number;
    relativeWeight: number;
    rewardTokens?: {
        [tokenAddress: string]: RewardData;
    };
    claimableTokens?: {
        [tokenAddress: string]: BigNumber;
    };
    balInflationRate?: number;
}
declare class LiquidityGaugeSubgraphRPCProvider implements Findable<LiquidityGauge> {
    private chainId;
    gaugeController?: GaugeControllerMulticallRepository;
    multicall: LiquidityGaugesMulticallRepository;
    subgraph: LiquidityGaugesSubgraphRepository;
    workingSupplies: {
        [gaugeAddress: string]: number;
    };
    relativeWeights: {
        [gaugeAddress: string]: number;
    };
    inflationRates: {
        [gaugeAddress: string]: number;
    };
    rewardData: {
        [gaugeAddress: string]: {
            [tokenAddress: string]: RewardData;
        };
    };
    gauges?: Promise<LiquidityGauge[]>;
    constructor(subgraphUrl: string, multicall: Multicall, gaugeControllerAddress: string, chainId: Network, gaugeControllerCheckpointerAddress?: string);
    fetch(): Promise<LiquidityGauge[]>;
    find(id: string): Promise<LiquidityGauge | undefined>;
    findBy(attribute: string, value: string): Promise<LiquidityGauge | undefined>;
    private compose;
}

type PoolAttribute = 'id' | 'address';
interface PoolRepository {
    skip?: number;
}
interface PoolsRepositoryFetchOptions {
    first?: number;
    skip?: number;
}
interface PoolsFallbackRepositoryOptions {
    timeout?: number;
}

type TokenAttribute = 'address' | 'symbol';
interface TokenProvider {
    find: (address: string) => Promise<Token | undefined>;
    findBy: (attribute: TokenAttribute, value: string) => Promise<Token | undefined>;
}

interface ProtocolFees {
    swapFee: number;
    yieldFee: number;
}
declare class ProtocolFeesProvider {
    private multicall;
    private protocolFeePercentagesProviderAddress;
    protocolFees?: ProtocolFees;
    constructor(multicall: Multicall, protocolFeePercentagesProviderAddress: string);
    private fetch;
    getFees(): Promise<ProtocolFees>;
}

declare enum PoolGaugesAttributes {
    Id = "id",
    Address = "address",
    PoolId = "poolId"
}
interface PoolGauges {
    preferentialGauge: {
        id: string;
    };
    gauges: {
        id: string;
        relativeWeightCap?: string | null;
    }[];
}

declare enum PoolShareAttributes {
    Balance = "balance",
    Id = "id",
    PoolId = "poolId",
    UserAddress = "userAddress"
}
interface PoolShare {
    id: string;
    userAddress: string;
    poolId: string;
    balance: string;
}

declare enum GaugeShareAttributes {
    Id = "id",
    UserAddress = "user",
    GaugeId = "gauge",
    Balance = "balance"
}
interface GaugeShare {
    id: string;
    balance: string;
    userAddress: string;
    gauge: {
        id: string;
        poolId?: string;
        isKilled: boolean;
        totalSupply: string;
    };
}

interface Findable<T, P = string, V = any> {
    find: (id: string) => Promise<T | undefined>;
    findBy: (attribute: P, value: V) => Promise<T | undefined>;
}
interface Searchable<T> {
    all: () => Promise<T[]>;
    where: (filters: (arg: T) => boolean) => Promise<T[]>;
}
interface Cacheable<T> {
    refresh: (arg: T) => Promise<T>;
}

interface GyroConfigRepository {
    getGyroProtocolFee(poolAddress: string): Promise<number>;
}
declare class GyroConfigRepositoryImpl implements GyroConfigRepository {
    private gyroConfigAddress;
    private multicall;
    gyroConfigInterface: GyroConfigInterface;
    gyroConfig: GyroConfig;
    constructor(gyroConfigAddress: string, multicall: Multicall, provider: Provider);
    getGyroProtocolFee(poolAddress: string): Promise<number>;
}

/**
 * Weekly Bal emissions are fixed / year according to:
 * https://docs.google.com/spreadsheets/d/1FY0gi596YWBOTeu_mrxhWcdF74SwKMNhmu0qJVgs0KI/edit#gid=0
 *
 * Using regular numbers for simplicity assuming frontend use only.
 *
 * Calculation source
 * https://github.com/balancer-labs/balancer-v2-monorepo/blob/master/pkg/liquidity-mining/contracts/BalancerTokenAdmin.sol
 */
declare const INITIAL_RATE = 145000;
declare const START_EPOCH_TIME = 1648465251;
/**
 * Weekly BAL emissions
 *
 * @param currentTimestamp used to get the epoch
 * @returns BAL emitted in a week
 */
declare const weekly: (currentTimestamp?: number) => number;
/**
 * Total BAL emitted in epoch (1 year)
 *
 * @param epoch starting from 0 for the first year of emissions
 * @returns BAL emitted in epoch
 */
declare const total: (epoch: number) => number;
/**
 * Total BAL emitted between two timestamps
 *
 * @param start starting timestamp
 * @param end ending timestamp
 * @returns BAL emitted in period
 */
declare const between: (start: number, end: number) => number;

declare const emissions_INITIAL_RATE: typeof INITIAL_RATE;
declare const emissions_START_EPOCH_TIME: typeof START_EPOCH_TIME;
declare const emissions_weekly: typeof weekly;
declare const emissions_total: typeof total;
declare const emissions_between: typeof between;
declare namespace emissions {
  export {
    emissions_INITIAL_RATE as INITIAL_RATE,
    emissions_START_EPOCH_TIME as START_EPOCH_TIME,
    emissions_weekly as weekly,
    emissions_total as total,
    emissions_between as between,
  };
}

declare abstract class AbstractSubgraphRepository<T, A> implements Findable<T, A> {
    protected abstract mapType(subgraphFragment: any): T;
    abstract query(args: any): Promise<T[]>;
    get(args: any): Promise<T | undefined>;
    find(id: string): Promise<T | undefined>;
    findBy(attribute: A, value: string): Promise<T | undefined>;
    findAllBy(attribute: A, value: string, first?: number, skip?: number): Promise<T[]>;
}

declare abstract class BalancerSubgraphRepository<T, A> extends AbstractSubgraphRepository<T, A> {
    protected chainId: Network;
    protected blockHeight?: (() => Promise<number | undefined>) | undefined;
    protected client: SubgraphClient;
    constructor(url: string, chainId: Network, blockHeight?: (() => Promise<number | undefined>) | undefined);
}

declare abstract class GaugesSubgraphRepository<T, A> extends AbstractSubgraphRepository<T, A> {
    protected chainId: Network;
    protected blockHeight?: (() => Promise<number | undefined>) | undefined;
    protected client: GaugesClient;
    constructor(url: string, chainId: Network, blockHeight?: (() => Promise<number | undefined>) | undefined);
}

declare class GaugeSharesRepository extends GaugesSubgraphRepository<GaugeShare, GaugeShareAttributes> {
    query(args: any): Promise<GaugeShare[]>;
    mapType(subgraphGaugeShare: SubgraphGaugeShareFragment): GaugeShare;
    findByUser(userAddress: string, first?: number, skip?: number): Promise<GaugeShare[]>;
    findByGauge(gaugeId: string, first?: number, skip?: number): Promise<GaugeShare[]>;
}

interface PoolsBalancerAPIOptions {
    url: string;
    apiKey: string;
    query?: GraphQLQuery;
}
/**
 * Access pools using the Balancer GraphQL Api.
 *
 * Balancer's API URL: https://api.balancer.fi/query/
 */
declare class PoolsBalancerAPIRepository implements Findable<Pool$1, PoolAttribute> {
    private client;
    pools: Pool$1[];
    skip: number;
    nextToken: string | undefined | null;
    private query;
    private hasFetched;
    private isFetching;
    constructor(options: PoolsBalancerAPIOptions);
    private fetchFromCache;
    fetch(options?: PoolsRepositoryFetchOptions): Promise<Pool$1[]>;
    fetchAll(options?: PoolsRepositoryFetchOptions): Promise<void>;
    awaitEnoughPoolsFetched(first: number, skip: number): Promise<void>;
    find(id: string): Promise<Pool$1 | undefined>;
    findBy(param: PoolAttribute, value: string): Promise<Pool$1 | undefined>;
    /** Fixes any formatting issues from the subgraph
     *  - GraphQL can't store a map so pool.apr.[rewardAprs/tokenAprs].breakdown
     *    is JSON data that needs to be parsed so they match the Pool type correctly.
     */
    private format;
}

/**
 * The fallback provider takes multiple PoolRepository's in an array and uses them in order
 * falling back to the next one if a request times out.
 *
 * This is useful for using the Balancer API while being able to fall back to the graph if it is down
 * to ensure Balancer is maximally decentralized.
 **/
declare class PoolsFallbackRepository implements Findable<Pool$1, PoolAttribute> {
    private readonly providers;
    currentProviderIdx: number;
    timeout: number;
    constructor(providers: PoolRepository[], options?: PoolsFallbackRepositoryOptions);
    fetch(options?: PoolsRepositoryFetchOptions): Promise<Pool$1[]>;
    get currentProvider(): PoolRepository | undefined;
    find(id: string): Promise<Pool$1 | undefined>;
    findBy(attribute: PoolAttribute, value: string): Promise<Pool$1 | undefined>;
    fallbackQuery(func: string, args: unknown[]): Promise<any>;
}

declare class PoolsStaticRepository implements Findable<Pool$1, PoolAttribute>, Searchable<Pool$1> {
    private pools;
    constructor(pools: Pool$1[]);
    find(id: string): Promise<Pool$1 | undefined>;
    findBy(attribute: PoolAttribute, value: string): Promise<Pool$1 | undefined>;
    all(): Promise<Pool$1[]>;
    where(filter: (pool: Pool$1) => boolean): Promise<Pool$1[]>;
}

interface PoolsSubgraphRepositoryOptions {
    url: string;
    chainId: Network;
    blockHeight?: () => Promise<number | undefined>;
    query?: GraphQLQuery;
}
/**
 * Access pools using generated subgraph client.
 *
 * Balancer's subgraph URL: https://thegraph.com/hosted-service/subgraph/balancer-labs/balancer-v2
 */
declare class PoolsSubgraphRepository implements Findable<Pool$1, PoolAttribute>, Searchable<Pool$1> {
    private client;
    private chainId;
    private pools?;
    skip: number;
    private blockHeight;
    private query;
    /**
     * Repository with optional lazy loaded blockHeight
     *
     * @param url subgraph URL
     * @param chainId current network, needed for L2s logic
     * @param blockHeight lazy loading blockHeigh resolver
     */
    constructor(options: PoolsSubgraphRepositoryOptions);
    /**
     * We need a list of all the pools, for calculating APRs (nested pools), and for SOR (path finding).
     * All the pools are fetched on page load and cachced for speedy lookups.
     *
     * @returns Promise resolving to pools list
     */
    private fetchAllPools;
    fetch(options?: PoolsRepositoryFetchOptions): Promise<Pool$1[]>;
    find(id: string): Promise<Pool$1 | undefined>;
    findBy(param: PoolAttribute, value: string): Promise<Pool$1 | undefined>;
    all(): Promise<Pool$1[]>;
    block(): Promise<{
        number: number | undefined;
    } | undefined>;
    where(filter: (pool: Pool$1) => boolean): Promise<Pool$1[]>;
}

interface PoolsSubgraphOnChainRepositoryOptions {
    provider: Provider;
    multicall: string;
    vault: string;
}
/**
 * Access pools using generated subgraph client and multicall.
 */
declare class PoolsSubgraphOnChainRepository implements Findable<Pool$1, PoolAttribute>, Searchable<Pool$1>, Cacheable<Pool$1> {
    private poolsSubgraph;
    private readonly poolsToIgnore;
    private batchSize?;
    private provider;
    private pools?;
    private multicall;
    private vault;
    skip: number;
    /**
     * Repository using multicall to get onchain data.
     *
     * @param poolsSubgraph subgraph repository
     * @param options options containing provider, multicall and vault addresses
     */
    constructor(poolsSubgraph: PoolsSubgraphRepository, options: PoolsSubgraphOnChainRepositoryOptions, poolsToIgnore: string[] | undefined, batchSize?: number | undefined);
    private filterPools;
    /**
     * We need a list of all the pools, for calculating APRs (nested pools), and for SOR (path finding).
     * All the pools are fetched on page load and cachced for speedy lookups.
     *
     * @returns Promise resolving to pools list
     */
    private fetchDefault;
    fetch(options?: PoolsRepositoryFetchOptions): Promise<Pool$1[]>;
    find(id: string, forceRefresh?: boolean): Promise<Pool$1 | undefined>;
    findBy(param: PoolAttribute, value: string, forceRefresh?: boolean): Promise<Pool$1 | undefined>;
    all(): Promise<Pool$1[]>;
    where(filter: (pool: Pool$1) => boolean): Promise<Pool$1[]>;
    refresh(pool: Pool$1): Promise<Pool$1>;
}

type GenericToken = SubgraphToken | PoolToken;
type GenericPool = Omit<SubgraphPoolBase | Pool$1, 'tokens'> & {
    tokens: GenericToken[];
};
interface OnchainData {
    poolTokens: [string[], string[]];
    totalShares: string;
    swapFee: string;
    isPaused?: boolean;
    inRecoveryMode?: boolean;
    rate?: string;
    scalingFactors?: string[];
    weights?: string[];
    targets?: [string, string];
    wrappedTokenRate?: string;
    amp?: [string, boolean, string];
    tokenRates?: [string, string];
}
declare const fetchOnChainPoolData: (pools: {
    id: string;
    address: string;
    poolType: string;
    poolTypeVersion?: number;
}[], vaultAddress: string, provider: Provider, batchSize?: number) => Promise<{
    [id: string]: OnchainData;
}>;
declare function getOnChainBalances<T extends GenericPool>(subgraphPoolsOriginal: T[], _multiAddress: string, vaultAddress: string, provider: Provider, batchSize?: number): Promise<T[]>;

declare class PoolGaugesRepository extends GaugesSubgraphRepository<PoolGauges, PoolGaugesAttributes> {
    query(args: any): Promise<PoolGauges[]>;
    mapType(fragment: any): PoolGauges;
}

declare enum PoolJoinExitAttributes {
    Pool = "pool",
    Sender = "sender"
}
interface PoolJoinExit {
    id: string;
    userAddress: string;
    poolId: string;
    timestamp: number;
    type: string;
    amounts: string[];
    tokens: string[];
}

declare class PoolJoinExitRepository extends BalancerSubgraphRepository<PoolJoinExit, PoolJoinExitAttributes> {
    query(args: any): Promise<PoolJoinExit[]>;
    mapType(item: SubgraphJoinExitFragment): PoolJoinExit;
    findByUser(sender: string, first?: number, skip?: number): Promise<PoolJoinExit[]>;
    findJoins(sender: string, pool: string): Promise<PoolJoinExit[]>;
    findExits(sender: string, pool: string): Promise<PoolJoinExit[]>;
    findByPool(poolId: string, first?: number, skip?: number): Promise<PoolJoinExit[]>;
}

declare class PoolSharesRepository extends BalancerSubgraphRepository<PoolShare, PoolShareAttributes> {
    query(args: any): Promise<PoolShare[]>;
    mapType(subgraphPoolShare: SubgraphPoolShareFragment): PoolShare;
    findByUser(userAddress: string, first?: number, skip?: number): Promise<PoolShare[]>;
    findByPool(poolId: string, first?: number, skip?: number): Promise<PoolShare[]>;
}

declare class StaticTokenProvider implements Findable<Token, TokenAttribute> {
    private tokens;
    constructor(tokens: Token[]);
    find(address: string): Promise<Token | undefined>;
    findBy(attribute: TokenAttribute, value: string): Promise<Token | undefined>;
}

declare class StaticTokenPriceProvider implements Findable<Price> {
    tokenPrices: TokenPrices$1;
    constructor(tokenPrices: TokenPrices$1);
    find(address: string): Promise<Price | undefined>;
    findBy(attribute: string, value: string): Promise<Price | undefined>;
}

declare class AssetHelpers {
    readonly ETH: string;
    readonly WETH: string;
    constructor(wethAddress: string);
    static isEqual: (addressA: string, addressB: string) => boolean;
    /**
     * Tests whether `token` is ETH (represented by `0x0000...0000`).
     *
     * @param token - the address of the asset to be checked
     */
    isETH: (token: string) => boolean;
    /**
     * Tests whether `token` is WETH.
     *
     * @param token - the address of the asset to be checked
     */
    isWETH: (token: string) => boolean;
    /**
     * Converts an asset to the equivalent ERC20 address.
     *
     * For ERC20s this will return the passed address but passing ETH (`0x0000...0000`) will return the WETH address
     * @param token - the address of the asset to be translated to an equivalent ERC20
     * @returns the address of translated ERC20 asset
     */
    translateToERC20: (token: string) => string;
    /**
     * Sorts an array of token addresses into ascending order to match the format expected by the Vault.
     *
     * Passing additional arrays will result in each being sorted to maintain relative ordering to token addresses.
     *
     * The zero address (representing ETH) is sorted as if it were the WETH address.
     * This matches the behaviour expected by the Vault when receiving an array of addresses.
     *
     * @param tokens - an array of token addresses to be sorted in ascending order
     * @param others - a set of arrays to be sorted in the same order as the tokens, e.g. token weights or asset manager addresses
     * @returns an array of the form `[tokens, ...others]` where each subarray has been sorted to maintain its ordering relative to `tokens`
     *
     * @example
     * const [tokens] = sortTokens([tokenB, tokenC, tokenA])
     * const [tokens, weights] = sortTokens([tokenB, tokenC, tokenA], [weightB, weightC, weightA])
     * // where tokens = [tokenA, tokenB, tokenC], weights = [weightA, weightB, weightC]
     */
    sortTokens(tokens: string[], ...others: unknown[][]): [string[], ...unknown[][]];
}

declare class BalancerErrors {
    /**
     * Cannot be constructed.
     */
    private constructor();
    static isErrorCode: (error: string) => boolean;
    /**
     * Decodes a Balancer error code into the corresponding reason
     * @param error - a Balancer error code of the form `BAL#000`
     * @returns The decoded error reason
     */
    static parseErrorCode: (error: string) => string;
    /**
     * Decodes a Balancer error code into the corresponding reason
     * @param error - a Balancer error code of the form `BAL#000`
     * @returns The decoded error reason if passed a valid error code, otherwise returns passed input
     */
    static tryParseErrorCode: (error: string) => string;
    /**
     * Tests whether a string is a known Balancer error message
     * @param error - a string to be checked verified as a Balancer error message
     */
    static isBalancerError: (error: string) => boolean;
    /**
     * Encodes an error string into the corresponding error code
     * @param error - a Balancer error message string
     * @returns a Balancer error code of the form `BAL#000`
     */
    static encodeError: (error: string) => string;
}

type Account = string | Signer$1 | Contract;
declare function accountToAddress(account: Account): Promise<string>;
declare enum RelayerAction {
    JoinPool = "JoinPool",
    ExitPool = "ExitPool",
    Swap = "Swap",
    BatchSwap = "BatchSwap",
    SetRelayerApproval = "SetRelayerApproval"
}
declare class RelayerAuthorization {
    /**
     * Cannot be constructed.
     */
    private constructor();
    static encodeCalldataAuthorization: (calldata: string, deadline: BigNumberish, signature: string) => string;
    static signJoinAuthorization: (validator: Contract, user: Signer$1 & TypedDataSigner, allowedSender: Account, allowedCalldata: string, deadline?: BigNumberish, nonce?: BigNumberish) => Promise<string>;
    static signExitAuthorization: (validator: Contract, user: Signer$1 & TypedDataSigner, allowedSender: Account, allowedCalldata: string, deadline?: BigNumberish, nonce?: BigNumberish) => Promise<string>;
    static signSwapAuthorization: (validator: Contract, user: Signer$1 & TypedDataSigner, allowedSender: Account, allowedCalldata: string, deadline?: BigNumberish, nonce?: BigNumberish) => Promise<string>;
    static signBatchSwapAuthorization: (validator: Contract, user: Signer$1 & TypedDataSigner, allowedSender: Account, allowedCalldata: string, deadline?: BigNumberish, nonce?: BigNumberish) => Promise<string>;
    static signSetRelayerApprovalAuthorization: (validator: Contract, user: Signer$1 & TypedDataSigner, allowedSender: Account, allowedCalldata: string, deadline?: BigNumberish, nonce?: BigNumberish) => Promise<string>;
    static signAuthorizationFor: (type: RelayerAction, validator: Contract, user: Signer$1 & TypedDataSigner, allowedSender: Account, allowedCalldata: string, deadline?: BigNumberish, nonce?: BigNumberish) => Promise<string>;
}
declare class BalancerMinterAuthorization {
    /**
     * Cannot be constructed.
     */
    private constructor();
    static signSetMinterApproval: (minterContract: Contract, minter: Account, approval: boolean, user: Signer$1 & TypedDataSigner, deadline?: BigNumberish, nonce?: BigNumberish) => Promise<{
        v: number;
        r: string;
        s: string;
        deadline: BigNumber;
    }>;
}

declare const signPermit: (token: Contract, owner: Signer$1 & TypedDataSigner, spender: Account, amount: BigNumberish, deadline?: BigNumberish, nonce?: BigNumberish) => Promise<{
    v: number;
    r: string;
    s: string;
    deadline: BigNumber;
    nonce: BigNumber;
}>;

declare const AMP_PRECISION = 3;
type ParsedPoolInfo = {
    bptIndex: number;
    higherBalanceTokenIndex: number;
    ampWithPrecision: bigint;
    balancesEvm: bigint[];
    balancesEvmWithoutBpt: bigint[];
    priceRates: bigint[];
    priceRatesWithoutBpt: bigint[];
    swapFeeEvm: bigint;
    poolTokens: string[];
    poolTokensWithoutBpt: string[];
    weights: bigint[];
    scalingFactors: bigint[];
    scalingFactorsWithoutBpt: bigint[];
    scalingFactorsRaw: bigint[];
    scalingFactorsRawWithoutBpt: bigint[];
    upScaledBalances: bigint[];
    upScaledBalancesWithoutBpt: bigint[];
    totalSharesEvm: bigint;
};
/**
 * Parse pool info into EVM amounts. Sorts by token order if wrappedNativeAsset param passed.
 * @param pool Pool object to be parsed
 * @param wrappedNativeAsset e.g. wETH address
 * @param unwrapNativeAsset if true, changes wETH address to ETH address
 * @returns parsed pool info
 */
declare const parsePoolInfo: (pool: Pool$1, wrappedNativeAsset?: string, unwrapNativeAsset?: boolean) => ParsedPoolInfo;

declare function tokensToTokenPrices(tokens: Token[]): TokenPrices$1;
declare function tokenAddressForPricing(address: string, chainId: Network): string;
/**
 * Maps testnet tokens, eg: on GÃ¶reli to a mainnet one.
 * Used to get the pricing information on networks not supported by a price feed.
 *
 * @param address Address on a testnet network
 */
declare const addressMapIn: (address: string, chainId: Network) => string;
/**
 * Finds an underlying token address for a wrapped one
 *
 * @param wrappedAddress
 * @param chainId
 * @returns underlying token address
 */
declare const unwrapToken: (wrappedAddress: string, chainId: Network) => string;
declare const getEthValue: (tokens: string[], amounts: string[]) => BigNumber;

/**
 * Debouncer for different attributes requested over time, which need to be aggregated into a single resolving call
 *
 * Choosing deferred promise since we have setTimeout that returns a promise
 * Some reference for history buffs: https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns
 */
interface Promised<T> {
    promise: Promise<T>;
    resolve: (value: T) => void;
    reject: (reason: unknown) => void;
}
/**
 * Aggregates attributes and exectutes a debounced call
 *
 * @param fn Function to debounce
 * @param wait Debouncing waiting time [ms]
 * @param limit Maximum number of attributes to execute in one promise
 * @returns Debouncer instance
 */
declare class Debouncer<T, A> {
    private fn;
    private wait;
    private limit;
    requestSets: Set<A>[];
    promisedCalls: Promised<T>[];
    promisedCount: number;
    timeout?: ReturnType<typeof setTimeout>;
    debounceCancel: () => void;
    constructor(fn: (attrs: A[]) => Promise<T>, wait?: number, limit?: number);
    fetch(attr?: A): Promise<T>;
    execute(timeout?: number): Promise<T>;
}

/**
 * Scales a number up by 10 ^ decimals. Also ensures the returned value is an
 * integer, any additional decimals post scaling are removed.
 * @param value The value to be scaled up
 * @param decimals The total decimal places / order of magnitude to scale by
 * @returns The scaled value
 */
declare function parseFixed(value: string, decimals?: BigNumberish): BigNumber;
/**
 * Scales a number down by 10 ^ decimals. Also ensures the returned value doesn't
 * have a .0 at the end, so integers are returned as integers.
 * @param value The value to be scaled down
 * @param decimals The total decimal places / order of magnitude to scale down by
 * @returns The scaled value
 */
declare function formatFixed(value: BigNumberish, decimals: BigNumberish): string;
declare function parseToBigInt18(value: string): bigint;
declare function formatFromBigInt18(value: bigint): string;
/**
 * Like parseEther but for numbers. Converts floating point to BigNumber using 18 decimals
 */
declare const bn: (value: number) => BigNumber;

/**
 * Multiplies input by slippage amount
 *
 * @param amount Input amount (not parsed)
 * @param slippage Slippage value in bps - i.e. 50 = 0.5%
 * @returns Result delta from multiplying amount and slippage
 */
declare const mulSlippage: (amount: BigNumber, slippage: BigNumber) => BigNumber;
/**
 * Reduce input amount by slippage factor
 *
 * @param amount Input in EVM amounts
 * @param slippage Slippage value in bps - i.e. 50 = 0.5%
 * @returns Result amount subtracting slippage
 */
declare const subSlippage: (amount: BigNumber, slippage: BigNumber) => BigNumber;
/**
 * Increase input amount by slippage factor
 *
 * @param amount Input in EVM amounts
 * @param slippage Slippage value in bps - i.e. 50 = 0.5%
 * @returns Result amount adding slippage
 */
declare const addSlippage: (amount: BigNumber, slippage: BigNumber) => BigNumber;

declare const isSameAddress: (address1: string, address2: string) => boolean;
declare function insert<T>(arr: T[], index: number, newItem: T): T[];
/**
 * Returns a new array with item on the specified index replaced by newItem
 * @param arr
 * @param index
 * @param newItem
 */
declare function replace<T>(arr: T[], index: number, newItem: T): T[];
/**
 * Removes item from array at specified index and returns new array. (Does not mutate original)
 * @param arr Original array
 * @param index Index of item to be removed
 * @returns New array with item at index removed
 */
declare function removeItem<T>(arr: T[], index: number): T[];
/**
 * REORDER ARRAYS USING A REFERENCE AND ORIGINAL ARRAY,
 * Example:
 * Input -> reference: [c,b,a], original: [a,b,c], others: [[1,2,3], [4,5,6]]
 * Sorts like -> [[c,b,a],[3,2,1],[6,5,4]]
 * Returns -> [6,5,4]
 * @param reference
 * @param original
 * @param others
 * @returns Sorted others
 */
declare function reorderArrays<T>(reference: T[], original: T[], ...others: unknown[][]): unknown[][];
declare function isLinearish(poolType: string): boolean;
declare function truncateAddresses(addresses: string[]): string[];
declare const findEventInReceiptLogs: ({ receipt, to, contractInterface, logName, }: {
    receipt: TransactionReceipt;
    to: Address;
    contractInterface: Interface;
    logName: string;
}) => LogDescription;
declare const getRandomBytes32: () => string;

/**
 * Simple coingecko price source implementation. Configurable by network and token addresses.
 */
declare class CoingeckoPriceRepository implements Findable<Price> {
    private chainId;
    prices: {
        [key: string]: Promise<Price>;
    };
    nativePrice?: Promise<Price>;
    private readonly url;
    private readonly urlNative;
    private readonly coingeckoApiKeyHeaderName;
    baseTokenAddresses: string[];
    debouncer: Debouncer<TokenPrices$1, string>;
    apiKey?: string;
    constructor(tokenAddresses: string[], chainId?: Network, coingecko?: CoingeckoConfig);
    private fetch;
    private fetchNative;
    find(inputAddress: string): Promise<Price | undefined>;
    findBy(attribute: string, value: string): Promise<Price | undefined>;
    private platform;
}

/**
 * Simple coingecko price source implementation. Configurable by network and token addresses.
 */
declare class CoingeckoHistoricalPriceRepository implements Findable<Price> {
    private chainId;
    prices: TokenPrices$1;
    nativePrice?: Promise<Price>;
    private readonly urlBase;
    private readonly apiKey?;
    private readonly coingeckoApiKeyHeaderName;
    constructor(chainId?: Network, coingecko?: CoingeckoConfig);
    private fetch;
    find(address: string): Promise<Price | undefined>;
    findBy(inputAddress: string, timestamp: number): Promise<Price | undefined>;
    private platform;
    private urlRange;
}

declare class SubgraphPriceRepository implements Findable<Price> {
    private subgraphUrl;
    private chainId;
    prices: {
        [key: string]: Promise<Price>;
    };
    debouncer: Debouncer<TokenPrices$1, string>;
    constructor(subgraphUrl: string, chainId?: Network);
    private fetch;
    find(inputAddress: string): Promise<Price | undefined>;
    findBy(attribute: string, value: string): Promise<Price | undefined>;
}

declare const yieldTokens: {
    1: {
        waUSDT: string;
        waUSDC: string;
        waDAI: string;
    };
    137: {
        wamDAI: string;
        wamUSDC: string;
        wamUSDT: string;
    };
};
declare const wrappedTokensMap: {
    1: {
        [x: string]: {
            aToken: string;
            underlying: string;
        };
    };
    137: {
        [x: string]: {
            aToken: string;
            underlying: string;
        };
    };
};
interface IAaveRates {
    getRate: (address: string) => Promise<number>;
}
declare class AaveRates implements IAaveRates {
    private multicall;
    private network;
    rates?: Promise<{
        [wrappedATokenAddress: string]: number;
    }>;
    constructor(multicall: Multicall, network: Network);
    private fetch;
    getRate(wrappedAToken: string): Promise<number>;
}

declare class TokenPriceProvider implements Findable<Price> {
    private coingeckoRepository;
    private subgraphRepository;
    private aaveRates;
    constructor(coingeckoRepository: Findable<Price>, subgraphRepository: Findable<Price>, aaveRates: IAaveRates);
    find(address: string): Promise<Price | undefined>;
    findBy(attribute: string, value: string): Promise<Price | undefined>;
}

declare class HistoricalPriceProvider implements Findable<Price> {
    private coingeckoRepository;
    private aaveRates;
    constructor(coingeckoRepository: Findable<Price>, aaveRates: IAaveRates);
    /**
     * get the historical price at time of call
     *
     * @param address the token address
     */
    find(address: string): Promise<Price | undefined>;
    /**
     * get the historical price at the given timestamp.
     *
     * @param address the token address
     * @param timestamp the UNIX timestamp
     * @private
     */
    findBy(address: string, timestamp: number): Promise<Price | undefined>;
}

declare const APR_THRESHOLD = 10000;
/**
 * For proportional exits from ComposableStable pools the ExactBPTInForTokensOut
 * exit type was removed. Therefore we have to use BPTInForExactTokensOut which
 * makes proportional exits using a user's total BPT balance impossible. In
 * order to 'fix' this we need to subtract a little bit from the bptIn value
 * when calculating the ExactTokensOut. The variable below is that "little bit".
 */
declare const SHALLOW_COMPOSABLE_STABLE_BUFFER = 1000000;
type FactoryType = 'oracleWeightedPool' | 'weightedPool' | 'stablePool' | 'managedPool' | 'liquidityBootstrappingPool' | 'boostedPool' | 'composableStablePool';
type PoolMetadata = {
    name: string;
    hasIcon: boolean;
};
type NamedPools = {
    staBAL: string;
    bbAaveUSD: {
        v1: string;
        v2: string;
    };
    xMatic: {
        v1: string;
        v2: string;
    };
    stMatic: {
        v1: string;
        v2: string;
    };
    mai4: {
        mai4: string;
        maiBbaUsd: string;
    };
    veBAL: string;
};
type Pools$1 = {
    IdsMap: Partial<NamedPools>;
    Pagination: {
        PerPage: number;
        PerPool: number;
        PerPoolInitial: number;
    };
    DelegateOwner: string;
    ZeroAddress: string;
    DynamicFees: {
        Gauntlet: string[];
    };
    BlockList: string[];
    ExcludedPoolTypes: string[];
    Stable: {
        AllowList: string[];
    };
    Investment: {
        AllowList: string[];
    };
    Factories: Record<string, FactoryType>;
    Stakable: {
        AllowList: string[];
    };
    Metadata: Record<string, PoolMetadata>;
};
declare function POOLS(networkId: Network): Pools$1;

interface TransactionData$1 {
    to: string;
    from: string;
    callData: string;
    tokensOut: string[];
    expectedTokensValue: BigNumber[];
    functionName: string;
}
interface TokenBalance {
    [token: string]: BigNumber;
}
interface IClaimService {
    getClaimableRewardTokens(userAddress: string): Promise<LiquidityGauge[]>;
    buildClaimRewardTokensRequest(gaugeAddresses: string[], userAddress: string): Promise<TransactionData$1>;
    getClaimableVeBalTokens(userAddress: string, claimableTokens: string[]): Promise<TokenBalance>;
    buildClaimVeBalTokensRequest(userAddress: string, claimableTokens: string[]): Promise<TransactionData$1>;
}

interface FeeDistributorData {
    balAmount: number;
    bbAUsdAmount: number;
    veBalSupply: number;
    bbAUsdPrice: number;
    balAddress: string;
}
interface BaseFeeDistributor {
    multicallData: (ts: number) => Promise<FeeDistributorData>;
    getClaimableBalances(userAddress: string, claimableTokens: string[]): Promise<TokenBalance>;
    claimBalances(userAddress: string, claimableTokens: string[]): string;
}
declare class FeeDistributorRepository implements BaseFeeDistributor {
    private multicall;
    private feeDistributorAddress;
    private balAddress;
    private veBalAddress;
    private bbAUsdAddress;
    feeDistributor: Contract;
    data?: FeeDistributorData;
    constructor(multicall: Multicall, feeDistributorAddress: string, balAddress: string, veBalAddress: string, bbAUsdAddress: string, provider: Provider);
    fetch(timestamp: number): Promise<FeeDistributorData>;
    multicallData(timestamp: number): Promise<FeeDistributorData>;
    getPreviousWeek(fromTimestamp: number): number;
    getClaimableBalances(userAddress: string, claimableTokens: string[]): Promise<TokenBalance>;
    claimBalances(userAddress: string, claimableTokens: string[]): string;
    extractTokenBalance(claimableTokens: string[], amounts: (BigNumber | undefined | null)[]): TokenBalance;
}

declare class FeeCollectorRepository implements Findable<number> {
    private provider;
    vault: Contract;
    swapFeePercentage?: number;
    constructor(vaultAddress: string, provider: Provider);
    fetch(): Promise<number>;
    find(): Promise<number>;
    findBy(): Promise<number>;
}

declare class TokenYieldsRepository implements Findable<number> {
    private url;
    private yields?;
    constructor(url?: string);
    fetch(): Promise<{
        [address: string]: number;
    }>;
    find(address: string): Promise<number>;
    findBy(attribute: string, value: string): Promise<number>;
}

declare class BlockNumberRepository implements Findable<number> {
    private endpoint;
    blocks: {
        [ts: string]: Promise<number>;
    };
    constructor(endpoint: string);
    find(from: string): Promise<number | undefined>;
    findBy(attribute?: string, value?: string): Promise<number | undefined>;
}

type GraphQLFilterOperator = 'gt' | 'lt' | 'eq' | 'in' | 'not_in' | 'contains';
type GraphQLFilter = {
    [operator in GraphQLFilterOperator]?: any;
};
interface GraphQLArgs {
    chainId?: number;
    first?: number;
    skip?: number;
    nextToken?: string;
    orderBy?: string;
    orderDirection?: string;
    block?: {
        number?: number;
    };
    where?: Record<string, GraphQLFilter>;
}
interface GraphQLArgsFormatter {
    format(args: GraphQLArgs): unknown;
}

declare class SubgraphPoolDataService implements PoolDataService {
    private readonly client;
    private readonly provider;
    private readonly network;
    private readonly sorConfig?;
    private readonly defaultArgs;
    constructor(client: SubgraphClient, provider: Provider, network: BalancerNetworkConfig, sorConfig?: BalancerSdkSorConfig | undefined, query?: GraphQLQuery);
    /**
     * Returns pools from the subgraph filtered by queryArgs with on-chain balances
     *
     * @param queryArgs
     * @returns SubgraphPoolBase[]
     */
    getPools(queryArgs?: GraphQLArgs): Promise<SubgraphPoolBase[]>;
    private getSubgraphPools;
}

type VeBalLockInfo = {
    lockedEndDate: number;
    lockedAmount: string;
    totalSupply: string;
    epoch: string;
    hasExistingLock: boolean;
    isExpired: boolean;
};
type VeBalLockInfoResult = {
    locked: BigNumber[];
    epoch: BigNumber;
    totalSupply: BigNumber;
};
declare class VeBal {
    private veBalAddress;
    private multicall;
    constructor(veBalAddress: string, multicall: Multicall);
    getLockInfo(account: string): Promise<VeBalLockInfo | undefined>;
    formatLockInfo(lockInfo: VeBalLockInfoResult): VeBalLockInfo;
}

declare class VeBalProxy {
    instance: Contract;
    constructor(addresses: ContractAddresses, provider: Provider);
    getAdjustedBalance(account: string): Promise<string>;
}

type ContractFactory = (address: string, signerOrProvider: Signer$1 | Provider) => Contract;
interface ContractInstances {
    aaveLinearPoolFactory?: AaveLinearPoolFactory;
    balancerHelpers: BalancerHelpers;
    BasePool: ContractFactory;
    composableStablePoolFactory?: ComposableStablePoolFactory;
    ERC20: ContractFactory;
    erc4626LinearPoolFactory?: ERC4626LinearPoolFactory;
    eulerLinearPoolFactory?: EulerLinearPoolFactory;
    gaugeClaimHelper?: GaugeClaimHelper;
    gearboxLinearPoolFactory?: GearboxLinearPoolFactory;
    gyroConfig?: GyroConfig;
    lidoRelayer?: LidoRelayer;
    liquidityGauge: ContractFactory;
    multicall: Multicall;
    relayer: Contract;
    vault: Vault;
    veBal?: VeBal;
    veBalProxy?: VeBalProxy;
    weightedPoolFactory?: WeightedPoolFactory;
    yearnLinearPoolFactory?: YearnLinearPoolFactory;
}
declare class Contracts {
    contractAddresses: ContractAddresses;
    private instances;
    /**
     * Create instances of Balancer contracts connected to passed provider.
     * @param { Network | ContractAddresses } networkOrAddresses
     * @param { Provider } provider
     */
    constructor(networkOrAddresses: Network | ContractAddresses, provider: Provider);
    /**
     * Expose contract instances.
     */
    get contracts(): ContractInstances;
    /**
     * Helper to create ERC20 contract.
     * @param { string } address ERC20 address.
     * @param { Signer | Provider } signerOrProvider Signer or Provider.
     * @returns Contract.
     */
    getErc20(address: string, signerOrProvider: Signer$1 | Provider): ERC20;
    /**
     * Helper to create base pool contract.
     * @param { string } address pool address.
     * @param { Signer | Provider } signerOrProvider Signer or Provider.
     * @returns Contract.
     */
    getBasePool(address: string, signerOrProvider: Signer$1 | Provider): Contract;
    /**
     * Helper to create LiquidityGauge contract.
     * @param { string } address Gauge address.
     * @param { Signer | Provider} signerOrProvider Signer or Provider.
     * @returns Contract.
     */
    getLiquidityGauge: typeof LiquidityGaugeV5__factory.connect;
}

declare class Data implements BalancerDataRepositories {
    pools: PoolsSubgraphRepository;
    poolsForSimulations: SubgraphPoolDataService;
    poolsOnChain: PoolsSubgraphOnChainRepository;
    yesterdaysPools: PoolsSubgraphRepository | undefined;
    poolShares: PoolSharesRepository;
    poolGauges: PoolGaugesRepository | undefined;
    gaugeShares: GaugeSharesRepository | undefined;
    tokenPrices: TokenPriceProvider;
    tokenHistoricalPrices: HistoricalPriceProvider;
    tokenMeta: StaticTokenProvider;
    liquidityGauges: LiquidityGaugeSubgraphRPCProvider | undefined;
    feeDistributor: FeeDistributorRepository | undefined;
    feeCollector: FeeCollectorRepository;
    protocolFees: ProtocolFeesProvider | undefined;
    tokenYields: TokenYieldsRepository;
    blockNumbers: BlockNumberRepository | undefined;
    poolJoinExits: PoolJoinExitRepository;
    gyroConfigRepository: GyroConfigRepositoryImpl | undefined;
    constructor(networkConfig: BalancerNetworkConfig, provider: Provider, contracts: Contracts, subgraphQuery?: GraphQLQuery, coingecko?: CoingeckoConfig);
}

declare class BalancerAPIArgsFormatter implements GraphQLArgsFormatter {
    format(args: GraphQLArgs): GraphQLArgs;
}

declare class SubgraphArgsFormatter implements GraphQLArgsFormatter {
    operatorMap: Record<string, string>;
    constructor();
    format(args: GraphQLArgs): GraphQLArgs;
}

declare class GraphQLArgsBuilder {
    readonly args: GraphQLArgs;
    constructor(args: GraphQLArgs);
    merge(other: GraphQLArgsBuilder): GraphQLArgsBuilder;
    format(formatter: GraphQLArgsFormatter): unknown;
}

interface AprBreakdown {
    swapFees: number;
    tokenAprs: {
        total: number;
        breakdown: {
            [address: string]: number;
        };
    };
    stakingApr: {
        min: number;
        max: number;
    };
    rewardAprs: {
        total: number;
        breakdown: {
            [address: string]: number;
        };
    };
    protocolApr: number;
    min: number;
    max: number;
}
/**
 * Calculates pool APR via summing up sources of APR:
 *
 * 1. Swap fees (pool level) data coming from subgraph
 * 2. Yield bearing pool tokens, with data from external sources eg: http endpoints, subgraph, onchain
 *    * stETH
 *    * aave
 *    * usd+
 *    map token: calculatorFn
 * 3. Staking rewards based from veBal gauges
 */
declare class PoolApr {
    private pools;
    private tokenPrices;
    private tokenMeta;
    private tokenYields;
    private feeCollector;
    private yesterdaysPools?;
    private liquidityGauges?;
    private feeDistributor?;
    private gyroConfigRepository?;
    constructor(pools: Findable<Pool$1, PoolAttribute>, tokenPrices: Findable<Price>, tokenMeta: Findable<Token, TokenAttribute>, tokenYields: Findable<number>, feeCollector: Findable<number>, yesterdaysPools?: Findable<Pool$1, PoolAttribute, any> | undefined, liquidityGauges?: Findable<LiquidityGauge, string, any> | undefined, feeDistributor?: BaseFeeDistributor | undefined, gyroConfigRepository?: GyroConfigRepository | undefined);
    /**
     * Pool revenue via swap fees.
     * Fees and liquidity are takes from subgraph as USD floats.
     *
     * @returns APR [bsp] from fees accumulated over last 24h
     */
    swapFees(pool: Pool$1): Promise<number>;
    /**
     * Pool revenue from holding yield-bearing wrapped tokens.
     *
     * @returns APR [bsp] from tokens contained in the pool
     */
    tokenAprs(pool: Pool$1): Promise<AprBreakdown['tokenAprs']>;
    /**
     * Calculates staking rewards based on veBal gauges deployed with Curve Finance contracts.
     * https://curve.readthedocs.io/dao-gauges.html
     *
     * Terminology:
     *  - LP token of a gauge is a BPT of a pool
     *  - Depositing into a gauge is called staking on the frontend
     *  - gauge totalSupply - BPT tokens deposited to a gauge
     *  - gauge workingSupply - effective BPT tokens participating in reward distribution. sum of 40% deposit + 60% boost from individual user's veBal
     *  - gauge relative weight - weight of this gauge in bal inflation distribution [0..1] scaled to 1e18
     *
     * APR sources:
     *  - gauge BAL emissions = min: 40% of totalSupply, max: 40% of totalSupply + 60% of totalSupply * gauge LPs voting power
     *    https://github.com/balancer-labs/balancer-v2-monorepo/blob/master/pkg/liquidity-mining/contracts/gauges/ethereum/LiquidityGaugeV5.vy#L338
     *  - gauge reward tokens: Admin or designated depositor has an option to deposit additional reward with a weekly accruing cadence.
     *    https://github.com/balancer-labs/balancer-v2-monorepo/blob/master/pkg/liquidity-mining/contracts/gauges/ethereum/LiquidityGaugeV5.vy#L641
     *    rate: amount of token per second
     *
     * @param pool
     * @param boost range between 1 and 2.5
     * @returns APR [bsp] from protocol rewards.
     */
    stakingApr(pool: Pool$1, boost?: number): Promise<number>;
    /**
     * Some gauges are holding tokens distributed as rewards to LPs.
     *
     * @param pool
     * @returns APR [bsp] from token rewards.
     */
    rewardAprs(pool: Pool$1): Promise<AprBreakdown['rewardAprs']>;
    /**
     * 80BAL-20WETH pool is accruing protocol revenue.
     *
     * @param pool
     * @returns accrued protocol revenue as APR [bsp]
     */
    protocolApr(pool: Pool$1): Promise<number>;
    /**
     * Composes all sources for total pool APR.
     *
     * @returns pool APR split [bsp]
     */
    apr(pool: Pool$1): Promise<AprBreakdown>;
    private last24hFees;
    /**
     * Total Liquidity based on USD token prices taken from external price feed, eg: coingecko.
     *
     * @param pool
     * @returns Pool liquidity in USD
     */
    private totalLiquidity;
    /**
     * BPT price as pool totalLiquidity / pool total Shares
     * Total Liquidity is calculated based on USD token prices taken from external price feed, eg: coingecko.
     *
     * @param pool
     * @returns BPT price in USD
     */
    private bptPrice;
    private protocolSwapFeePercentage;
    private rewardTokenApr;
}

interface ParamsBuilder {
    buildQueryJoinExactIn(params: JoinExactInParams): queryJoinParams;
    buildQueryJoinExactOut(params: JoinExactOutParams): queryJoinParams;
    buildQueryExitToSingleToken(params: ExitToSingleTokenParams): queryExitParams;
    buildQueryExitProportionally(params: ExitProportionallyParams): queryExitParams;
    buildQueryExitExactOut(params: ExitExactOutParams): queryExitParams;
}
interface JoinExactInParams {
    maxAmountsInByToken: Map<string, BigNumber>;
    minimumBPT?: BigNumber;
}
interface JoinExactOutParams {
    maxAmountIn?: BigNumber;
    bptOut: BigNumber;
    tokenIn: string;
}
interface ExitToSingleTokenParams {
    minAmountOut?: BigNumber;
    bptIn: BigNumber;
    tokenOut: string;
}
interface ExitProportionallyParams {
    minAmountsOut?: BigNumber[];
    bptIn: BigNumber;
}
interface ExitExactOutParams {
    minAmountsOut: BigNumber[];
    tokensOut: string[];
    maxBptIn?: BigNumber;
}
type queryJoinParams = [
    poolId: string,
    sender: string,
    recipient: string,
    request: {
        assets: string[];
        maxAmountsIn: BigNumber[];
        userData: string;
        fromInternalBalance: boolean;
    }
];
type queryExitParams = [
    poolId: string,
    sender: string,
    recipient: string,
    request: {
        assets: string[];
        minAmountsOut: BigNumber[];
        userData: string;
        toInternalBalance: boolean;
    }
];

type Address = string;
interface BalancerSdkConfig {
    network: Network | BalancerNetworkConfig;
    rpcUrl: string;
    customSubgraphUrl?: string;
    subgraphQuery?: GraphQLQuery;
    sor?: Partial<BalancerSdkSorConfig>;
    tenderly?: BalancerTenderlyConfig;
    enableLogging?: boolean;
    coingecko?: CoingeckoConfig;
}
interface BalancerTenderlyConfig {
    accessKey: string;
    user: string;
    project: string;
    blockNumber?: number;
}
interface BalancerSdkSorConfig {
    tokenPriceService: 'api' | 'coingecko' | 'subgraph' | TokenPriceService;
    poolDataService: 'subgraph' | PoolDataService;
    fetchOnChainBalances: boolean;
}
interface ContractAddresses {
    vault: string;
    multicall: string;
    poolDataQueries: string;
    gaugeClaimHelper?: string;
    balancerHelpers: string;
    balancerMinter?: string;
    lidoRelayer?: string;
    balancerRelayer: string;
    gaugeController?: string;
    feeDistributor?: string;
    veBal?: string;
    veBalProxy?: string;
    protocolFeePercentagesProvider?: string;
    weightedPoolFactory?: string;
    composableStablePoolFactory?: string;
    aaveLinearPoolFactory?: string;
    erc4626LinearPoolFactory?: string;
    eulerLinearPoolFactory?: string;
    gearboxLinearPoolFactory?: string;
    yearnLinearPoolFactory?: string;
    [key: string]: string | undefined;
}
interface BalancerNetworkConfig {
    chainId: Network;
    addresses: {
        contracts: ContractAddresses;
        tokens: {
            wrappedNativeAsset: string;
            lbpRaisingTokens?: string[];
            stETH?: string;
            wstETH?: string;
            bal: string;
            veBal?: string;
            bbaUsd?: string;
        };
    };
    tenderly?: BalancerTenderlyConfig;
    urls: {
        subgraph: string;
        gaugesSubgraph?: string;
        blockNumberSubgraph?: string;
    };
    thirdParty: {
        coingecko: {
            nativeAssetId: string;
            platformId: string;
        };
    };
    averageBlockTime?: number;
    multicallBatchSize?: number;
    pools: {
        wETHwstETH?: PoolReference;
    };
    poolsToIgnore?: string[];
    sorConnectingTokens?: {
        symbol: string;
        address: string;
    }[];
    sorTriPathMidPoolIds?: string[];
}
interface BalancerDataRepositories {
    feeDistributor?: BaseFeeDistributor;
    feeCollector: Findable<number>;
    gaugeShares?: GaugeSharesRepository;
    gyroConfigRepository?: GyroConfigRepository;
    liquidityGauges?: Findable<LiquidityGauge>;
    protocolFees?: ProtocolFeesProvider;
    /**
     * Why do we need 3 different pools repositories?
     */
    pools: Findable<Pool$1, PoolAttribute> & Searchable<Pool$1>;
    poolsForSimulations: SubgraphPoolDataService;
    poolGauges?: PoolGaugesRepository;
    poolJoinExits: PoolJoinExitRepository;
    poolsOnChain: Findable<Pool$1, PoolAttribute> & Searchable<Pool$1> & Cacheable<Pool$1>;
    poolShares: PoolSharesRepository;
    tokenHistoricalPrices: Findable<Price>;
    tokenMeta: Findable<Token, TokenAttribute>;
    tokenPrices: Findable<Price>;
    tokenYields: Findable<number>;
    yesterdaysPools?: Findable<Pool$1, PoolAttribute> & Searchable<Pool$1>;
}
type PoolReference = {
    id: string;
    address: string;
};
declare enum PoolSpecialization {
    GeneralPool = 0,
    MinimalSwapInfoPool = 1,
    TwoTokenPool = 2
}
type JoinPoolRequest$1 = {
    assets: string[];
    maxAmountsIn: BigNumberish[];
    userData: string;
    fromInternalBalance: boolean;
};
type ExitPoolRequest$1 = {
    assets: string[];
    minAmountsOut: string[];
    userData: string;
    toInternalBalance: boolean;
};
declare enum UserBalanceOpKind {
    DepositInternal = 0,
    WithdrawInternal = 1,
    TransferInternal = 2,
    TransferExternal = 3
}
type UserBalanceOp = {
    kind: UserBalanceOpKind;
    asset: string;
    amount: BigNumberish;
    sender: string;
    recipient: string;
};
declare enum PoolBalanceOpKind {
    Withdraw = 0,
    Deposit = 1,
    Update = 2
}
type PoolBalanceOp = {
    kind: PoolBalanceOpKind;
    poolId: string;
    token: string;
    amount: BigNumberish;
};
interface TransactionData {
    contract?: Contract;
    function: string;
    params: string[];
    outputs?: {
        amountsIn?: string[];
        amountsOut?: string[];
    };
}
type Currency = 'eth' | 'usd';
type Price = {
    [currency in Currency]?: string;
};
type TokenPrices$1 = {
    [address: string]: Price;
};
type HistoricalPrices = {
    prices: [[number, number]];
    market_caps: [[number, number]];
    total_volumes: [[number, number]];
};
interface Token {
    address: string;
    decimals?: number;
    symbol?: string;
    price?: Price;
}
interface PoolToken extends Token {
    balance: string;
    priceRate?: string;
    weight?: string | null;
    isExemptFromYieldProtocolFee?: boolean;
    token?: SubPoolMeta;
}
interface SubPoolMeta {
    pool: SubPool | null;
    latestUSDPrice?: string;
    latestFXPrice?: string;
}
interface SubPool {
    id: string;
    address: string;
    poolType: PoolType;
    totalShares: string;
    mainIndex: number;
    tokens?: PoolToken[];
}
interface OnchainTokenData {
    balance: string;
    weight: number;
    decimals: number;
    logoURI: string | undefined;
    name: string;
    symbol: string;
}
interface OnchainPoolData {
    tokens: Record<Address, OnchainTokenData>;
    totalSupply: string;
    decimals: number;
    swapFee: string;
    amp?: string;
    swapEnabled: boolean;
    tokenRates?: string[];
}
declare enum PoolType {
    Weighted = "Weighted",
    Investment = "Investment",
    Stable = "Stable",
    ComposableStable = "ComposableStable",
    MetaStable = "MetaStable",
    StablePhantom = "StablePhantom",
    LiquidityBootstrapping = "LiquidityBootstrapping",
    Element = "Element",
    Gyro2 = "Gyro2",
    Gyro3 = "Gyro3",
    GyroE = "GyroE",
    Managed = "Managed",
    AaveLinear = "AaveLinear",
    Linear = "Linear",
    EulerLinear = "EulerLinear",
    ERC4626Linear = "ERC4626Linear",
    BeefyLinear = "BeefyLinear",
    GearboxLinear = "GearboxLinear",
    MidasLinear = "MidasLinear",
    ReaperLinear = "ReaperLinear",
    SiloLinear = "SiloLinear",
    TetuLinear = "TetuLinear",
    YearnLinear = "YearnLinear",
    FX = "FX"
}
interface Pool$1 {
    id: string;
    name: string;
    address: string;
    chainId: number;
    poolType: PoolType;
    poolTypeVersion: number;
    swapFee: string;
    protocolYieldFeeCache: string;
    protocolSwapFeeCache: string;
    owner?: string;
    factory?: string;
    tokens: PoolToken[];
    tokensList: string[];
    tokenAddresses?: string[];
    totalLiquidity: string;
    totalShares: string;
    totalSwapFee?: string;
    totalSwapVolume?: string;
    onchain?: OnchainPoolData;
    createTime?: number;
    mainTokens?: string[];
    wrappedTokens?: string[];
    unwrappedTokens?: string[];
    isNew?: boolean;
    volumeSnapshot?: string;
    feesSnapshot?: string;
    boost?: string;
    symbol?: string;
    swapEnabled: boolean;
    amp?: string;
    wrappedIndex?: number;
    mainIndex?: number;
    apr?: AprBreakdown;
    liquidity?: string;
    totalWeight: string;
    lowerTarget: string;
    upperTarget: string;
    priceRateProviders?: PriceRateProvider[];
    lastJoinExitInvariant?: string;
    isInRecoveryMode?: boolean;
    isPaused?: boolean;
    tokenRates?: string[];
}
interface PriceRateProvider {
    address: string;
    token: {
        address: string;
    };
}
/**
 * Pool use-cases / controller layer
 */
interface PoolWithMethods extends Pool$1, ParamsBuilder {
    /**
     * Build join pool transaction parameters with exact tokens in and minimum BPT out based on slippage tolerance
     * @param joiner Account address joining pool
     * @param tokensIn Token addresses provided for joining pool (same length and order as amountsIn)
     * @param amountsIn Token amounts provided for joining pool in EVM scale
     * @param slippage Maximum slippage tolerance in bps i.e. 50 = 0.5%
     * @returns transaction request ready to send with signer.sendTransaction
     */
    buildJoin: (joiner: string, tokensIn: string[], amountsIn: string[], slippage: string) => JoinPoolAttributes;
    /**
     * Calculate price impact of bptAmount against zero price impact BPT amount.
     * @param tokenAmounts Token amounts. Needs a value for each pool token.
     * @param bptAmount BPT amount for comparison (in EVM scale).
     * @param isJoin boolean indicating if the price impact is for a join or exit.
     * @returns price impact in EVM scale.
     */
    calcPriceImpact: (tokenAmounts: string[], bptAmount: string, isJoin: boolean) => Promise<string>;
    /**
     * Build exit pool transaction parameters with exact BPT in and minimum token amounts out based on slippage tolerance
     * @param exiter Account address exiting pool
     * @param bptIn BPT provided for exiting pool in EVM scale
     * @param slippage Maximum slippage tolerance in bps. i.e. 50 = 5%
     * @param shouldUnwrapNativeAsset Indicates whether wrapped native asset should be unwrapped after exit. Defaults to false.
     * @param singleTokenOut Optional: token address that if provided will exit to given token
     * @returns transaction request ready to send with signer.sendTransaction
     */
    buildExitExactBPTIn: (exiter: string, bptIn: string, slippage: string, shouldUnwrapNativeAsset?: boolean, singleTokenOut?: string, toInternalBalance?: boolean) => ExitExactBPTInAttributes;
    /**
     * Build exit pool transaction parameters with exact tokens out and maximum BPT in based on slippage tolerance
     * @param exiter Account address exiting pool
     * @param tokensOut Tokens provided for exiting pool (same length and order as amountsOut)
     * @param amountsOut Amounts provided for exiting pool in EVM scale
     * @param slippage Maximum slippage tolerance in bps. i.e. 50 = 5%
     * @returns transaction request ready to send with signer.sendTransaction
     */
    buildExitExactTokensOut: (exiter: string, tokensOut: string[], amountsOut: string[], slippage: string, toInternalBalance?: boolean) => ExitExactTokensOutAttributes;
    /**
     * Build recovery exit pool transaction parameters with exact BPT in and minimum token amounts out based on slippage tolerance
     * @param exiter Account address exiting pool
     * @param bptIn BPT amount in EVM scale
     * @param slippage Maximum slippage tolerance in basis points. i.e. 50 = 5%
     * @returns transaction request ready to send with signer.sendTransaction
     */
    buildRecoveryExit: (exiter: string, bptIn: string, slippage: string, toInternalBalance?: boolean) => ExitExactBPTInAttributes;
    /**
     * Calculate spot price for swapping tokenIn with tokenOut
     * @param tokenIn Token address
     * @param tokenOut Token address
     * @returns spot price for swapping tokenIn with tokenOut in EVM scale
     */
    calcSpotPrice: (tokenIn: string, tokenOut: string) => string;
    bptIndex: number;
}
interface GraphQLQuery {
    args: GraphQLArgs;
    attrs: any;
}
type CoingeckoConfig = {
    coingeckoApiKey: string;
    tokensPerPriceRequest?: number;
    isDemoApiKey?: boolean;
};

/**
 * Splits a poolId into its components, i.e. pool address, pool specialization and its nonce
 * @param poolId - a bytes32 string of the pool's ID
 * @returns an object with the decomposed poolId
 */
declare const splitPoolId: (poolId: string) => {
    address: string;
    specialization: PoolSpecialization;
    nonce: BigNumber;
};
/**
 * Extracts a pool's address from its poolId
 * @param poolId - a bytes32 string of the pool's ID
 * @returns the pool's address
 */
declare const getPoolAddress: (poolId: string) => string;
/**
 * Extracts a pool's specialization from its poolId
 * @param poolId - a bytes32 string of the pool's ID
 * @returns the pool's specialization
 */
declare const getPoolSpecialization: (poolId: string) => PoolSpecialization;
/**
 * Extracts a pool's nonce from its poolId
 * @param poolId - a bytes32 string of the pool's ID
 * @returns the pool's nonce
 */
declare const getPoolNonce: (poolId: string) => BigNumber;

interface TokenAmounts {
    [token: string]: string;
}
interface SwapsOptions {
    maxPools?: number;
    gasPrice?: string;
    deadline?: string;
    maxSlippage?: number;
}
declare enum SwapType {
    SwapExactIn = 0,
    SwapExactOut = 1
}
type FundManagement = {
    sender: string;
    recipient: string;
    fromInternalBalance: boolean;
    toInternalBalance: boolean;
};
type SingleSwap = {
    poolId: string;
    kind: SwapType;
    assetIn: string;
    assetOut: string;
    amount: BigNumberish;
    userData: string;
};
type Swap = {
    request: SingleSwap;
    funds: FundManagement;
    limit: BigNumberish;
    deadline: BigNumberish;
    value?: BigNumberish;
    outputReference?: BigNumberish;
};
type BatchSwapStep = {
    poolId: string;
    assetInIndex: number;
    assetOutIndex: number;
    amount: string;
    userData: string;
};
type BatchSwap = {
    kind: SwapType;
    swaps: BatchSwapStep[];
    assets: string[];
    funds: FundManagement;
    limits: BigNumberish[];
    deadline: BigNumberish;
    value?: BigNumberish;
    outputReferences?: {
        index: BigNumberish;
        key: BigNumberish;
    }[];
};
interface SwapInput {
    tokenIn: string;
    tokenOut: string;
    swapType: SwapType;
    amount: string;
}
interface QuerySimpleFlashSwapParameters {
    poolIds: string[];
    assets: BatchSwap['assets'];
    flashLoanAmount: string;
    vaultContract: Vault;
}
interface SimpleFlashSwapParameters {
    poolIds: string[];
    assets: BatchSwap['assets'];
    flashLoanAmount: string;
    walletAddress: string;
}
interface QuerySimpleFlashSwapResponse {
    profits: Record<string, string>;
    isProfitable: boolean;
}
interface FindRouteParameters {
    tokenIn: string;
    tokenOut: string;
    amount: BigNumber;
    gasPrice: BigNumber;
    maxPools?: number;
}
interface BuildTransactionParameters {
    userAddress: string;
    recipient?: string;
    swapInfo: SwapInfo;
    kind: SwapType;
    deadline: string;
    maxSlippage: number;
}
interface SwapTransactionRequest {
    to: string;
    data: string;
    value?: BigNumber;
}
interface SwapAttributes {
    to: string;
    functionName: string;
    attributes: Swap | BatchSwap;
    data: string;
    value?: BigNumber;
}

/**
 * Helper to create limits using a defined slippage amount.
 * @param tokensIn - Array of token in addresses.
 * @param tokensOut - Array of token out addresses.
 * @param swapType - Type of swap - SwapExactIn or SwapExactOut
 * @param deltas - An array with the net Vault asset balance deltas. Positive amounts represent tokens (or ETH) sent to the Vault, and negative amounts represent tokens (or ETH) sent by the Vault. Each delta corresponds to the asset at the same index in the `assets` array.
 * @param assets - array contains the addresses of all assets involved in the swaps.
 * @param slippage - Slippage to be applied. i.e. 5%=50000000000000000.
 * @returns Returns an array (same length as assets) with limits applied for each asset.
 */
declare function getLimitsForSlippage(tokensIn: string[], tokensOut: string[], swapType: SwapType, deltas: BigNumberish[], assets: string[], slippage: BigNumberish): BigNumberish[];

interface PoolBPTValue {
    address: string;
    liquidity: string;
}
declare class Liquidity {
    private pools;
    private tokenPrices;
    constructor(pools: Findable<Pool$1, PoolAttribute>, tokenPrices: Findable<Price>);
    getLiquidity(pool: Pool$1): Promise<string>;
    getBptPrice(pool: Pool$1): Promise<string>;
}

declare class Swaps {
    readonly sor: SOR;
    chainId: number;
    vaultContract: Vault;
    constructor(sorOrConfig: SOR | BalancerSdkConfig);
    static getLimitsForSlippage(tokensIn: string[], tokensOut: string[], swapType: SwapType, deltas: string[], assets: string[], slippage: string): string[];
    /**
     * Uses SOR to find optimal route for a trading pair and amount
     *
     * @param FindRouteParameters
     * @param FindRouteParameters.tokenIn Address
     * @param FindRouteParameters.tokenOut Address
     * @param FindRouteParameters.amount BigNumber with a trade amount
     * @param FindRouteParameters.gasPrice BigNumber current gas price
     * @param FindRouteParameters.maxPools number of pool included in path, default 4
     * @returns Best trade route information
     */
    findRouteGivenIn({ tokenIn, tokenOut, amount, gasPrice, maxPools, }: FindRouteParameters): Promise<SwapInfo>;
    /**
     * Uses SOR to find optimal route for a trading pair and amount
     *
     * @param FindRouteParameters
     * @param FindRouteParameters.tokenIn Address
     * @param FindRouteParameters.tokenOut Address
     * @param FindRouteParameters.amount BigNumber with a trade amount
     * @param FindRouteParameters.gasPrice BigNumber current gas price
     * @param FindRouteParameters.maxPools number of pool included in path, default 4
     * @returns Best trade route information
     */
    findRouteGivenOut({ tokenIn, tokenOut, amount, gasPrice, maxPools, }: FindRouteParameters): Promise<SwapInfo>;
    /**
     * Uses SOR to find optimal route for a trading pair and amount
     *
     * @param BuildTransactionParameters
     * @param BuildTransactionParameters.userAddress Address
     * @param BuildTransactionParameters.swapInfo result of route finding
     * @param BuildTransactionParameters.kind 0 - givenIn, 1 - givenOut
     * @param BuildTransactionParameters.deadline block linux timestamp as string
     * @param BuildTransactionParameters.maxSlippage [bps], eg: 1 === 0.01%, 100 === 1%
     * @returns transaction request ready to send with signer.sendTransaction
     */
    buildSwap({ userAddress, recipient, swapInfo, kind, deadline, maxSlippage, }: BuildTransactionParameters): SwapAttributes;
    /**
     * Uses SOR to find optimal route for a trading pair and amount
     * and builds a transaction request
     *
     * @param sender Sender of the swap
     * @param recipient Reciever of the swap
     * @param tokenIn Address of tokenIn
     * @param tokenOut Address of tokenOut
     * @param amount Amount of tokenIn to swap as a string with 18 decimals precision
     * @param options
     * @param options.maxPools number of pool included in path
     * @param options.gasPrice BigNumber current gas price
     * @param options.deadline BigNumber block timestamp
     * @param options.maxSlippage [bps], eg: 1 === 0.01%, 100 === 1%
     * @returns transaction request ready to send with signer.sendTransaction
     */
    buildRouteExactIn(sender: string, recipient: string, tokenIn: string, tokenOut: string, amount: string, options?: SwapsOptions): Promise<SwapAttributes>;
    /**
     * Encode batchSwap in an ABI byte string
     *
     * [See method for a batchSwap](https://dev.balancer.fi/references/contracts/apis/the-vault#batch-swaps).
     *
     * _NB: This method doesn't execute a batchSwap -- it returns an [ABI byte string](https://docs.soliditylang.org/en/latest/abi-spec.html)
     * containing the data of the function call on a contract, which can then be sent to the network to be executed.
     * (ex. [sendTransaction](https://web3js.readthedocs.io/en/v1.2.11/web3-eth.html#sendtransaction)).
     *
     * @param {BatchSwap}           batchSwap - BatchSwap information used for query.
     * @param {SwapType}            batchSwap.kind - either exactIn or exactOut
     * @param {BatchSwapSteps[]}    batchSwap.swaps - sequence of swaps
     * @param {string[]}            batchSwap.assets - array contains the addresses of all assets involved in the swaps
     * @param {FundManagement}      batchSwap.funds - object containing information about where funds should be taken/sent
     * @param {number[]}            batchSwap.limits - limits for each token involved in the swap, where either the maximum number of tokens to send (by passing a positive value) or the minimum amount of tokens to receive (by passing a negative value) is specified
     * @param {string}              batchSwap.deadline -  time (in Unix timestamp) after which it will no longer attempt to make a trade
     * @returns {string}            encodedBatchSwapData - Returns an ABI byte string containing the data of the function call on a contract
     */
    static encodeBatchSwap(batchSwap: BatchSwap): string;
    /**
     * Encode simple flash swap into a ABI byte string
     *
     * A "simple" flash swap is an arbitrage executed with only two tokens and two pools,
     * swapping in the first pool and then back in the second pool for a profit. For more
     * complex flash swaps, you will have to use the batch swap method.
     *
     * Learn more: A [Flash Swap](https://dev.balancer.fi/resources/swaps/flash-swaps).
     *
     * @param {SimpleFlashSwapParameters}   params - BatchSwap information used for query.
     * @param {string}                      params.flashLoanAmount - initial input amount for the flash loan (first asset)
     * @param {string[]}                    params.poolIds - array of Balancer pool ids
     * @param {string[]}                    params.assets - array of token addresses
     * @param {string}                      params.walletAddress - array of token addresses
     * @returns {string}                    encodedBatchSwapData - Returns an ABI byte string containing the data of the function call on a contract
     */
    static encodeSimpleFlashSwap(params: SimpleFlashSwapParameters): string;
    /**
     * fetchPools saves updated pools data to SOR internal onChainBalanceCache.
     *
     * @returns Boolean indicating whether pools data was fetched correctly (true) or not (false).
     */
    fetchPools(queryArgs?: GraphQLArgs): Promise<boolean>;
    getPools(): SubgraphPoolBase[];
    /**
     * queryBatchSwap simulates a call to `batchSwap`, returning an array of Vault asset deltas.
     * @param batchSwap - BatchSwap information used for query.
     * @param {SwapType} batchSwap.kind - either exactIn or exactOut.
     * @param {BatchSwapStep[]} batchSwap.swaps - sequence of swaps.
     * @param {string[]} batchSwap.assets - array contains the addresses of all assets involved in the swaps.
     * @returns {Promise<string[]>} Returns an array with the net Vault asset balance deltas. Positive amounts represent tokens (or ETH) sent to the
     * Vault, and negative amounts represent tokens (or ETH) sent by the Vault. Each delta corresponds to the asset at
     * the same index in the `assets` array.
     */
    queryBatchSwap(batchSwap: Pick<BatchSwap, 'kind' | 'swaps' | 'assets'>): Promise<string[]>;
    /**
     * Simple interface to test if a simple flash swap is valid and see potential profits.
     *
     * A "simple" flash swap is an arbitrage executed with only two tokens and two pools,
     * swapping in the first pool and then back in the second pool for a profit. For more
     * complex flash swaps, you will have to use the batch swap method.
     *
     * Learn more: A [Flash Swap](https://dev.balancer.fi/resources/swaps/flash-swaps).
     *
     * _NB: This method doesn't execute a flashSwap
     *
     * @param {SimpleFlashSwapParameters}   params - BatchSwap information used for query.
     * @param {string}                      params.flashLoanAmount - initial input amount for the flash loan (first asset)
     * @param {string[]}                    params.poolIds - array of Balancer pool ids
     * @param {string[]}                    params.assets - array of token addresses
     * @returns {Promise<{profits: Record<string, string>, isProfitable: boolean}>}       Returns an ethersjs transaction response
     */
    querySimpleFlashSwap(params: Omit<QuerySimpleFlashSwapParameters, 'vaultContract'>): Promise<QuerySimpleFlashSwapResponse>;
    /**
     * Use SOR to get swapInfo for tokenIn<>tokenOut.
     * @param {SwapInput} swapInput - Swap information used for querying using SOR.
     * @param {string} swapInput.tokenIn - Addresse of asset in.
     * @param {string} swapInput.tokenOut - Addresse of asset out.
     * @param {SwapType} swapInput.swapType - Type of Swap, ExactIn/Out.
     * @param {string} swapInput.amount - Amount used in swap.
     * @returns {Promise<SwapInfo>} SOR swap info.
     */
    getSorSwap(swapInput: SwapInput): Promise<SwapInfo>;
    queryExactIn(swap: SwapInfo): Promise<TokenAmounts>;
    queryExactOut(swap: SwapInfo): Promise<TokenAmounts>;
    private query;
    private assetDeltas;
}

declare enum PoolKind {
    WEIGHTED = 0,
    LEGACY_STABLE = 1,
    COMPOSABLE_STABLE = 2,
    COMPOSABLE_STABLE_V2 = 3
}
type OutputReference = {
    index: number;
    key: BigNumber;
};
interface EncodeBatchSwapInput {
    swapType: SwapType;
    swaps: BatchSwapStep[];
    assets: string[];
    funds: FundManagement;
    limits: string[];
    deadline: BigNumberish;
    value: BigNumberish;
    outputReferences: OutputReference[];
}
interface EncodeExitPoolInput {
    poolId: string;
    poolKind: number;
    sender: string;
    recipient: string;
    outputReferences: OutputReference[];
    exitPoolRequest: ExitPoolRequest$1;
}
interface EncodeJoinPoolInput {
    poolId: string;
    kind: number;
    sender: string;
    recipient: string;
    joinPoolRequest: JoinPoolRequest$1;
    value: BigNumberish;
    outputReference: string;
}
interface EncodeWrapAaveDynamicTokenInput {
    staticToken: string;
    sender: string;
    recipient: string;
    amount: BigNumberish;
    fromUnderlying: boolean;
    outputReference: BigNumberish;
}
interface EncodeUnwrapAaveStaticTokenInput {
    staticToken: string;
    sender: string;
    recipient: string;
    amount: BigNumberish;
    toUnderlying: boolean;
    outputReference: BigNumberish;
}
interface EncodeUnwrapInput {
    wrappedToken: string;
    sender: string;
    recipient: string;
    amount: BigNumberish;
    outputReference: BigNumberish;
}
interface EncodeUnwrapWstETHInput {
    sender: string;
    recipient: string;
    amount: BigNumberish;
    outputReference: BigNumberish;
}
type ExitPoolData = ExitPoolRequest$1 & EncodeExitPoolInput;
type JoinPoolData = JoinPoolRequest$1 & EncodeJoinPoolInput;

declare class Relayer {
    static CHAINED_REFERENCE_TEMP_PREFIX: string;
    static CHAINED_REFERENCE_READONLY_PREFIX: string;
    static encodeApproveVault(tokenAddress: string, maxAmount: string): string;
    static encodeSetRelayerApproval(relayerAdress: string, approved: boolean, authorisation: string): string;
    static encodeGaugeWithdraw(gaugeAddress: string, sender: string, recipient: string, amount: string): string;
    static encodeGaugeDeposit(gaugeAddress: string, sender: string, recipient: string, amount: string): string;
    static encodeSwap(params: Swap): string;
    static encodeBatchSwap(params: EncodeBatchSwapInput): string;
    static encodeExitPool(params: EncodeExitPoolInput): string;
    static encodeJoinPool(params: EncodeJoinPoolInput): string;
    static encodeWrapAaveDynamicToken(params: EncodeWrapAaveDynamicTokenInput): string;
    static encodeUnwrapAaveStaticToken(params: EncodeUnwrapAaveStaticTokenInput): string;
    static encodeUnwrapWstETH(params: EncodeUnwrapWstETHInput): string;
    static encodeUnwrap(params: EncodeUnwrapInput, linearPoolType: string): string;
    static encodePeekChainedReferenceValue(reference: BigNumberish): string;
    static toChainedReference(key: BigNumberish, isTemporary?: boolean): BigNumber;
    static fromChainedReference(ref: string, isTemporary?: boolean): BigNumber;
    /**
     * Returns true if `amount` is not actually an amount, but rather a chained reference.
     */
    static isChainedReference(amount: string): boolean;
    static formatExitPoolInput(params: ExitPoolData): EncodeExitPoolInput;
    static formatJoinPoolInput(params: JoinPoolData): EncodeJoinPoolInput;
    static signRelayerApproval: (relayerAddress: string, signerAddress: string, signer: JsonRpcSigner, vault: Vault) => Promise<string>;
}

declare class Subgraph {
    readonly url: string;
    readonly client: SubgraphClient;
    constructor(config: BalancerSdkConfig);
    private initClient;
}

declare class Sor extends SOR {
    constructor(sdkConfig: BalancerSdkConfig);
    private static getSorConfig;
    private static getSorNetworkConfig;
    private static getPoolDataService;
    private static getTokenPriceService;
}

declare class Pricing {
    private readonly swaps;
    constructor(config: BalancerSdkConfig, swaps?: Swaps);
    /**
     * Retrieves pools using poolDataService.
     * @returns {boolean} Boolean indicating whether pools data was fetched correctly (true) or not (false).
     */
    fetchPools(): Promise<boolean>;
    /**
     * Get currently saved pools list (fetched using fetchPools()).
     * @returns {SubgraphPoolBase[]} pools list.
     */
    getPools(): SubgraphPoolBase[];
    /**
     * Calculates Spot Price for a token pair - finds most liquid path and uses this as reference SP.
     * @param { string } tokenIn Token in address.
     * @param { string } tokenOut Token out address.
     * @param { SubgraphPoolBase[] } pools Optional - Pool data. Will be fetched via dataProvider if not supplied.
     * @returns  { string } Spot price.
     */
    getSpotPrice(tokenIn: string, tokenOut: string, pools?: SubgraphPoolBase[]): Promise<string>;
}

type Asset = {
    priceDelta: number;
    weight: number;
};
type TokenPrices = {
    [key: string]: number;
};
declare class ImpermanentLossService {
    private tokenPrices;
    private tokenHistoricalPrices;
    constructor(tokenPrices: Findable<Price>, tokenHistoricalPrices: Findable<Price>);
    /**
     * entry point to calculate impermanent loss.
     *
     * The function will
     *  - retrieve the tokens' historical value at the desired time in the future
     *  - calculate the relative variation between current and historical value
     *  - return the IL in percentage rounded to 2 decimal places
     *
     * @param timestamp UNIX timestamp from which the IL is desired
     * @param pool the pool
     * @returns the impermanent loss as percentage rounded to 2 decimal places
     */
    calcImpLoss(timestamp: number, pool: Pool$1): Promise<number>;
    calculateImpermanentLoss(poolValueDelta: number, holdValueDelta: number): number;
    getPoolValueDelta(assets: Asset[]): number;
    getHoldValueDelta(assets: Asset[]): number;
    /**
     * prepare the data for calculating the impermanent loss
     *
     * @param entryTimestamp UNIX timestamp from which the IL is desired
     * @param pool the pool
     * @returns a list of pair weight/price delta for each token in the pool
     * @throws BalancerError if
     *  1. a token's price is unknown
     *  2. a token's weight is unknown
     *  3. the user has no liquidity invested in the pool
     */
    prepareData(entryTimestamp: number, pool: Pool$1): Promise<Asset[]>;
    getAssets(poolTokens: PoolToken[], exitPrices: TokenPrices, entryPrices: TokenPrices, weights: number[]): Asset[];
    getDelta(entryPrice: number, exitPrice: number): number;
    /**
     * returns the list of token's weights.
     *
     * @param poolTokens the pools' tokens
     * @returns the list of token's weights
     * @throws BalancerError if a token's weight is missing
     *
     */
    getWeights(poolTokens: PoolToken[]): number[];
    /**
     * get the current's tokens' prices
     * @param tokens the pools' tokens
     * @returns a list of tokens with prices
     */
    getExitPrices(tokens: PoolToken[]): Promise<TokenPrices>;
    /**
     * get the tokens' price at a given time
     *
     * @param timestamp the Unix timestamp
     * @param tokenAddresses the tokens' addresses
     * @returns a map of tokens' price
     */
    getEntryPrices(timestamp: number, tokenAddresses: string[]): Promise<TokenPrices>;
}

type SpotPrices = {
    [tokenIn: string]: string;
};
interface Node {
    address: string;
    id: string;
    joinAction: JoinAction;
    exitAction: ExitAction;
    isProportionalExit: boolean;
    type: string;
    children: Node[];
    marked: boolean;
    index: string;
    proportionOfParent: BigNumber;
    parent: Node | undefined;
    isLeaf: boolean;
    spotPrices: SpotPrices;
    decimals: number;
    balance: string;
    priceRate: string;
}
type JoinAction = 'input' | 'batchSwap' | 'wrap' | 'joinPool';
type ExitAction = 'output' | 'batchSwap' | 'unwrap' | 'exitPool';
declare class PoolGraph {
    private pools;
    constructor(pools: Findable<Pool$1, PoolAttribute>);
    buildGraphFromRootPool(poolId: string, tokensToUnwrap: string[]): Promise<Node>;
    getTokenTotal(pool: Pool$1): BigNumber;
    buildGraphFromPool(address: string, nodeIndex: number, parent: Node | undefined, proportionOfParent: BigNumber, tokensToUnwrap: string[]): Promise<[Node, number]>;
    /**
     * Updates isProportionalExit for Node if the pool supports it
     * @param pool
     * @param node
     */
    updateNodeIfProportionalExit(pool: Pool$1, node: Node): void;
    createLinearNodeChildren(linearPoolNode: Node, nodeIndex: number, linearPool: Pool$1, tokensToUnwrap: string[]): [Node, number];
    createWrappedTokenNode(linearPool: Pool$1, nodeIndex: number, parent: Node | undefined, proportionOfParent: BigNumber): [Node, number];
    static createInputTokenNode(nodeIndex: number, address: string, decimals: number, parent: Node | undefined, proportionOfParent: BigNumber, balance: string): [Node, number];
    static orderByBfs(root: Node): Node[];
    static getLeafAddresses(nodes: Node[]): string[];
    /**
     * Checks if list of Nodes only contains pools that support proportional exits
     * @param nodes
     * @returns
     */
    static isProportionalPools(nodes: Node[]): boolean;
    getGraphNodes: (isJoin: boolean, poolId: string, tokensToUnwrap: string[]) => Promise<Node[]>;
}

interface PoolDictionary {
    [poolId: string]: Pool;
}
type Pool = (WeightedPool$1 | StablePool$1 | LinearPool$1 | MetaStablePool | PhantomStablePool | ComposableStablePool$1) & {
    SubgraphType: string;
};
declare class PoolsSource {
    private poolDataService;
    private wrappedNativeAsset;
    poolsArray: SubgraphPoolBase[];
    poolsDict: PoolDictionary;
    constructor(poolDataService: PoolDataService, wrappedNativeAsset: string);
    dataSource(): PoolDataService;
    all(refresh?: boolean): Promise<SubgraphPoolBase[]>;
    parseToPoolsDict(pools: SubgraphPoolBase[]): PoolDictionary;
    parseNewPool(subgraphPool: SubgraphPoolBase): Pool | undefined;
    /**
     * Converts Subgraph array into PoolDictionary
     * @param refresh
     * @returns
     */
    poolsDictionary(refresh?: boolean): Promise<PoolDictionary>;
}

interface JoinPoolRequest {
    actionType: ActionType.Join;
    poolId: string;
    encodedUserData: string;
    outputReference: string;
}

interface ExitPoolRequest {
    actionType: ActionType.Exit;
    poolId: string;
    encodedUserData: string;
    outputReferences: OutputReference[];
}

interface SwapRequest extends Pick<Swap, 'request' | 'funds' | 'outputReference'> {
    actionType: ActionType.Swap;
}
interface BatchSwapRequest extends Pick<EncodeBatchSwapInput, 'swaps' | 'assets' | 'funds' | 'swapType' | 'outputReferences'> {
    actionType: ActionType.BatchSwap;
}

interface UnwrapRequest extends Pick<EncodeUnwrapAaveStaticTokenInput, 'amount' | 'outputReference'> {
    poolId: string;
    actionType: ActionType.Unwrap;
}

declare enum ActionType {
    BatchSwap = 0,
    Join = 1,
    Exit = 2,
    Swap = 3,
    Unwrap = 4
}
type Requests = BatchSwapRequest | JoinPoolRequest | ExitPoolRequest | SwapRequest | UnwrapRequest;
/**
 * Controller / use-case layer for interacting with pools data.
 */
declare class VaultModel {
    poolsSource: PoolsSource;
    constructor(poolDataService: PoolDataService, wrappedNativeAsset: string);
    updateDeltas(deltas: Record<string, BigNumber>, assets: string[], amounts: string[]): Record<string, BigNumber>;
    multicall(rawCalls: Requests[], refresh?: boolean): Promise<Record<string, BigNumber>>;
    static mapSwapRequest(call: Swap): SwapRequest;
    static mapBatchSwapRequest(call: EncodeBatchSwapInput): BatchSwapRequest;
    static mapJoinPoolRequest(call: EncodeJoinPoolInput): JoinPoolRequest;
    static mapExitPoolRequest(call: EncodeExitPoolInput): ExitPoolRequest;
    static mapUnwrapRequest(amount: BigNumberish, outputReference: BigNumberish, poolId: string): UnwrapRequest;
}

declare enum SimulationType {
    Tenderly = 0,
    VaultModel = 1,
    Static = 2
}
/**
 * Simulation module is responsible for simulating the results of a generalised
 * join or exit using different types of simulation, such as:
 * - Tenderly: uses Tenderly Simulation API (third party service)
 * - VaultModel: uses TS math, which may be less accurate (min. 99% accuracy)
 * - Static: uses staticCall, which is 100% accurate but requires vault approval
 *
 * This module allows a user to perform a simulation and check for expected
 * amounts out in order to make an informed decision on whether to proceed with
 * the transaction. These expected amounts out can be used as limits to prevent
 * frontrunning and ensure that the transaction will return minimum amounts out.
 */
declare class Simulation {
    private tenderlyHelper?;
    private vaultModel;
    constructor(networkConfig: BalancerNetworkConfig, poolDataService?: PoolDataService);
    simulateGeneralisedJoin: (to: string, multiRequests: Requests[][], encodedCall: string, outputIndexes: number[], userAddress: string, tokensIn: string[], signer: JsonRpcSigner, simulationType: SimulationType, value: string) => Promise<string[]>;
    simulateGeneralisedExit: (to: string, multiRequests: Requests[][], encodedCall: string, outputIndexes: number[], userAddress: string, tokenIn: string, signer: JsonRpcSigner, simulationType: SimulationType) => Promise<string[]>;
    private decodeResult;
    private simulateRequests;
}

declare class Join {
    private poolGraph;
    private simulationService;
    private relayer;
    private wrappedNativeAsset;
    constructor(poolGraph: PoolGraph, networkConfig: BalancerNetworkConfig, simulationService: Simulation);
    private checkInputs;
    joinPool(poolId: string, tokensIn: string[], amountsIn: string[], userAddress: string, slippage: string, signer: JsonRpcSigner, simulationType: SimulationType, authorisation?: string): Promise<{
        to: string;
        encodedCall: string;
        expectedOut: string;
        minOut: string;
        priceImpact: string;
        value: BigNumberish;
    }>;
    private assertDeltas;
    static getJoinPaths: (orderedNodes: Node[], tokensIn: string[], amountsIn: string[]) => Node[][];
    private static updateInputAmounts;
    private createCalls;
    static totalBptZeroPriceImpact: (joinPaths: Node[][]) => BigNumber;
    static bptOutZeroPiForInputNode: (inputNode: Node) => bigint;
    private amountsOutByJoinPath;
    private minAmountsOutByJoinPath;
    private updateDeltas;
    private createActionCalls;
    /**
     * Creates a map of node address and total proportion. Used for the case where there may be multiple inputs using same token, e.g. DAI input to 2 pools.
     * @param nodes nodes to consider.
     */
    static updateTotalProportions: (nodes: Node[]) => Record<string, BigNumber>;
    /**
     * Uses relayer to approve itself to act in behalf of the user
     *
     * @param authorisation Encoded authorisation call.
     * @returns relayer approval call
     */
    private createSetRelayerApproval;
    static updateNodeAmount: (node: Node, tokensIn: string[], amountsIn: string[], totalProportions: Record<string, BigNumber>) => Node;
    private createSwap;
    private createJoinPool;
    private getOutputRefValue;
    private shouldBeConsidered;
    private sendsToInternalBalance;
    private allImmediateChildrenSendToInternal;
    private allSiblingsSendToInternal;
    private replaceWrappedNativeAsset;
}

interface GeneralisedExitOutput {
    to: string;
    encodedCall: string;
    tokensOut: string[];
    expectedAmountsOut: string[];
    minAmountsOut: string[];
    priceImpact: string;
}
interface ExitInfo {
    tokensOut: string[];
    estimatedAmountsOut: string[];
    priceImpact: string;
    tokensToUnwrap: string[];
}
declare class Exit {
    private poolGraph;
    private simulationService;
    private wrappedNativeAsset;
    private relayer;
    constructor(poolGraph: PoolGraph, networkConfig: BalancerNetworkConfig, simulationService: Simulation);
    getExitInfo(poolId: string, amountBptIn: string, userAddress: string, signer: JsonRpcSigner): Promise<{
        tokensOut: string[];
        estimatedAmountsOut: string[];
        priceImpact: string;
        tokensToUnwrap: string[];
    }>;
    buildExitCall(poolId: string, amountBptIn: string, userAddress: string, slippage: string, signer: JsonRpcSigner, simulationType: SimulationType.Static | SimulationType.Tenderly, authorisation?: string, tokensToUnwrap?: string[]): Promise<{
        to: string;
        encodedCall: string;
        tokensOut: string[];
        expectedAmountsOut: string[];
        minAmountsOut: string[];
        priceImpact: string;
    }>;
    private getExit;
    private calculatePriceImpact;
    private assertDeltas;
    private amountsOutByExitPath;
    private amountsOutByTokenOut;
    private minAmountsOut;
    private getExitPaths;
    private createCalls;
    private updateDeltas;
    private createActionCalls;
    private createUnwrap;
    private createSwap;
    private createBatchSwap;
    private createExitPool;
    private createExitPoolProportional;
    private getOutputRef;
    private receivesFromInternal;
}

declare class PoolVolume {
    private yesterdaysPools;
    constructor(yesterdaysPools: Findable<Pool$1, PoolAttribute> | undefined);
    last24h(pool: Pool$1): Promise<number>;
}

declare class PoolFees {
    private yesterdaysPools;
    constructor(yesterdaysPools: Findable<Pool$1, PoolAttribute> | undefined);
    last24h(pool: Pool$1): Promise<number>;
}

type CreatePoolParameters = {
    name: string;
    symbol: string;
    tokenAddresses: string[];
    swapFeeEvm: string;
    owner: string;
    salt?: BytesLike$1;
};
interface ComposableStableCreatePoolParameters extends CreatePoolParameters {
    amplificationParameter: string;
    rateProviders: string[];
    tokenRateCacheDurations: string[];
    exemptFromYieldProtocolFeeFlags: boolean[];
    salt?: BytesLike$1;
}
interface WeightedCreatePoolParameters extends CreatePoolParameters {
    rateProviders: string[];
    normalizedWeights: BigNumberish[];
}
type LinearCreatePoolParameters = Pick<CreatePoolParameters, 'name' | 'symbol' | 'swapFeeEvm' | 'owner' | 'salt'> & {
    mainToken: string;
    wrappedToken: string;
    upperTargetEvm: string;
    protocolId: ProtocolId;
};
interface InitJoinPoolParameters {
    joiner: string;
    poolId: string;
    poolAddress: string;
    tokensIn: string[];
    amountsIn: string[];
}
interface InitJoinPoolAttributes {
    to: string;
    functionName: string;
    attributes: JoinPool;
    data: string;
    value?: BigNumber;
}
declare enum ProtocolId {
    AAVE_V1 = 0,
    AAVE_V2 = 1,
    AAVE_V3 = 2,
    AMPLEFORTH = 3,
    BEEFY = 4,
    EULER = 5,
    GEARBOX = 6,
    IDLE = 7,
    MORPHO = 8,
    RADIANT = 9,
    REAPER = 10,
    SILO = 11,
    STARGATE = 12,
    STURDY = 13,
    TESSERA = 14,
    TETU = 15,
    YEARN = 16,
    MIDAS = 17,
    AGAVE = 18
}
type JoinPoolDecodedAttributes = {
    poolId: string;
    sender: string;
    recipient: string;
    joinPoolRequest: JoinPoolRequestDecodedAttributes;
};
type JoinPoolRequestDecodedAttributes = {
    assets: string[];
    maxAmountsIn: string[];
    userData: string;
    fromInternalBalance: boolean;
};
type LinearPoolInterface = ERC4626LinearPoolInterface | EulerLinearPoolInterface | AaveLinearPoolInterface | YearnLinearPoolInterface | GearboxLinearPoolInterface;
type LinearPoolFactoryInterface = AaveLinearPoolFactoryInterface | ERC4626LinearPoolFactoryInterface | EulerLinearPoolFactoryInterface | GearboxLinearPoolFactoryInterface | YearnLinearPoolFactoryInterface;

interface PoolFactory {
    buildInitJoin: (parameters: InitJoinPoolParameters) => InitJoinPoolAttributes;
    getPoolAddressAndIdWithReceipt: (provider: JsonRpcProvider, receipt: TransactionReceipt) => Promise<{
        poolId: string;
        poolAddress: string;
    }>;
    create(parameters: ComposableStableCreatePoolParameters | WeightedCreatePoolParameters | LinearCreatePoolParameters): {
        to?: string;
        data: BytesLike$1;
    };
    getPoolInterface(): WeightedPoolInterface | ComposableStablePoolInterface | LinearPoolInterface;
}

/**
 * Wrapper around pool type specific methods.
 *
 * Returns a class instance of a type specific factory.
 */
declare class PoolFactory__factory {
    networkConfig: BalancerNetworkConfig;
    contracts: ContractInstances;
    constructor(networkConfig: BalancerNetworkConfig, balancerContracts: Contracts);
    of(poolType: PoolType): PoolFactory;
}

/**
 * Returns BAL emissions per pool
 */
declare class EmissionsService {
    private liquidityGaugesRepository;
    constructor(liquidityGaugesRepository: Findable<LiquidityGauge>);
    relativeWeight(poolId: string): Promise<number>;
    weekly(poolId: string): Promise<number>;
}

/**
 * Controller / use-case layer for interacting with pools data.
 */
declare class Pools implements Findable<PoolWithMethods> {
    private networkConfig;
    private repositories;
    private balancerContracts;
    aprService: PoolApr;
    liquidityService: Liquidity;
    joinService: Join;
    exitService: Exit;
    feesService: PoolFees;
    volumeService: PoolVolume;
    simulationService: Simulation;
    poolFactory: PoolFactory__factory;
    impermanentLossService: ImpermanentLossService;
    graphService: PoolGraph;
    emissionsService: EmissionsService | undefined;
    proportionalAmounts: (pool: {
        id: string;
        tokens: {
            address: string;
            balance: string;
            decimals?: number | undefined;
        }[];
    }, token: string, amount: string) => {
        tokens: string[];
        amounts: string[];
    };
    constructor(networkConfig: BalancerNetworkConfig, repositories: BalancerDataRepositories, balancerContracts: Contracts);
    static wrap(pool: Pool$1, networkConfig: BalancerNetworkConfig): PoolWithMethods;
    dataSource(): Findable<Pool$1, PoolAttribute> & Searchable<Pool$1>;
    /**
     * Calculates APR on any pool data
     *
     * @param pool
     * @returns
     */
    apr(pool: Pool$1): Promise<AprBreakdown>;
    /**
     * Calculates Impermanent Loss on any pool data
     *
     * @param timestamp
     * @param pool
     * @returns
     */
    impermanentLoss(timestamp: number, pool: Pool$1): Promise<number>;
    /**
     * Calculates total pool liquidity in USD
     *
     * @param pool
     * @returns total pool liquidity in USD
     */
    liquidity(pool: Pool$1): Promise<string>;
    /**
     * Calculates pool's BPT price in USD
     *
     * @param pool
     * @returns pool's BPT price in USD
     */
    bptPrice(pool: Pool$1): Promise<string>;
    /**
     * Builds join transaction
     *
     * @param pool            Pool
     * @param tokensIn        Token addresses
     * @param amountsIn       Token amounts in EVM scale
     * @param userAddress     User address
     * @param slippage        Maximum slippage tolerance in bps i.e. 50 = 0.5%.
     * @returns               Transaction object
     * @throws                Error if pool type is not implemented
     */
    buildJoin({ pool, tokensIn, amountsIn, userAddress, slippage, }: {
        pool: Pool$1;
        tokensIn: string[];
        amountsIn: string[];
        userAddress: string;
        slippage: string;
    }): JoinPoolAttributes;
    buildExitExactBPTIn({ pool, bptAmount, userAddress, slippage, shouldUnwrapNativeAsset, singleTokenOut, }: {
        pool: Pool$1;
        bptAmount: string;
        userAddress: string;
        slippage: string;
        shouldUnwrapNativeAsset?: boolean;
        singleTokenOut?: string;
    }): ExitExactBPTInAttributes;
    buildRecoveryExit({ pool, bptAmount, userAddress, slippage, toInternalBalance, }: {
        pool: Pool$1;
        bptAmount: string;
        userAddress: string;
        slippage: string;
        toInternalBalance?: boolean;
    }): ExitExactBPTInAttributes;
    /**
     * Builds generalised join transaction
     *
     * @param poolId          Pool id
     * @param tokens          Token addresses
     * @param amounts         Token amounts in EVM scale
     * @param userAddress     User address
     * @param slippage        Maximum slippage tolerance in bps i.e. 50 = 0.5%.
     * @param signer          JsonRpcSigner that will sign the staticCall transaction if Static simulation chosen
     * @param simulationType  Simulation type (VaultModel, Tenderly or Static)
     * @param authorisation   Optional auhtorisation call to be added to the chained transaction
     * @returns transaction data ready to be sent to the network along with min and expected BPT amounts out.
     */
    generalisedJoin(poolId: string, tokens: string[], amounts: string[], userAddress: string, slippage: string, signer: JsonRpcSigner, simulationType: SimulationType, authorisation?: string): Promise<{
        to: string;
        encodedCall: string;
        minOut: string;
        expectedOut: string;
        priceImpact: string;
        value: BigNumberish;
    }>;
    /**
     * Builds generalised exit transaction
     *
     * @param poolId          Pool id
     * @param amount          Token amount in EVM scale
     * @param userAddress     User address
     * @param slippage        Maximum slippage tolerance in bps i.e. 50 = 0.5%.
     * @param signer          JsonRpcSigner that will sign the staticCall transaction if Static simulation chosen
     * @param simulationType  Simulation type (Tenderly or Static) - VaultModel should not be used to build exit transaction
     * @param authorisation   Optional auhtorisation call to be added to the chained transaction
     * @param tokensToUnwrap  List all tokens that requires exit by unwrapping - info provided by getExitInfo
     * @returns transaction data ready to be sent to the network along with tokens, min and expected amounts out.
     */
    generalisedExit(poolId: string, amount: string, userAddress: string, slippage: string, signer: JsonRpcSigner, simulationType: SimulationType.Static | SimulationType.Tenderly, authorisation?: string, tokensToUnwrap?: string[]): Promise<GeneralisedExitOutput>;
    /**
     * Calculates price impact for an action on a pool
     *
     * @param pool
     * @returns percentage as a string in EVM scale
     */
    calcPriceImpact({ pool, tokenAmounts, bptAmount, isJoin, }: {
        pool: Pool$1;
        tokenAmounts: string[];
        bptAmount: string;
        isJoin: boolean;
    }): string;
    /**
     * Gets info required to build generalised exit transaction
     *
     * @param poolId          Pool id
     * @param amountBptIn     BPT amount in EVM scale
     * @param userAddress     User address
     * @param signer          JsonRpcSigner that will sign the staticCall transaction if Static simulation chosen
     * @returns info required to build a generalised exit transaction including whether tokens need to be unwrapped
     */
    getExitInfo(poolId: string, amountBptIn: string, userAddress: string, signer: JsonRpcSigner): Promise<ExitInfo>;
    /**
     * Calculates total fees for the pool in the last 24 hours
     *
     * @param pool
     * @returns
     */
    fees(pool: Pool$1): Promise<number>;
    /**
     * Calculates total volume of the pool in the last 24 hours
     *
     * @param pool
     * @returns
     */
    volume(pool: Pool$1): Promise<number>;
    find(id: string): Promise<PoolWithMethods | undefined>;
    findBy(param: string, value: string): Promise<PoolWithMethods | undefined>;
    all(): Promise<PoolWithMethods[]>;
    where(filter: (pool: Pool$1) => boolean): Promise<PoolWithMethods[]>;
}

/**
 * @param user - user address
 * @param from - pool ID
 * @param to - pool ID
 * @param balance - amount of liquidity to migrate in WAL (wei-ether)
 * @param minBptOut - minimum amount of BPT to receive, when 0 it will include a peek for the amount
 * @param authorisation - signed user's authorisation to approve relayer in the vault
 */
interface MigrationParams {
    user: string;
    from: string;
    to: string;
    balance: string;
    minBptOut?: string;
    authorisation?: string;
}
/**
 * Class responsible for building liquidity migration transactions.
 */
declare class Migrations {
    relayerAddress: string;
    poolsRepository: Findable<Pool$1, PoolAttribute>;
    gaugesRepository: Findable<SubgraphLiquidityGauge>;
    provider: JsonRpcProvider;
    /**
     * Instance of a class responsible for building liquidity migration transactions.
     *
     * @param relayerAddress Address of the relayer contract.
     * @param poolsRepository Repository of pools.
     * @param liquidityGaugesRepository Repository of liquidity gauges.
     * @param provider Provider to use for RPC data fetching.
     *
     * Available methods:
     * - `pool2pool` - Migrates liquidity from one pool to another.
     * - `pool2poolWithGauges` - Migrates liquidity from a pool's gauge to another gauge.
     * - `gauge2gauge` - Migrates liquidity from one gauge to another of the same pool.
     *
     * @example
     * ```typescript
     * const sdk = new BalancerSDK({
     *   network: 1,
     *   rpcUrl: 'https://rpc.ankr.com/eth',
     * })
     *
     * const migrations = new Migrations({
     *   relayerAddress: sdk.networkConfig.addresses.contracts.relayerV4 as string,
     *   poolsRepository: sdk.data.pools,
     *   gaugesRepository: sdk.data.liquidityGauges.subgraph,
     *   provider: sdk.provider
     * })
     *
     * const user = '0xfacec29Ae158B26e234B1a81Db2431F6Bd8F8cE8'
     * const from = '0x32296969ef14eb0c6d29669c550d4a0449130230000200000000000000000080'
     * const to = '0x32296969ef14eb0c6d29669c550d4a0449130230000200000000000000000080'
     * const balance = '1000000000000000000'
     * const { to, data } = await migrations.pool2pool({ user, from, to, balance })
     *
     * const tx = await sdk.provider.sendTransaction({ to, data })
     * ```
     */
    constructor({ relayerAddress, poolsRepository, gaugesRepository, provider, }: {
        relayerAddress: string;
        poolsRepository: Findable<Pool$1, PoolAttribute>;
        gaugesRepository: Findable<SubgraphLiquidityGauge>;
        provider: JsonRpcProvider;
    });
    /**
     * Takes user, from and to pool IDs as strings and returns the transaction data
     *
     * @returns transaction data
     */
    pool2pool({ user, from, to, balance, minBptOut, authorisation, }: MigrationParams): Promise<{
        to: string;
        data: string;
    }>;
    /**
     * Takes user, from and to pool IDs as strings and returns the transaction data
     * for a migration including unstaking and restaking
     *
     * @returns transaction data
     */
    pool2poolWithGauges({ user, from, to, balance, minBptOut, authorisation, }: MigrationParams): Promise<{
        to: string;
        data: string;
    }>;
    /**
     * Migrates staked liquidity for the same pool from one gauge to another.
     *
     * @returns transaction data
     */
    gauge2gauge({ user, from, to, balance, authorisation, }: MigrationParams): Promise<{
        to: string;
        data: string;
    }>;
    /**
     * Decodes the relayer return value to get the expected BPT out.
     *
     * @param relayerReturnValue
     * @returns
     */
    static getExpectedBptOut: (relayerReturnValue: string) => string;
    getExpectedBptOut: (relayerReturnValue: string) => string;
}

interface BalancerSDKRoot {
    config: BalancerSdkConfig;
    sor: Sor;
    subgraph: Subgraph;
    pools: Pools;
    data: Data;
    swaps: Swaps;
    relayer: Relayer;
    networkConfig: BalancerNetworkConfig;
    provider: JsonRpcProvider;
    claimService?: IClaimService;
}
declare class BalancerSDK implements BalancerSDKRoot {
    config: BalancerSdkConfig;
    sor: Sor;
    subgraph: Subgraph;
    readonly swaps: Swaps;
    readonly relayer: Relayer;
    readonly pricing: Pricing;
    readonly pools: Pools;
    readonly data: Data;
    balancerContracts: Contracts;
    vaultModel: VaultModel;
    readonly networkConfig: BalancerNetworkConfig;
    readonly provider: JsonRpcProvider;
    readonly claimService?: IClaimService;
    readonly migrationService?: Migrations;
    constructor(config: BalancerSdkConfig, sor?: Sor, subgraph?: Subgraph);
    /**
     * Expose balancer contracts, e.g. Vault, LidoRelayer.
     */
    get contracts(): ContractInstances;
}

declare function canUseJoinExit(swapType: SwapTypes, tokenIn: string, tokenOut: string): boolean;
/**
 * Find if any of the swaps are join/exits. If yes these swaps should be routed via Relayer.
 * @param pools
 * @param swaps
 * @param assets
 * @returns
 */
declare function someJoinExit(pools: SubgraphPoolBase[], swaps: SwapV2[], assets: string[]): boolean;
/**
 * Given swapInfo from the SOR construct the Relayer multicall to execture swaps/joins/exits.
 * @param swapInfo Returned from SOR
 * @param swapType Only supports ExactIn
 * @param pools Pool info from SOR
 * @param user Address of user
 * @param relayerAddress Address of Relayer (>=V4)
 * @param wrappedNativeAsset Address of Native asset
 * @param slippage [bps], eg: 1 === 0.01%, 100 === 1%
 * @param authorisation Encoded authorisation call.
 * @returns
 */
declare function buildRelayerCalls(swapInfo: SwapInfo, pools: SubgraphPoolBase[], user: string, relayerAddress: string, wrappedNativeAsset: string, slippage: string, authorisation: string | undefined): {
    to: string;
    data: string;
    rawCalls: string[];
    inputs: (EncodeBatchSwapInput | ExitPoolData | EncodeJoinPoolInput)[];
};

declare enum BalancerErrorCode {
    ABOVE_MAX_TOKENS = "ABOVE_MAX_TOKENS",
    BELOW_MIN_TOKENS = "BELOW_MIN_TOKENS",
    EXIT_DELTA_AMOUNTS = "EXIT_DELTA_AMOUNTS",
    FEE_PROVIDER_NOT_PROVIDED = "FEE_PROVIDER_NOT_PROVIDED",
    GAUGES_HELPER_ADDRESS_NOT_PROVIDED = "GAUGES_HELPER_ADDRESS_NOT_PROVIDED",
    GAUGES_NOT_FOUND = "GAUGES_NOT_FOUND",
    GAUGES_REWARD_MINTER_ADDRESS_NOT_PROVIDED = "GAUGES_REWARD_MINTER_ADDRESS_NOT_PROVIDED",
    GAUGES_REWARD_TOKEN_EMPTY = "GAUGES_REWARD_TOKEN_EMPTY",
    ILLEGAL_PARAMETER = "ILLEGAL_PARAMETER",
    INTERNAL_ERROR_INVALID_ABI = "INTERNAL_ERROR_INVALID_ABI",
    INPUT_LENGTH_MISMATCH = "INPUT_LENGTH_MISMATCH",
    INPUT_OUT_OF_BOUNDS = "INPUT_OUT_OF_BOUNDS",
    INPUT_TOKEN_INVALID = "INPUT_TOKEN_INVALID",
    INVALID_PROTOCOL_ID = "INVALID_PROTOCOL_ID",
    INVALID_SWAP_FEE_PERCENTAGE = "INVALID_SWAP_FEE_PERCENTAGE",
    INVALID_WEIGHTS = "INVALID_WEIGHTS",
    JOIN_DELTA_AMOUNTS = "JOIN_DELTA_AMOUNTS",
    JOIN_WITH_ZERO_AMOUNT = "JOIN_WITH_ZERO_AMOUNT",
    MISSING_AMP = "MISSING_AMP",
    MISSING_DECIMALS = "MISSING_DECIMALS",
    MISSING_PRICE_RATE = "MISSING_PRICE_RATE",
    MISSING_TOKENS = "MISSING_TOKENS",
    MISSING_WEIGHT = "MISSING_WEIGHT",
    NO_POOL_DATA = "NO_POOL_DATA",
    NO_VALUE_PARAMETER = "NO_VALUE_PARAMETER",
    POOL_DOESNT_EXIST = "POOL_DOESNT_EXIST",
    QUERY_BATCH_SWAP = "QUERY_BATCH_SWAP",
    RELAY_SWAP_AMOUNTS = "RELAY_SWAP_AMOUNTS",
    REWARD_TOKEN_ZERO = "REWARD_TOKEN_ZERO",
    TIMESTAMP_IN_THE_FUTURE = "TIMESTAMP_IN_THE_FUTURE",
    TOKEN_MISMATCH = "TOKEN_MISMATCH",
    UNSUPPORTED_PAIR = "UNSUPPORTED_PAIR",
    UNSUPPORTED_POOL_TYPE = "UNSUPPORTED_POOL_TYPE",
    UNSUPPORTED_POOL_TYPE_VERSION = "UNSUPPORTED_POOL_TYPE_VERSION"
}
declare class BalancerError extends Error {
    code: BalancerErrorCode;
    constructor(code: BalancerErrorCode);
    static getMessage(code: BalancerErrorCode): string;
}

declare const BALANCER_NETWORK_CONFIG: Record<Network, BalancerNetworkConfig>;

export { AMP_PRECISION, APR_THRESHOLD, AaveLinearPool, AaveLinearPoolFactory, AaveLinearPoolFactory__factory, AaveLinearPool__factory, AaveRates, AaveWrapping, AaveWrapping__factory, Account, Address, AprBreakdown, AssetHelpers, Authoriser, Authoriser__factory, BALANCER_NETWORK_CONFIG, BalancerAPIArgsFormatter, BalancerDataRepositories, BalancerError, BalancerErrorCode, BalancerErrors, BalancerHelpers, BalancerHelpers__factory, BalancerMinter, BalancerMinterAuthorization, BalancerMinter__factory, BalancerNetworkConfig, BalancerPoolDataQueries, BalancerPoolDataQueries__factory, BalancerRelayer, BalancerRelayer__factory, BalancerSDK, BalancerSDKRoot, BalancerSdkConfig, BalancerSdkSorConfig, BalancerTenderlyConfig, BaseFeeDistributor, BasePoolEncoder, BatchRelayerLibrary, BatchRelayerLibrary__factory, BatchSwap, BatchSwapStep, BlockNumberRepository, BuildTransactionParameters, Cacheable, CoingeckoConfig, CoingeckoHistoricalPriceRepository, CoingeckoPriceRepository, ComposableStableCreatePoolParameters, ComposableStablePool, ComposableStablePoolEncoder, ComposableStablePoolExitKind, ComposableStablePoolFactory, ComposableStablePoolFactory__factory, ComposableStablePoolJoinKind, ComposableStablePool__factory, ContractAddresses, ConvergentCurvePool, ConvergentCurvePool__factory, CreatePoolParameters, Currency, Data, Debouncer, ERC20, ERC20__factory, ERC4626LinearPool, ERC4626LinearPoolFactory, ERC4626LinearPoolFactory__factory, ERC4626LinearPool__factory, EncodeBatchSwapInput, EncodeExitPoolInput, EncodeJoinPoolInput, EncodeUnwrapAaveStaticTokenInput, EncodeUnwrapInput, EncodeUnwrapWstETHInput, EncodeWrapAaveDynamicTokenInput, EulerLinearPool, EulerLinearPoolFactory, EulerLinearPoolFactory__factory, EulerLinearPool__factory, ExitPoolData, ExitPoolRequest$1 as ExitPoolRequest, FXPool, FXPool__factory, FeeCollectorRepository, FeeDistributorData, FeeDistributorRepository, FindRouteParameters, Findable, FundManagement, GaugeClaimHelper, GaugeClaimHelper__factory, GaugeControllerMulticallRepository, GaugeShare, GaugeShareAttributes, GaugeSharesRepository, GearboxLinearPool, GearboxLinearPoolFactory, GearboxLinearPoolFactory__factory, GearboxLinearPool__factory, GraphQLArgs, GraphQLArgsBuilder, GraphQLArgsFormatter, GraphQLFilter, GraphQLFilterOperator, GraphQLQuery, GyroConfig, GyroConfig__factory, GyroEV2, GyroEV2__factory, HistoricalPriceProvider, HistoricalPrices, IAaveRates, InitJoinPoolAttributes, InitJoinPoolParameters, JoinPoolData, JoinPoolDecodedAttributes, JoinPoolRequest$1 as JoinPoolRequest, JoinPoolRequestDecodedAttributes, LidoRelayer, LidoRelayer__factory, LinearCreatePoolParameters, LinearPool, LinearPoolFactoryInterface, LinearPoolInterface, LinearPool__factory, Liquidity, LiquidityGauge, LiquidityGaugeSubgraphRPCProvider, LiquidityGaugeV5, LiquidityGaugeV5__factory, LiquidityGaugesMulticallRepository, LiquidityGaugesSubgraphRepository, ManagedPoolEncoder, Migrations, Multicall, Multicall3, Multicall3__factory, Multicall__factory, NamedPools, Network, OnchainPoolData, OnchainTokenData, OutputReference, POOLS, Pool$1 as Pool, PoolAttribute, PoolBPTValue, PoolBalanceOp, PoolBalanceOpKind, PoolGauges, PoolGaugesAttributes, PoolGaugesRepository, PoolJoinExit, PoolJoinExitAttributes, PoolJoinExitRepository, PoolKind, PoolReference, PoolRepository, PoolShare, PoolShareAttributes, PoolSharesRepository, PoolSpecialization, PoolToken, PoolType, PoolWithMethods, Pools, PoolsBalancerAPIRepository, PoolsFallbackRepository, PoolsFallbackRepositoryOptions, PoolsRepositoryFetchOptions, PoolsStaticRepository, PoolsSubgraphOnChainRepository, PoolsSubgraphRepository, Price, PriceRateProvider, ProtocolFees, ProtocolFeesProvider, ProtocolId, QuerySimpleFlashSwapParameters, QuerySimpleFlashSwapResponse, Relayer, RelayerAction, RelayerAuthorization, RewardData, SHALLOW_COMPOSABLE_STABLE_BUFFER, Searchable, SimpleFlashSwapParameters, SimulationType, SingleSwap, Sor, StablePhantomPoolJoinKind, StablePool, StablePoolEncoder, StablePoolExitKind, StablePoolJoinKind, StablePool__factory, StaticATokenRateProvider, StaticATokenRateProvider__factory, StaticTokenPriceProvider, StaticTokenProvider, SubPool, SubPoolMeta, Subgraph, SubgraphArgsFormatter, SubgraphPriceRepository, Swap, SwapAttributes, SwapInput, SwapTransactionRequest, SwapType, Swaps, SwapsOptions, Token, TokenAmounts, TokenAttribute, TokenPriceProvider, TokenPrices$1 as TokenPrices, TokenProvider, TokenYieldsRepository, TransactionData, UserBalanceOp, UserBalanceOpKind, Vault, Vault__factory, VeBal$1 as VeBal, VeBal__factory, VeDelegationProxy, VeDelegationProxy__factory, WeightedCreatePoolParameters, WeightedPool, WeightedPoolEncoder, WeightedPoolExitKind, WeightedPoolFactory, WeightedPoolFactory__factory, WeightedPoolJoinKind, WeightedPool__factory, YearnLinearPool, YearnLinearPoolFactory, YearnLinearPoolFactory__factory, YearnLinearPool__factory, accountToAddress, addSlippage, addressMapIn, emissions as balEmissions, bn, buildRelayerCalls, canUseJoinExit, index as factories, fetchOnChainPoolData, findEventInReceiptLogs, formatFixed, formatFromBigInt18, getEthValue, getLimitsForSlippage, getOnChainBalances, getPoolAddress, getPoolNonce, getPoolSpecialization, getRandomBytes32, insert, isLinearish, isNormalizedWeights, isSameAddress, mulSlippage, parseFixed, parsePoolInfo, parseToBigInt18, removeItem, reorderArrays, replace, signPermit, someJoinExit, splitPoolId, subSlippage, toNormalizedWeights, tokenAddressForPricing, tokensToTokenPrices, truncateAddresses, unwrapToken, wrappedTokensMap, yieldTokens };
